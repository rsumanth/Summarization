
File: butterworth_filter.py
 - Function 'make_lowpass' takes 3 arguments: frequency, samplerate, q_factor.  Docstring: Creates a low-pass filter

>>> filter = make_lowpass(1000, 48000)
>>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE
[1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.004277569313094809,
 0.008555138626189618, 0.004277569313094809]
 - Function 'make_highpass' takes 3 arguments: frequency, samplerate, q_factor.  Docstring: Creates a high-pass filter

>>> filter = make_highpass(1000, 48000)
>>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE
[1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.9957224306869052,
 -1.9914448613738105, 0.9957224306869052]
 - Function 'make_bandpass' takes 3 arguments: frequency, samplerate, q_factor.  Docstring: Creates a band-pass filter

>>> filter = make_bandpass(1000, 48000)
>>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE
[1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.06526309611002579,
 0, -0.06526309611002579]
 - Function 'make_allpass' takes 3 arguments: frequency, samplerate, q_factor.  Docstring: Creates an all-pass filter

>>> filter = make_allpass(1000, 48000)
>>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE
[1.0922959556412573, -1.9828897227476208, 0.9077040443587427, 0.9077040443587427,
 -1.9828897227476208, 1.0922959556412573]
 - Function 'make_peak' takes 4 arguments: frequency, samplerate, gain_db, q_factor.  Docstring: Creates a peak filter

>>> filter = make_peak(1000, 48000, 6)
>>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE
[1.0653405327119334, -1.9828897227476208, 0.9346594672880666, 1.1303715025601122,
 -1.9828897227476208, 0.8696284974398878]
 - Function 'make_lowshelf' takes 4 arguments: frequency, samplerate, gain_db, q_factor.  Docstring: Creates a low-shelf filter

>>> filter = make_lowshelf(1000, 48000, 6)
>>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE
[3.0409336710888786, -5.608870992220748, 2.602157875636628, 3.139954022810743,
 -5.591841778072785, 2.5201667380627257]
 - Function 'make_highshelf' takes 4 arguments: frequency, samplerate, gain_db, q_factor.  Docstring: Creates a high-shelf filter

>>> filter = make_highshelf(1000, 48000, 6)
>>> filter.a_coeffs + filter.b_coeffs  # doctest: +NORMALIZE_WHITESPACE
[2.2229172136088806, -3.9587208137297303, 1.7841414181566304, 4.295432981120543,
 -7.922740859457287, 3.6756456963725253]

File: iir_filter.py
 - Function '__init__' takes 2 arguments: self, order.  No docstring available.
 - Function 'set_coefficients' takes 3 arguments: self, a_coeffs, b_coeffs.  Docstring: Set the coefficients for the IIR filter. These should both be of size order + 1.
a_0 may be left out, and it will use 1.0 as default value.

This method works well with scipy's filter design functions
    >>> # Make a 2nd-order 1000Hz butterworth lowpass filter
    >>> import scipy.signal
    >>> b_coeffs, a_coeffs = scipy.signal.butter(2, 1000,
    ...                                          btype='lowpass',
    ...                                          fs=48000)
    >>> filt = IIRFilter(2)
    >>> filt.set_coefficients(a_coeffs, b_coeffs)
 - Function 'process' takes 2 arguments: self, sample.  Docstring: Calculate y[n]

>>> filt = IIRFilter(2)
>>> filt.process(0)
0.0

File: show_response.py
 - Function 'process' takes 2 arguments: self, sample.  Docstring: Calculate y[n]

>>> issubclass(FilterType, Protocol)
True
 - Function 'get_bounds' takes 2 arguments: fft_results, samplerate.  Docstring: Get bounds for printing fft results

>>> import numpy
>>> array = numpy.linspace(-20.0, 20.0, 1000)
>>> get_bounds(array, 1000)
(-20, 20)
 - Function 'show_frequency_response' takes 2 arguments: filter_type, samplerate.  Docstring: Show frequency response of a filter

>>> from audio_filters.iir_filter import IIRFilter
>>> filt = IIRFilter(4)
>>> show_frequency_response(filt, 48000)
 - Function 'show_phase_response' takes 2 arguments: filter_type, samplerate.  Docstring: Show phase response of a filter

>>> from audio_filters.iir_filter import IIRFilter
>>> filt = IIRFilter(4)
>>> show_phase_response(filt, 48000)

File: __init__.py

File: all_combinations.py
 - Function 'combination_lists' takes 2 arguments: n, k.  Docstring: >>> combination_lists(n=4, k=2)
[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]
 - Function 'generate_all_combinations' takes 2 arguments: n, k.  Docstring: >>> generate_all_combinations(n=4, k=2)
[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]
>>> generate_all_combinations(n=0, k=0)
[[]]
>>> generate_all_combinations(n=10, k=-1)
Traceback (most recent call last):
    ...
ValueError: k must not be negative
>>> generate_all_combinations(n=-1, k=10)
Traceback (most recent call last):
    ...
ValueError: n must not be negative
>>> generate_all_combinations(n=5, k=4)
[[1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 4, 5], [1, 3, 4, 5], [2, 3, 4, 5]]
>>> from itertools import combinations
>>> all(generate_all_combinations(n, k) == combination_lists(n, k)
...     for n in range(1, 6) for k in range(1, 6))
True
 - Function 'create_all_state' takes 5 arguments: increment, total_number, level, current_list, total_list.  No docstring available.

File: all_permutations.py
 - Function 'generate_all_permutations' takes 1 arguments: sequence.  No docstring available.
 - Function 'create_state_space_tree' takes 4 arguments: sequence, current_sequence, index, index_used.  Docstring: Creates a state space tree to iterate through each branch using DFS.
We know that each state has exactly len(sequence) - index children.
It terminates when it reaches the end of the given sequence.

:param sequence: The input sequence for which permutations are generated.
:param current_sequence: The current permutation being built.
:param index: The current index in the sequence.
:param index_used: list to track which elements are used in permutation.

Example 1:
>>> sequence = [1, 2, 3]
>>> current_sequence = []
>>> index_used = [False, False, False]
>>> create_state_space_tree(sequence, current_sequence, 0, index_used)
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]

Example 2:
>>> sequence = ["A", "B", "C"]
>>> current_sequence = []
>>> index_used = [False, False, False]
>>> create_state_space_tree(sequence, current_sequence, 0, index_used)
['A', 'B', 'C']
['A', 'C', 'B']
['B', 'A', 'C']
['B', 'C', 'A']
['C', 'A', 'B']
['C', 'B', 'A']

Example 3:
>>> sequence = [1]
>>> current_sequence = []
>>> index_used = [False]
>>> create_state_space_tree(sequence, current_sequence, 0, index_used)
[1]

File: all_subsequences.py
 - Function 'generate_all_subsequences' takes 1 arguments: sequence.  No docstring available.
 - Function 'create_state_space_tree' takes 3 arguments: sequence, current_subsequence, index.  Docstring: Creates a state space tree to iterate through each branch using DFS.
We know that each state has exactly two children.
It terminates when it reaches the end of the given sequence.

:param sequence: The input sequence for which subsequences are generated.
:param current_subsequence: The current subsequence being built.
:param index: The current index in the sequence.

Example:
>>> sequence = [3, 2, 1]
>>> current_subsequence = []
>>> create_state_space_tree(sequence, current_subsequence, 0)
[]
[1]
[2]
[2, 1]
[3]
[3, 1]
[3, 2]
[3, 2, 1]

>>> sequence = ["A", "B"]
>>> current_subsequence = []
>>> create_state_space_tree(sequence, current_subsequence, 0)
[]
['B']
['A']
['A', 'B']

>>> sequence = []
>>> current_subsequence = []
>>> create_state_space_tree(sequence, current_subsequence, 0)
[]

>>> sequence = [1, 2, 3, 4]
>>> current_subsequence = []
>>> create_state_space_tree(sequence, current_subsequence, 0)
[]
[4]
[3]
[3, 4]
[2]
[2, 4]
[2, 3]
[2, 3, 4]
[1]
[1, 4]
[1, 3]
[1, 3, 4]
[1, 2]
[1, 2, 4]
[1, 2, 3]
[1, 2, 3, 4]

File: coloring.py
 - Function 'valid_coloring' takes 3 arguments: neighbours, colored_vertices, color.  Docstring: For each neighbour check if the coloring constraint is satisfied
If any of the neighbours fail the constraint return False
If all neighbours validate the constraint return True

>>> neighbours = [0,1,0,1,0]
>>> colored_vertices = [0, 2, 1, 2, 0]

>>> color = 1
>>> valid_coloring(neighbours, colored_vertices, color)
True

>>> color = 2
>>> valid_coloring(neighbours, colored_vertices, color)
False
 - Function 'util_color' takes 4 arguments: graph, max_colors, colored_vertices, index.  Docstring: Pseudo-Code

Base Case:
1. Check if coloring is complete
    1.1 If complete return True (meaning that we successfully colored the graph)

Recursive Step:
2. Iterates over each color:
    Check if the current coloring is valid:
        2.1. Color given vertex
        2.2. Do recursive call, check if this coloring leads to a solution
        2.4. if current coloring leads to a solution return
        2.5. Uncolor given vertex

>>> graph = [[0, 1, 0, 0, 0],
...          [1, 0, 1, 0, 1],
...          [0, 1, 0, 1, 0],
...          [0, 1, 1, 0, 0],
...          [0, 1, 0, 0, 0]]
>>> max_colors = 3
>>> colored_vertices = [0, 1, 0, 0, 0]
>>> index = 3

>>> util_color(graph, max_colors, colored_vertices, index)
True

>>> max_colors = 2
>>> util_color(graph, max_colors, colored_vertices, index)
False
 - Function 'color' takes 2 arguments: graph, max_colors.  Docstring: Wrapper function to call subroutine called util_color
which will either return True or False.
If True is returned colored_vertices list is filled with correct colorings

>>> graph = [[0, 1, 0, 0, 0],
...          [1, 0, 1, 0, 1],
...          [0, 1, 0, 1, 0],
...          [0, 1, 1, 0, 0],
...          [0, 1, 0, 0, 0]]

>>> max_colors = 3
>>> color(graph, max_colors)
[0, 1, 0, 2, 0]

>>> max_colors = 2
>>> color(graph, max_colors)
[]

File: combination_sum.py
 - Function 'backtrack' takes 5 arguments: candidates, path, answer, target, previous_index.  Docstring: A recursive function that searches for possible combinations. Backtracks in case
of a bigger current combination value than the target value.

Parameters
----------
previous_index: Last index from the previous search
target: The value we need to obtain by summing our integers in the path list.
answer: A list of possible combinations
path: Current combination
candidates: A list of integers we can use.
 - Function 'combination_sum' takes 2 arguments: candidates, target.  Docstring: >>> combination_sum([2, 3, 5], 8)
[[2, 2, 2, 2], [2, 3, 3], [3, 5]]
>>> combination_sum([2, 3, 6, 7], 7)
[[2, 2, 3], [7]]
>>> combination_sum([-8, 2.3, 0], 1)
Traceback (most recent call last):
    ...
RecursionError: maximum recursion depth exceeded
 - Function 'main' takes 0 arguments: .  No docstring available.

File: crossword_puzzle_solver.py
 - Function 'is_valid' takes 5 arguments: puzzle, word, row, col, vertical.  Docstring: Check if a word can be placed at the given position.

>>> puzzle = [
...     ['', '', '', ''],
...     ['', '', '', ''],
...     ['', '', '', ''],
...     ['', '', '', '']
... ]
>>> is_valid(puzzle, 'word', 0, 0, True)
True
>>> puzzle = [
...     ['', '', '', ''],
...     ['', '', '', ''],
...     ['', '', '', ''],
...     ['', '', '', '']
... ]
>>> is_valid(puzzle, 'word', 0, 0, False)
True
 - Function 'place_word' takes 5 arguments: puzzle, word, row, col, vertical.  Docstring: Place a word at the given position.

>>> puzzle = [
...     ['', '', '', ''],
...     ['', '', '', ''],
...     ['', '', '', ''],
...     ['', '', '', '']
... ]
>>> place_word(puzzle, 'word', 0, 0, True)
>>> puzzle
[['w', '', '', ''], ['o', '', '', ''], ['r', '', '', ''], ['d', '', '', '']]
 - Function 'remove_word' takes 5 arguments: puzzle, word, row, col, vertical.  Docstring: Remove a word from the given position.

>>> puzzle = [
...     ['w', '', '', ''],
...     ['o', '', '', ''],
...     ['r', '', '', ''],
...     ['d', '', '', '']
... ]
>>> remove_word(puzzle, 'word', 0, 0, True)
>>> puzzle
[['', '', '', ''], ['', '', '', ''], ['', '', '', ''], ['', '', '', '']]
 - Function 'solve_crossword' takes 2 arguments: puzzle, words.  Docstring: Solve the crossword puzzle using backtracking.

>>> puzzle = [
...     ['', '', '', ''],
...     ['', '', '', ''],
...     ['', '', '', ''],
...     ['', '', '', '']
... ]

>>> words = ['word', 'four', 'more', 'last']
>>> solve_crossword(puzzle, words)
True
>>> puzzle = [
...     ['', '', '', ''],
...     ['', '', '', ''],
...     ['', '', '', ''],
...     ['', '', '', '']
... ]
>>> words = ['word', 'four', 'more', 'paragraphs']
>>> solve_crossword(puzzle, words)
False

File: generate_parentheses.py
 - Function 'backtrack' takes 5 arguments: partial, open_count, close_count, n, result.  Docstring: Generate valid combinations of balanced parentheses using recursion.

:param partial: A string representing the current combination.
:param open_count: An integer representing the count of open parentheses.
:param close_count: An integer representing the count of close parentheses.
:param n: An integer representing the total number of pairs.
:param result: A list to store valid combinations.
:return: None

This function uses recursion to explore all possible combinations,
ensuring that at each step, the parentheses remain balanced.

Example:
>>> result = []
>>> backtrack("", 0, 0, 2, result)
>>> result
['(())', '()()']
 - Function 'generate_parenthesis' takes 1 arguments: n.  Docstring: Generate valid combinations of balanced parentheses for a given n.

:param n: An integer representing the number of pairs of parentheses.
:return: A list of strings with valid combinations.

This function uses a recursive approach to generate the combinations.

Time Complexity: O(2^(2n)) - In the worst case, we have 2^(2n) combinations.
Space Complexity: O(n) - where 'n' is the number of pairs.

Example 1:
>>> generate_parenthesis(3)
['((()))', '(()())', '(())()', '()(())', '()()()']

Example 2:
>>> generate_parenthesis(1)
['()']

File: hamiltonian_cycle.py
 - Function 'valid_connection' takes 4 arguments: graph, next_ver, curr_ind, path.  Docstring: Checks whether it is possible to add next into path by validating 2 statements
1. There should be path between current and next vertex
2. Next vertex should not be in path
If both validations succeed we return True, saying that it is possible to connect
this vertices, otherwise we return False

Case 1:Use exact graph as in main function, with initialized values
>>> graph = [[0, 1, 0, 1, 0],
...          [1, 0, 1, 1, 1],
...          [0, 1, 0, 0, 1],
...          [1, 1, 0, 0, 1],
...          [0, 1, 1, 1, 0]]
>>> path = [0, -1, -1, -1, -1, 0]
>>> curr_ind = 1
>>> next_ver = 1
>>> valid_connection(graph, next_ver, curr_ind, path)
True

Case 2: Same graph, but trying to connect to node that is already in path
>>> path = [0, 1, 2, 4, -1, 0]
>>> curr_ind = 4
>>> next_ver = 1
>>> valid_connection(graph, next_ver, curr_ind, path)
False
 - Function 'util_hamilton_cycle' takes 3 arguments: graph, path, curr_ind.  Docstring: Pseudo-Code
Base Case:
1. Check if we visited all of vertices
    1.1 If last visited vertex has path to starting vertex return True either
        return False
Recursive Step:
2. Iterate over each vertex
    Check if next vertex is valid for transiting from current vertex
        2.1 Remember next vertex as next transition
        2.2 Do recursive call and check if going to this vertex solves problem
        2.3 If next vertex leads to solution return True
        2.4 Else backtrack, delete remembered vertex

Case 1: Use exact graph as in main function, with initialized values
>>> graph = [[0, 1, 0, 1, 0],
...          [1, 0, 1, 1, 1],
...          [0, 1, 0, 0, 1],
...          [1, 1, 0, 0, 1],
...          [0, 1, 1, 1, 0]]
>>> path = [0, -1, -1, -1, -1, 0]
>>> curr_ind = 1
>>> util_hamilton_cycle(graph, path, curr_ind)
True
>>> path
[0, 1, 2, 4, 3, 0]

Case 2: Use exact graph as in previous case, but in the properties taken from
    middle of calculation
>>> graph = [[0, 1, 0, 1, 0],
...          [1, 0, 1, 1, 1],
...          [0, 1, 0, 0, 1],
...          [1, 1, 0, 0, 1],
...          [0, 1, 1, 1, 0]]
>>> path = [0, 1, 2, -1, -1, 0]
>>> curr_ind = 3
>>> util_hamilton_cycle(graph, path, curr_ind)
True
>>> path
[0, 1, 2, 4, 3, 0]
 - Function 'hamilton_cycle' takes 2 arguments: graph, start_index.  Docstring: Wrapper function to call subroutine called util_hamilton_cycle,
which will either return array of vertices indicating hamiltonian cycle
or an empty list indicating that hamiltonian cycle was not found.
Case 1:
Following graph consists of 5 edges.
If we look closely, we can see that there are multiple Hamiltonian cycles.
For example one result is when we iterate like:
(0)->(1)->(2)->(4)->(3)->(0)

(0)---(1)---(2)
 |   /   \   |
 |  /     \  |
 | /       \ |
 |/         \|
(3)---------(4)
>>> graph = [[0, 1, 0, 1, 0],
...          [1, 0, 1, 1, 1],
...          [0, 1, 0, 0, 1],
...          [1, 1, 0, 0, 1],
...          [0, 1, 1, 1, 0]]
>>> hamilton_cycle(graph)
[0, 1, 2, 4, 3, 0]

Case 2:
Same Graph as it was in Case 1, changed starting index from default to 3

(0)---(1)---(2)
 |   /   \   |
 |  /     \  |
 | /       \ |
 |/         \|
(3)---------(4)
>>> graph = [[0, 1, 0, 1, 0],
...          [1, 0, 1, 1, 1],
...          [0, 1, 0, 0, 1],
...          [1, 1, 0, 0, 1],
...          [0, 1, 1, 1, 0]]
>>> hamilton_cycle(graph, 3)
[3, 0, 1, 2, 4, 3]

Case 3:
Following Graph is exactly what it was before, but edge 3-4 is removed.
Result is that there is no Hamiltonian Cycle anymore.

(0)---(1)---(2)
 |   /   \   |
 |  /     \  |
 | /       \ |
 |/         \|
(3)         (4)
>>> graph = [[0, 1, 0, 1, 0],
...          [1, 0, 1, 1, 1],
...          [0, 1, 0, 0, 1],
...          [1, 1, 0, 0, 0],
...          [0, 1, 1, 0, 0]]
>>> hamilton_cycle(graph,4)
[]

File: knight_tour.py
 - Function 'get_valid_pos' takes 2 arguments: position, n.  Docstring: Find all the valid positions a knight can move to from the current position.

>>> get_valid_pos((1, 3), 4)
[(2, 1), (0, 1), (3, 2)]
 - Function 'is_complete' takes 1 arguments: board.  Docstring: Check if the board (matrix) has been completely filled with non-zero values.

>>> is_complete([[1]])
True

>>> is_complete([[1, 2], [3, 0]])
False
 - Function 'open_knight_tour_helper' takes 3 arguments: board, pos, curr.  Docstring: Helper function to solve knight tour problem.
 - Function 'open_knight_tour' takes 1 arguments: n.  Docstring: Find the solution for the knight tour problem for a board of size n. Raises
ValueError if the tour cannot be performed for the given size.

>>> open_knight_tour(1)
[[1]]

>>> open_knight_tour(2)
Traceback (most recent call last):
    ...
ValueError: Open Knight Tour cannot be performed on a board of size 2

File: match_word_pattern.py
 - Function 'match_word_pattern' takes 2 arguments: pattern, input_string.  Docstring: Determine if a given pattern matches a string using backtracking.

pattern: The pattern to match.
input_string: The string to match against the pattern.
return: True if the pattern matches the string, False otherwise.

>>> match_word_pattern("aba", "GraphTreesGraph")
True

>>> match_word_pattern("xyx", "PythonRubyPython")
True

>>> match_word_pattern("GG", "PythonJavaPython")
False
 - Function 'backtrack' takes 2 arguments: pattern_index, str_index.  Docstring: >>> backtrack(0, 0)
True

>>> backtrack(0, 1)
True

>>> backtrack(0, 4)
False

File: minimax.py
 - Function 'minimax' takes 5 arguments: depth, node_index, is_max, scores, height.  Docstring: This function implements the minimax algorithm, which helps achieve the optimal
score for a player in a two-player game by checking all possible moves.
If the player is the maximizer, then the score is maximized.
If the player is the minimizer, then the score is minimized.

Parameters:
- depth: Current depth in the game tree.
- node_index: Index of the current node in the scores list.
- is_max: A boolean indicating whether the current move
          is for the maximizer (True) or minimizer (False).
- scores: A list containing the scores of the leaves of the game tree.
- height: The maximum height of the game tree.

Returns:
- An integer representing the optimal score for the current player.

>>> import math
>>> scores = [90, 23, 6, 33, 21, 65, 123, 34423]
>>> height = math.log(len(scores), 2)
>>> minimax(0, 0, True, scores, height)
65
>>> minimax(-1, 0, True, scores, height)
Traceback (most recent call last):
    ...
ValueError: Depth cannot be less than 0
>>> minimax(0, 0, True, [], 2)
Traceback (most recent call last):
    ...
ValueError: Scores cannot be empty
>>> scores = [3, 5, 2, 9, 12, 5, 23, 23]
>>> height = math.log(len(scores), 2)
>>> minimax(0, 0, True, scores, height)
12
 - Function 'main' takes 0 arguments: .  No docstring available.

File: n_queens.py
 - Function 'is_safe' takes 3 arguments: board, row, column.  Docstring: This function returns a boolean value True if it is safe to place a queen there
considering the current state of the board.

Parameters:
board (2D matrix): The chessboard
row, column: Coordinates of the cell on the board

Returns:
Boolean Value

>>> is_safe([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)
True
>>> is_safe([[1, 0, 0], [0, 0, 0], [0, 0, 0]], 1, 1)
False
 - Function 'solve' takes 2 arguments: board, row.  Docstring: This function creates a state space tree and calls the safe function until it
receives a False Boolean and terminates that branch and backtracks to the next
possible solution branch.
 - Function 'printboard' takes 1 arguments: board.  Docstring: Prints the boards that have a successful combination.

File: n_queens_math.py
 - Function 'depth_first_search' takes 5 arguments: possible_board, diagonal_right_collisions, diagonal_left_collisions, boards, n.  Docstring: >>> boards = []
>>> depth_first_search([], [], [], boards, 4)
>>> for board in boards:
...     print(board)
['. Q . . ', '. . . Q ', 'Q . . . ', '. . Q . ']
['. . Q . ', 'Q . . . ', '. . . Q ', '. Q . . ']
 - Function 'n_queens_solution' takes 1 arguments: n.  No docstring available.

File: power_sum.py
 - Function 'backtrack' takes 5 arguments: needed_sum, power, current_number, current_sum, solutions_count.  Docstring: >>> backtrack(13, 2, 1, 0, 0)
(0, 1)
>>> backtrack(10, 2, 1, 0, 0)
(0, 1)
>>> backtrack(10, 3, 1, 0, 0)
(0, 0)
>>> backtrack(20, 2, 1, 0, 0)
(0, 1)
>>> backtrack(15, 10, 1, 0, 0)
(0, 0)
>>> backtrack(16, 2, 1, 0, 0)
(0, 1)
>>> backtrack(20, 1, 1, 0, 0)
(0, 64)
 - Function 'solve' takes 2 arguments: needed_sum, power.  Docstring: >>> solve(13, 2)
1
>>> solve(10, 2)
1
>>> solve(10, 3)
0
>>> solve(20, 2)
1
>>> solve(15, 10)
0
>>> solve(16, 2)
1
>>> solve(20, 1)
Traceback (most recent call last):
    ...
ValueError: Invalid input
needed_sum must be between 1 and 1000, power between 2 and 10.
>>> solve(-10, 5)
Traceback (most recent call last):
    ...
ValueError: Invalid input
needed_sum must be between 1 and 1000, power between 2 and 10.

File: rat_in_maze.py
 - Function 'solve_maze' takes 5 arguments: maze, source_row, source_column, destination_row, destination_column.  Docstring: This method solves the "rat in maze" problem.
Parameters :
    - maze: A two dimensional matrix of zeros and ones.
    - source_row: The row index of the starting point.
    - source_column: The column index of the starting point.
    - destination_row: The row index of the destination point.
    - destination_column: The column index of the destination point.
Returns:
    - solution: A 2D matrix representing the solution path if it exists.
Raises:
    - ValueError: If no solution exists or if the source or
        destination coordinates are invalid.
Description:
    This method navigates through a maze represented as an n by n matrix,
    starting from a specified source cell and
    aiming to reach a destination cell.
    The maze consists of walls (1s) and open paths (0s).
    By providing custom row and column values, the source and destination
    cells can be adjusted.
>>> maze = [[0, 1, 0, 1, 1],
...         [0, 0, 0, 0, 0],
...         [1, 0, 1, 0, 1],
...         [0, 0, 1, 0, 0],
...         [1, 0, 0, 1, 0]]
>>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE
[[0, 1, 1, 1, 1],
[0, 0, 0, 0, 1],
[1, 1, 1, 0, 1],
[1, 1, 1, 0, 0],
[1, 1, 1, 1, 0]]

Note:
    In the output maze, the zeros (0s) represent one of the possible
    paths from the source to the destination.

>>> maze = [[0, 1, 0, 1, 1],
...         [0, 0, 0, 0, 0],
...         [0, 0, 0, 0, 1],
...         [0, 0, 0, 0, 0],
...         [0, 0, 0, 0, 0]]
>>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE
[[0, 1, 1, 1, 1],
[0, 1, 1, 1, 1],
[0, 1, 1, 1, 1],
[0, 1, 1, 1, 1],
[0, 0, 0, 0, 0]]

>>> maze = [[0, 0, 0],
...         [0, 1, 0],
...         [1, 0, 0]]
>>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE
[[0, 0, 0],
[1, 1, 0],
[1, 1, 0]]

>>> maze = [[1, 0, 0],
...         [0, 1, 0],
...         [1, 0, 0]]
>>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)    # doctest: +NORMALIZE_WHITESPACE
[[1, 0, 0],
[1, 1, 0],
[1, 1, 0]]

>>> maze = [[1, 1, 0, 0, 1, 0, 0, 1],
...         [1, 0, 1, 0, 0, 1, 1, 1],
...         [0, 1, 0, 1, 0, 0, 1, 0],
...         [1, 1, 1, 0, 0, 1, 0, 1],
...         [0, 1, 0, 0, 1, 0, 1, 1],
...         [0, 0, 0, 1, 1, 1, 0, 1],
...         [0, 1, 0, 1, 0, 1, 1, 1],
...         [1, 1, 0, 0, 0, 0, 0, 1]]
>>> solve_maze(maze,0,2,len(maze)-1,2)  # doctest: +NORMALIZE_WHITESPACE
[[1, 1, 0, 0, 1, 1, 1, 1],
[1, 1, 1, 0, 0, 1, 1, 1],
[1, 1, 1, 1, 0, 1, 1, 1],
[1, 1, 1, 0, 0, 1, 1, 1],
[1, 1, 0, 0, 1, 1, 1, 1],
[1, 1, 0, 1, 1, 1, 1, 1],
[1, 1, 0, 1, 1, 1, 1, 1],
[1, 1, 0, 1, 1, 1, 1, 1]]
>>> maze = [[1, 0, 0],
...         [0, 1, 1],
...         [1, 0, 1]]
>>> solve_maze(maze,0,1,len(maze)-1,len(maze)-1)
Traceback (most recent call last):
    ...
ValueError: No solution exists!

>>> maze = [[0, 0],
...         [1, 1]]
>>> solve_maze(maze,0,0,len(maze)-1,len(maze)-1)
Traceback (most recent call last):
    ...
ValueError: No solution exists!

>>> maze = [[0, 1],
...         [1, 0]]
>>> solve_maze(maze,2,0,len(maze)-1,len(maze)-1)
Traceback (most recent call last):
    ...
ValueError: Invalid source or destination coordinates

>>> maze = [[1, 0, 0],
...         [0, 1, 0],
...         [1, 0, 0]]
>>> solve_maze(maze,0,1,len(maze),len(maze)-1)
Traceback (most recent call last):
    ...
ValueError: Invalid source or destination coordinates
 - Function 'run_maze' takes 6 arguments: maze, i, j, destination_row, destination_column, solutions.  Docstring: This method is recursive starting from (i, j) and going in one of four directions:
up, down, left, right.
If a path is found to destination it returns True otherwise it returns False.
Parameters
    maze: A two dimensional matrix of zeros and ones.
    i, j : coordinates of matrix
    solutions: A two dimensional matrix of solutions.
Returns:
    Boolean if path is found True, Otherwise False.

File: sudoku.py
 - Function 'is_safe' takes 4 arguments: grid, row, column, n.  Docstring: This function checks the grid to see if each row,
column, and the 3x3 subgrids contain the digit 'n'.
It returns False if it is not 'safe' (a duplicate digit
is found) else returns True if it is 'safe'
 - Function 'find_empty_location' takes 1 arguments: grid.  Docstring: This function finds an empty location so that we can assign a number
for that particular row and column.
 - Function 'sudoku' takes 1 arguments: grid.  Docstring: Takes a partially filled-in grid and attempts to assign values to
all unassigned locations in such a way to meet the requirements
for Sudoku solution (non-duplication across rows, columns, and boxes)

>>> sudoku(initial_grid)  # doctest: +NORMALIZE_WHITESPACE
[[3, 1, 6, 5, 7, 8, 4, 9, 2],
 [5, 2, 9, 1, 3, 4, 7, 6, 8],
 [4, 8, 7, 6, 2, 9, 5, 3, 1],
 [2, 6, 3, 4, 1, 5, 9, 8, 7],
 [9, 7, 4, 8, 6, 3, 1, 2, 5],
 [8, 5, 1, 7, 9, 2, 6, 4, 3],
 [1, 3, 8, 9, 4, 7, 2, 5, 6],
 [6, 9, 2, 3, 5, 1, 8, 7, 4],
 [7, 4, 5, 2, 8, 6, 3, 1, 9]]
 >>> sudoku(no_solution) is None
 True
 - Function 'print_solution' takes 1 arguments: grid.  Docstring: A function to print the solution in the form
of a 9x9 grid

File: sum_of_subsets.py
 - Function 'generate_sum_of_subsets_soln' takes 2 arguments: nums, max_sum.  No docstring available.
 - Function 'create_state_space_tree' takes 6 arguments: nums, max_sum, num_index, path, result, remaining_nums_sum.  Docstring: Creates a state space tree to iterate through each branch using DFS.
It terminates the branching of a node when any of the two conditions
given below satisfy.
This algorithm follows depth-fist-search and backtracks when the node is not
branchable.

File: word_search.py
 - Function '__init__' takes 4 arguments: self, words, width, height.  No docstring available.
 - Function 'insert_north' takes 4 arguments: self, word, rows, cols.  Docstring: >>> ws = WordSearch(WORDS, 3, 3)
>>> ws.insert_north("cat", [2], [2])
>>> ws.board  # doctest: +NORMALIZE_WHITESPACE
[[None, None, 't'],
[None, None, 'a'],
[None, None, 'c']]
>>> ws.insert_north("at", [0, 1, 2], [2, 1])
>>> ws.board  # doctest: +NORMALIZE_WHITESPACE
[[None, 't', 't'],
[None, 'a', 'a'],
[None, None, 'c']]
 - Function 'insert_northeast' takes 4 arguments: self, word, rows, cols.  Docstring: >>> ws = WordSearch(WORDS, 3, 3)
>>> ws.insert_northeast("cat", [2], [0])
>>> ws.board  # doctest: +NORMALIZE_WHITESPACE
[[None, None, 't'],
[None, 'a', None],
['c', None, None]]
>>> ws.insert_northeast("at", [0, 1], [2, 1, 0])
>>> ws.board  # doctest: +NORMALIZE_WHITESPACE
[[None, 't', 't'],
['a', 'a', None],
['c', None, None]]
 - Function 'insert_east' takes 4 arguments: self, word, rows, cols.  Docstring: >>> ws = WordSearch(WORDS, 3, 3)
>>> ws.insert_east("cat", [1], [0])
>>> ws.board  # doctest: +NORMALIZE_WHITESPACE
[[None, None, None],
['c', 'a', 't'],
[None, None, None]]
>>> ws.insert_east("at", [1, 0], [2, 1, 0])
>>> ws.board  # doctest: +NORMALIZE_WHITESPACE
[[None, 'a', 't'],
['c', 'a', 't'],
[None, None, None]]
 - Function 'insert_southeast' takes 4 arguments: self, word, rows, cols.  Docstring: >>> ws = WordSearch(WORDS, 3, 3)
>>> ws.insert_southeast("cat", [0], [0])
>>> ws.board  # doctest: +NORMALIZE_WHITESPACE
[['c', None, None],
[None, 'a', None],
[None, None, 't']]
>>> ws.insert_southeast("at", [1, 0], [2, 1, 0])
>>> ws.board  # doctest: +NORMALIZE_WHITESPACE
[['c', None, None],
['a', 'a', None],
[None, 't', 't']]
 - Function 'insert_south' takes 4 arguments: self, word, rows, cols.  Docstring: >>> ws = WordSearch(WORDS, 3, 3)
>>> ws.insert_south("cat", [0], [0])
>>> ws.board  # doctest: +NORMALIZE_WHITESPACE
[['c', None, None],
['a', None, None],
['t', None, None]]
>>> ws.insert_south("at", [2, 1, 0], [0, 1, 2])
>>> ws.board  # doctest: +NORMALIZE_WHITESPACE
[['c', None, None],
['a', 'a', None],
['t', 't', None]]
 - Function 'insert_southwest' takes 4 arguments: self, word, rows, cols.  Docstring: >>> ws = WordSearch(WORDS, 3, 3)
>>> ws.insert_southwest("cat", [0], [2])
>>> ws.board  # doctest: +NORMALIZE_WHITESPACE
[[None, None, 'c'],
[None, 'a', None],
['t', None, None]]
>>> ws.insert_southwest("at", [1, 2], [2, 1, 0])
>>> ws.board  # doctest: +NORMALIZE_WHITESPACE
[[None, None, 'c'],
[None, 'a', 'a'],
['t', 't', None]]
 - Function 'insert_west' takes 4 arguments: self, word, rows, cols.  Docstring: >>> ws = WordSearch(WORDS, 3, 3)
>>> ws.insert_west("cat", [1], [2])
>>> ws.board  # doctest: +NORMALIZE_WHITESPACE
[[None, None, None],
['t', 'a', 'c'],
[None, None, None]]
>>> ws.insert_west("at", [1, 0], [1, 2, 0])
>>> ws.board  # doctest: +NORMALIZE_WHITESPACE
[['t', 'a', None],
['t', 'a', 'c'],
[None, None, None]]
 - Function 'insert_northwest' takes 4 arguments: self, word, rows, cols.  Docstring: >>> ws = WordSearch(WORDS, 3, 3)
>>> ws.insert_northwest("cat", [2], [2])
>>> ws.board  # doctest: +NORMALIZE_WHITESPACE
[['t', None, None],
[None, 'a', None],
[None, None, 'c']]
>>> ws.insert_northwest("at", [1, 2], [0, 1])
>>> ws.board  # doctest: +NORMALIZE_WHITESPACE
[['t', None, None],
['t', 'a', None],
[None, 'a', 'c']]
 - Function 'generate_board' takes 1 arguments: self.  Docstring: Generates a board with a random direction for each word.

>>> wt = WordSearch(WORDS, WIDTH, HEIGHT)
>>> wt.generate_board()
>>> len(list(filter(lambda word: word is not None, sum(wt.board, start=[])))
... ) == sum(map(lambda word: len(word), WORDS))
True
 - Function 'visualise_word_search' takes 1 arguments: board.  Docstring: Graphically displays the word search in the terminal.

>>> ws = WordSearch(WORDS, 5, 5)
>>> ws.insert_north("cat", [4], [4])
>>> visualise_word_search(
...     ws.board, add_fake_chars=False)  # doctest: +NORMALIZE_WHITESPACE
# # # # #
# # # # #
# # # # t
# # # # a
# # # # c
>>> ws.insert_northeast("snake", [4], [4, 3, 2, 1, 0])
>>> visualise_word_search(
...     ws.board, add_fake_chars=False)  # doctest: +NORMALIZE_WHITESPACE
# # # # e
# # # k #
# # a # t
# n # # a
s # # # c

File: binary_and_operator.py
 - Function 'binary_and' takes 2 arguments: a, b.  Docstring: Take in 2 integers, convert them to binary,
return a binary number that is the
result of a binary and operation on the integers provided.

>>> binary_and(25, 32)
'0b000000'
>>> binary_and(37, 50)
'0b100000'
>>> binary_and(21, 30)
'0b10100'
>>> binary_and(58, 73)
'0b0001000'
>>> binary_and(0, 255)
'0b00000000'
>>> binary_and(256, 256)
'0b100000000'
>>> binary_and(0, -1)
Traceback (most recent call last):
    ...
ValueError: the value of both inputs must be positive
>>> binary_and(0, 1.1)
Traceback (most recent call last):
    ...
ValueError: Unknown format code 'b' for object of type 'float'
>>> binary_and("0", "1")
Traceback (most recent call last):
    ...
TypeError: '<' not supported between instances of 'str' and 'int'

File: binary_coded_decimal.py
 - Function 'binary_coded_decimal' takes 1 arguments: number.  Docstring: Find binary coded decimal (bcd) of integer base 10.
Each digit of the number is represented by a 4-bit binary.
Example:
>>> binary_coded_decimal(-2)
'0b0000'
>>> binary_coded_decimal(-1)
'0b0000'
>>> binary_coded_decimal(0)
'0b0000'
>>> binary_coded_decimal(3)
'0b0011'
>>> binary_coded_decimal(2)
'0b0010'
>>> binary_coded_decimal(12)
'0b00010010'
>>> binary_coded_decimal(987)
'0b100110000111'

File: binary_count_setbits.py
 - Function 'binary_count_setbits' takes 1 arguments: a.  Docstring: Take in 1 integer, return a number that is
the number of 1's in binary representation of that number.

>>> binary_count_setbits(25)
3
>>> binary_count_setbits(36)
2
>>> binary_count_setbits(16)
1
>>> binary_count_setbits(58)
4
>>> binary_count_setbits(4294967295)
32
>>> binary_count_setbits(0)
0
>>> binary_count_setbits(-10)
Traceback (most recent call last):
    ...
ValueError: Input value must be a positive integer
>>> binary_count_setbits(0.8)
Traceback (most recent call last):
    ...
TypeError: Input value must be a 'int' type
>>> binary_count_setbits("0")
Traceback (most recent call last):
    ...
TypeError: '<' not supported between instances of 'str' and 'int'

File: binary_count_trailing_zeros.py
 - Function 'binary_count_trailing_zeros' takes 1 arguments: a.  Docstring: Take in 1 integer, return a number that is
the number of trailing zeros in binary representation of that number.

>>> binary_count_trailing_zeros(25)
0
>>> binary_count_trailing_zeros(36)
2
>>> binary_count_trailing_zeros(16)
4
>>> binary_count_trailing_zeros(58)
1
>>> binary_count_trailing_zeros(4294967296)
32
>>> binary_count_trailing_zeros(0)
0
>>> binary_count_trailing_zeros(-10)
Traceback (most recent call last):
    ...
ValueError: Input value must be a positive integer
>>> binary_count_trailing_zeros(0.8)
Traceback (most recent call last):
    ...
TypeError: Input value must be a 'int' type
>>> binary_count_trailing_zeros("0")
Traceback (most recent call last):
    ...
TypeError: '<' not supported between instances of 'str' and 'int'

File: binary_or_operator.py
 - Function 'binary_or' takes 2 arguments: a, b.  Docstring: Take in 2 integers, convert them to binary, and return a binary number that is the
result of a binary or operation on the integers provided.

>>> binary_or(25, 32)
'0b111001'
>>> binary_or(37, 50)
'0b110111'
>>> binary_or(21, 30)
'0b11111'
>>> binary_or(58, 73)
'0b1111011'
>>> binary_or(0, 255)
'0b11111111'
>>> binary_or(0, 256)
'0b100000000'
>>> binary_or(0, -1)
Traceback (most recent call last):
    ...
ValueError: the value of both inputs must be positive
>>> binary_or(0, 1.1)
Traceback (most recent call last):
    ...
TypeError: 'float' object cannot be interpreted as an integer
>>> binary_or("0", "1")
Traceback (most recent call last):
    ...
TypeError: '<' not supported between instances of 'str' and 'int'

File: binary_shifts.py
 - Function 'logical_left_shift' takes 2 arguments: number, shift_amount.  Docstring: Take in 2 positive integers.
'number' is the integer to be logically left shifted 'shift_amount' times.
i.e. (number << shift_amount)
Return the shifted binary representation.

>>> logical_left_shift(0, 1)
'0b00'
>>> logical_left_shift(1, 1)
'0b10'
>>> logical_left_shift(1, 5)
'0b100000'
>>> logical_left_shift(17, 2)
'0b1000100'
>>> logical_left_shift(1983, 4)
'0b111101111110000'
>>> logical_left_shift(1, -1)
Traceback (most recent call last):
    ...
ValueError: both inputs must be positive integers
 - Function 'logical_right_shift' takes 2 arguments: number, shift_amount.  Docstring: Take in positive 2 integers.
'number' is the integer to be logically right shifted 'shift_amount' times.
i.e. (number >>> shift_amount)
Return the shifted binary representation.

>>> logical_right_shift(0, 1)
'0b0'
>>> logical_right_shift(1, 1)
'0b0'
>>> logical_right_shift(1, 5)
'0b0'
>>> logical_right_shift(17, 2)
'0b100'
>>> logical_right_shift(1983, 4)
'0b1111011'
>>> logical_right_shift(1, -1)
Traceback (most recent call last):
    ...
ValueError: both inputs must be positive integers
 - Function 'arithmetic_right_shift' takes 2 arguments: number, shift_amount.  Docstring: Take in 2 integers.
'number' is the integer to be arithmetically right shifted 'shift_amount' times.
i.e. (number >> shift_amount)
Return the shifted binary representation.

>>> arithmetic_right_shift(0, 1)
'0b00'
>>> arithmetic_right_shift(1, 1)
'0b00'
>>> arithmetic_right_shift(-1, 1)
'0b11'
>>> arithmetic_right_shift(17, 2)
'0b000100'
>>> arithmetic_right_shift(-17, 2)
'0b111011'
>>> arithmetic_right_shift(-1983, 4)
'0b111110000100'

File: binary_twos_complement.py
 - Function 'twos_complement' takes 1 arguments: number.  Docstring: Take in a negative integer 'number'.
Return the two's complement representation of 'number'.

>>> twos_complement(0)
'0b0'
>>> twos_complement(-1)
'0b11'
>>> twos_complement(-5)
'0b1011'
>>> twos_complement(-17)
'0b101111'
>>> twos_complement(-207)
'0b100110001'
>>> twos_complement(1)
Traceback (most recent call last):
    ...
ValueError: input must be a negative integer

File: binary_xor_operator.py
 - Function 'binary_xor' takes 2 arguments: a, b.  Docstring: Take in 2 integers, convert them to binary,
return a binary number that is the
result of a binary xor operation on the integers provided.

>>> binary_xor(25, 32)
'0b111001'
>>> binary_xor(37, 50)
'0b010111'
>>> binary_xor(21, 30)
'0b01011'
>>> binary_xor(58, 73)
'0b1110011'
>>> binary_xor(0, 255)
'0b11111111'
>>> binary_xor(256, 256)
'0b000000000'
>>> binary_xor(0, -1)
Traceback (most recent call last):
    ...
ValueError: the value of both inputs must be positive
>>> binary_xor(0, 1.1)
Traceback (most recent call last):
    ...
TypeError: 'float' object cannot be interpreted as an integer
>>> binary_xor("0", "1")
Traceback (most recent call last):
    ...
TypeError: '<' not supported between instances of 'str' and 'int'

File: bitwise_addition_recursive.py
 - Function 'bitwise_addition_recursive' takes 2 arguments: number, other_number.  Docstring: >>> bitwise_addition_recursive(4, 5)
9
>>> bitwise_addition_recursive(8, 9)
17
>>> bitwise_addition_recursive(0, 4)
4
>>> bitwise_addition_recursive(4.5, 9)
Traceback (most recent call last):
    ...
TypeError: Both arguments MUST be integers!
>>> bitwise_addition_recursive('4', 9)
Traceback (most recent call last):
    ...
TypeError: Both arguments MUST be integers!
>>> bitwise_addition_recursive('4.5', 9)
Traceback (most recent call last):
    ...
TypeError: Both arguments MUST be integers!
>>> bitwise_addition_recursive(-1, 9)
Traceback (most recent call last):
    ...
ValueError: Both arguments MUST be non-negative!
>>> bitwise_addition_recursive(1, -9)
Traceback (most recent call last):
    ...
ValueError: Both arguments MUST be non-negative!

File: count_1s_brian_kernighan_method.py
 - Function 'get_1s_count' takes 1 arguments: number.  Docstring: Count the number of set bits in a 32 bit integer using Brian Kernighan's way.
Ref - https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan
>>> get_1s_count(25)
3
>>> get_1s_count(37)
3
>>> get_1s_count(21)
3
>>> get_1s_count(58)
4
>>> get_1s_count(0)
0
>>> get_1s_count(256)
1
>>> get_1s_count(-1)
Traceback (most recent call last):
    ...
ValueError: Input must be a non-negative integer
>>> get_1s_count(0.8)
Traceback (most recent call last):
    ...
ValueError: Input must be a non-negative integer
>>> get_1s_count("25")
Traceback (most recent call last):
    ...
ValueError: Input must be a non-negative integer

File: count_number_of_one_bits.py
 - Function 'get_set_bits_count_using_brian_kernighans_algorithm' takes 1 arguments: number.  Docstring: Count the number of set bits in a 32 bit integer
>>> get_set_bits_count_using_brian_kernighans_algorithm(25)
3
>>> get_set_bits_count_using_brian_kernighans_algorithm(37)
3
>>> get_set_bits_count_using_brian_kernighans_algorithm(21)
3
>>> get_set_bits_count_using_brian_kernighans_algorithm(58)
4
>>> get_set_bits_count_using_brian_kernighans_algorithm(0)
0
>>> get_set_bits_count_using_brian_kernighans_algorithm(256)
1
>>> get_set_bits_count_using_brian_kernighans_algorithm(-1)
Traceback (most recent call last):
    ...
ValueError: the value of input must not be negative
 - Function 'get_set_bits_count_using_modulo_operator' takes 1 arguments: number.  Docstring: Count the number of set bits in a 32 bit integer
>>> get_set_bits_count_using_modulo_operator(25)
3
>>> get_set_bits_count_using_modulo_operator(37)
3
>>> get_set_bits_count_using_modulo_operator(21)
3
>>> get_set_bits_count_using_modulo_operator(58)
4
>>> get_set_bits_count_using_modulo_operator(0)
0
>>> get_set_bits_count_using_modulo_operator(256)
1
>>> get_set_bits_count_using_modulo_operator(-1)
Traceback (most recent call last):
    ...
ValueError: the value of input must not be negative
 - Function 'benchmark' takes 0 arguments: .  Docstring: Benchmark code for comparing 2 functions, with different length int values.
Brian Kernighan's algorithm is consistently faster than using modulo_operator.
 - Function 'do_benchmark' takes 1 arguments: number.  No docstring available.

File: excess_3_code.py
 - Function 'excess_3_code' takes 1 arguments: number.  Docstring: Find excess-3 code of integer base 10.
Add 3 to all digits in a decimal number then convert to a binary-coded decimal.
https://en.wikipedia.org/wiki/Excess-3

>>> excess_3_code(0)
'0b0011'
>>> excess_3_code(3)
'0b0110'
>>> excess_3_code(2)
'0b0101'
>>> excess_3_code(20)
'0b01010011'
>>> excess_3_code(120)
'0b010001010011'

File: find_previous_power_of_two.py
 - Function 'find_previous_power_of_two' takes 1 arguments: number.  Docstring: Find the largest power of two that is less than or equal to a given integer.
https://stackoverflow.com/questions/1322510

>>> [find_previous_power_of_two(i) for i in range(18)]
[0, 1, 2, 2, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 16, 16]
>>> find_previous_power_of_two(-5)
Traceback (most recent call last):
    ...
ValueError: Input must be a non-negative integer
>>> find_previous_power_of_two(10.5)
Traceback (most recent call last):
    ...
ValueError: Input must be a non-negative integer

File: gray_code_sequence.py
 - Function 'gray_code' takes 1 arguments: bit_count.  Docstring: Takes in an integer n and returns a n-bit
gray code sequence
An n-bit gray code sequence is a sequence of 2^n
integers where:

a) Every integer is between [0,2^n -1] inclusive
b) The sequence begins with 0
c) An integer appears at most one times in the sequence
d)The binary representation of every pair of integers differ
   by exactly one bit
e) The binary representation of first and last bit also
   differ by exactly one bit

>>> gray_code(2)
[0, 1, 3, 2]

>>> gray_code(1)
[0, 1]

>>> gray_code(3)
[0, 1, 3, 2, 6, 7, 5, 4]

>>> gray_code(-1)
Traceback (most recent call last):
    ...
ValueError: The given input must be positive

>>> gray_code(10.6)
Traceback (most recent call last):
    ...
TypeError: unsupported operand type(s) for <<: 'int' and 'float'
 - Function 'gray_code_sequence_string' takes 1 arguments: bit_count.  Docstring: Will output the n-bit grey sequence as a
string of bits

>>> gray_code_sequence_string(2)
['00', '01', '11', '10']

>>> gray_code_sequence_string(1)
['0', '1']

File: highest_set_bit.py
 - Function 'get_highest_set_bit_position' takes 1 arguments: number.  Docstring: Returns position of the highest set bit of a number.
Ref - https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogObvious
>>> get_highest_set_bit_position(25)
5
>>> get_highest_set_bit_position(37)
6
>>> get_highest_set_bit_position(1)
1
>>> get_highest_set_bit_position(4)
3
>>> get_highest_set_bit_position(0)
0
>>> get_highest_set_bit_position(0.8)
Traceback (most recent call last):
    ...
TypeError: Input value must be an 'int' type

File: index_of_rightmost_set_bit.py
 - Function 'get_index_of_rightmost_set_bit' takes 1 arguments: number.  Docstring: Take in a positive integer 'number'.
Returns the zero-based index of first set bit in that 'number' from right.
Returns -1, If no set bit found.

>>> get_index_of_rightmost_set_bit(0)
-1
>>> get_index_of_rightmost_set_bit(5)
0
>>> get_index_of_rightmost_set_bit(36)
2
>>> get_index_of_rightmost_set_bit(8)
3
>>> get_index_of_rightmost_set_bit(-18)
Traceback (most recent call last):
    ...
ValueError: Input must be a non-negative integer
>>> get_index_of_rightmost_set_bit('test')
Traceback (most recent call last):
    ...
ValueError: Input must be a non-negative integer
>>> get_index_of_rightmost_set_bit(1.25)
Traceback (most recent call last):
    ...
ValueError: Input must be a non-negative integer

File: is_even.py
 - Function 'is_even' takes 1 arguments: number.  Docstring: return true if the input integer is even
Explanation: Lets take a look at the following decimal to binary conversions
2 => 10
14 => 1110
100 => 1100100
3 => 11
13 => 1101
101 => 1100101
from the above examples we can observe that
for all the odd integers there is always 1 set bit at the end
also, 1 in binary can be represented as 001, 00001, or 0000001
so for any odd integer n => n&1 is always equals 1 else the integer is even

>>> is_even(1)
False
>>> is_even(4)
True
>>> is_even(9)
False
>>> is_even(15)
False
>>> is_even(40)
True
>>> is_even(100)
True
>>> is_even(101)
False

File: is_power_of_two.py
 - Function 'is_power_of_two' takes 1 arguments: number.  Docstring: Return True if this number is power of 2 or False otherwise.

>>> is_power_of_two(0)
True
>>> is_power_of_two(1)
True
>>> is_power_of_two(2)
True
>>> is_power_of_two(4)
True
>>> is_power_of_two(6)
False
>>> is_power_of_two(8)
True
>>> is_power_of_two(17)
False
>>> is_power_of_two(-1)
Traceback (most recent call last):
    ...
ValueError: number must not be negative
>>> is_power_of_two(1.2)
Traceback (most recent call last):
    ...
TypeError: unsupported operand type(s) for &: 'float' and 'float'

# Test all powers of 2 from 0 to 10,000
>>> all(is_power_of_two(int(2 ** i)) for i in range(10000))
True

File: largest_pow_of_two_le_num.py
 - Function 'largest_pow_of_two_le_num' takes 1 arguments: number.  Docstring: Return the largest power of two less than or equal to a number.

>>> largest_pow_of_two_le_num(0)
0
>>> largest_pow_of_two_le_num(1)
1
>>> largest_pow_of_two_le_num(-1)
0
>>> largest_pow_of_two_le_num(3)
2
>>> largest_pow_of_two_le_num(15)
8
>>> largest_pow_of_two_le_num(99)
64
>>> largest_pow_of_two_le_num(178)
128
>>> largest_pow_of_two_le_num(999999)
524288
>>> largest_pow_of_two_le_num(99.9)
Traceback (most recent call last):
    ...
TypeError: Input value must be a 'int' type

File: missing_number.py
 - Function 'find_missing_number' takes 1 arguments: nums.  Docstring: Finds the missing number in a list of consecutive integers.

Args:
    nums: A list of integers.

Returns:
    The missing number.

Example:
    >>> find_missing_number([0, 1, 3, 4])
    2
    >>> find_missing_number([4, 3, 1, 0])
    2
    >>> find_missing_number([-4, -3, -1, 0])
    -2
    >>> find_missing_number([-2, 2, 1, 3, 0])
    -1
    >>> find_missing_number([1, 3, 4, 5, 6])
    2
    >>> find_missing_number([6, 5, 4, 2, 1])
    3
    >>> find_missing_number([6, 1, 5, 3, 4])
    2

File: numbers_different_signs.py
 - Function 'different_signs' takes 2 arguments: num1, num2.  Docstring: Return True if numbers have opposite signs False otherwise.

>>> different_signs(1, -1)
True
>>> different_signs(1, 1)
False
>>> different_signs(1000000000000000000000000000, -1000000000000000000000000000)
True
>>> different_signs(-1000000000000000000000000000, 1000000000000000000000000000)
True
>>> different_signs(50, 278)
False
>>> different_signs(0, 2)
False
>>> different_signs(2, 0)
False

File: power_of_4.py
 - Function 'power_of_4' takes 1 arguments: number.  Docstring: Return True if this number is power of 4 or False otherwise.

>>> power_of_4(0)
Traceback (most recent call last):
    ...
ValueError: number must be positive
>>> power_of_4(1)
True
>>> power_of_4(2)
False
>>> power_of_4(4)
True
>>> power_of_4(6)
False
>>> power_of_4(8)
False
>>> power_of_4(17)
False
>>> power_of_4(64)
True
>>> power_of_4(-1)
Traceback (most recent call last):
    ...
ValueError: number must be positive
>>> power_of_4(1.2)
Traceback (most recent call last):
    ...
TypeError: number must be an integer

File: reverse_bits.py
 - Function 'get_reverse_bit_string' takes 1 arguments: number.  Docstring: return the bit string of an integer

>>> get_reverse_bit_string(9)
'10010000000000000000000000000000'
>>> get_reverse_bit_string(43)
'11010100000000000000000000000000'
>>> get_reverse_bit_string(2873)
'10011100110100000000000000000000'
>>> get_reverse_bit_string("this is not a number")
Traceback (most recent call last):
    ...
TypeError: operation can not be conducted on a object of type str
 - Function 'reverse_bit' takes 1 arguments: number.  Docstring: Take in an 32 bit integer, reverse its bits,
return a string of reverse bits

result of a reverse_bit and operation on the integer provided.

>>> reverse_bit(25)
'00000000000000000000000000011001'
>>> reverse_bit(37)
'00000000000000000000000000100101'
>>> reverse_bit(21)
'00000000000000000000000000010101'
>>> reverse_bit(58)
'00000000000000000000000000111010'
>>> reverse_bit(0)
'00000000000000000000000000000000'
>>> reverse_bit(256)
'00000000000000000000000100000000'
>>> reverse_bit(-1)
Traceback (most recent call last):
    ...
ValueError: the value of input must be positive

>>> reverse_bit(1.1)
Traceback (most recent call last):
    ...
TypeError: Input value must be a 'int' type

>>> reverse_bit("0")
Traceback (most recent call last):
    ...
TypeError: '<' not supported between instances of 'str' and 'int'

File: single_bit_manipulation_operations.py
 - Function 'set_bit' takes 2 arguments: number, position.  Docstring: Set the bit at position to 1.

Details: perform bitwise or for given number and X.
Where X is a number with all the bits - zeroes and bit on given
position - one.

>>> set_bit(0b1101, 1) # 0b1111
15
>>> set_bit(0b0, 5) # 0b100000
32
>>> set_bit(0b1111, 1) # 0b1111
15
 - Function 'clear_bit' takes 2 arguments: number, position.  Docstring: Set the bit at position to 0.

Details: perform bitwise and for given number and X.
Where X is a number with all the bits - ones and bit on given
position - zero.

>>> clear_bit(0b10010, 1) # 0b10000
16
>>> clear_bit(0b0, 5) # 0b0
0
 - Function 'flip_bit' takes 2 arguments: number, position.  Docstring: Flip the bit at position.

Details: perform bitwise xor for given number and X.
Where X is a number with all the bits - zeroes and bit on given
position - one.

>>> flip_bit(0b101, 1) # 0b111
7
>>> flip_bit(0b101, 0) # 0b100
4
 - Function 'is_bit_set' takes 2 arguments: number, position.  Docstring: Is the bit at position set?

Details: Shift the bit at position to be the first (smallest) bit.
Then check if the first bit is set by anding the shifted number with 1.

>>> is_bit_set(0b1010, 0)
False
>>> is_bit_set(0b1010, 1)
True
>>> is_bit_set(0b1010, 2)
False
>>> is_bit_set(0b1010, 3)
True
>>> is_bit_set(0b0, 17)
False
 - Function 'get_bit' takes 2 arguments: number, position.  Docstring: Get the bit at the given position

Details: perform bitwise and for the given number and X,
Where X is a number with all the bits - zeroes and bit on given position - one.
If the result is not equal to 0, then the bit on the given position is 1, else 0.

>>> get_bit(0b1010, 0)
0
>>> get_bit(0b1010, 1)
1
>>> get_bit(0b1010, 2)
0
>>> get_bit(0b1010, 3)
1

File: swap_all_odd_and_even_bits.py
 - Function 'show_bits' takes 2 arguments: before, after.  Docstring: >>> print(show_bits(0, 0xFFFF))
    0: 00000000
65535: 1111111111111111
 - Function 'swap_odd_even_bits' takes 1 arguments: num.  Docstring: 1. We use bitwise AND operations to separate the even bits (0, 2, 4, 6, etc.) and
   odd bits (1, 3, 5, 7, etc.) in the input number.
2. We then right-shift the even bits by 1 position and left-shift the odd bits by
   1 position to swap them.
3. Finally, we combine the swapped even and odd bits using a bitwise OR operation
   to obtain the final result.
>>> print(show_bits(0, swap_odd_even_bits(0)))
    0: 00000000
    0: 00000000
>>> print(show_bits(1, swap_odd_even_bits(1)))
    1: 00000001
    2: 00000010
>>> print(show_bits(2, swap_odd_even_bits(2)))
    2: 00000010
    1: 00000001
>>> print(show_bits(3, swap_odd_even_bits(3)))
    3: 00000011
    3: 00000011
>>> print(show_bits(4, swap_odd_even_bits(4)))
    4: 00000100
    8: 00001000
>>> print(show_bits(5, swap_odd_even_bits(5)))
    5: 00000101
   10: 00001010
>>> print(show_bits(6, swap_odd_even_bits(6)))
    6: 00000110
    9: 00001001
>>> print(show_bits(23, swap_odd_even_bits(23)))
   23: 00010111
   43: 00101011

File: diophantine_equation.py
 - Function 'diophantine' takes 3 arguments: a, b, c.  Docstring: Diophantine Equation : Given integers a,b,c ( at least one of a and b != 0), the
diophantine equation a*x + b*y = c has a solution (where x and y are integers)
iff greatest_common_divisor(a,b) divides c.

GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )

>>> diophantine(10,6,14)
(-7.0, 14.0)

>>> diophantine(391,299,-69)
(9.0, -12.0)

But above equation has one more solution i.e., x = -4, y = 5.
That's why we need diophantine all solution function.
 - Function 'diophantine_all_soln' takes 4 arguments: a, b, c, n.  Docstring: Lemma : if n|ab and gcd(a,n) = 1, then n|b.

Finding All solutions of Diophantine Equations:

Theorem : Let gcd(a,b) = d, a = d*p, b = d*q. If (x0,y0) is a solution of
Diophantine Equation a*x + b*y = c.  a*x0 + b*y0 = c, then all the
solutions have the form a(x0 + t*q) + b(y0 - t*p) = c,
where t is an arbitrary integer.

n is the number of solution you want, n = 2 by default

>>> diophantine_all_soln(10, 6, 14)
-7.0 14.0
-4.0 9.0

>>> diophantine_all_soln(10, 6, 14, 4)
-7.0 14.0
-4.0 9.0
-1.0 4.0
2.0 -1.0

>>> diophantine_all_soln(391, 299, -69, n = 4)
9.0 -12.0
22.0 -29.0
35.0 -46.0
48.0 -63.0
 - Function 'extended_gcd' takes 2 arguments: a, b.  Docstring: Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers
x and y, then d = gcd(a,b)

>>> extended_gcd(10, 6)
(2, -1, 2)

>>> extended_gcd(7, 5)
(1, -2, 3)

File: and_gate.py
 - Function 'and_gate' takes 2 arguments: input_1, input_2.  Docstring: Calculate AND of the input values

>>> and_gate(0, 0)
0
>>> and_gate(0, 1)
0
>>> and_gate(1, 0)
0
>>> and_gate(1, 1)
1

File: imply_gate.py
 - Function 'imply_gate' takes 2 arguments: input_1, input_2.  Docstring: Calculate IMPLY of the input values

>>> imply_gate(0, 0)
1
>>> imply_gate(0, 1)
1
>>> imply_gate(1, 0)
0
>>> imply_gate(1, 1)
1

File: karnaugh_map_simplification.py
 - Function 'simplify_kmap' takes 1 arguments: kmap.  Docstring: Simplify the Karnaugh map.
>>> simplify_kmap(kmap=[[0, 1], [1, 1]])
"A'B + AB' + AB"
>>> simplify_kmap(kmap=[[0, 0], [0, 0]])
''
>>> simplify_kmap(kmap=[[0, 1], [1, -1]])
"A'B + AB' + AB"
>>> simplify_kmap(kmap=[[0, 1], [1, 2]])
"A'B + AB' + AB"
>>> simplify_kmap(kmap=[[0, 1], [1, 1.1]])
"A'B + AB' + AB"
>>> simplify_kmap(kmap=[[0, 1], [1, 'a']])
"A'B + AB' + AB"
 - Function 'main' takes 0 arguments: .  Docstring: Main function to create and simplify a K-Map.

>>> main()
[0, 1]
[1, 1]
Simplified Expression:
A'B + AB' + AB

File: multiplexer.py
 - Function 'mux' takes 3 arguments: input0, input1, select.  Docstring: Implement a 2-to-1 Multiplexer.

:param input0: The first input value (0 or 1).
:param input1: The second input value (0 or 1).
:param select: The select signal (0 or 1) to choose between input0 and input1.
:return: The output based on the select signal.  input1 if select else input0.

https://www.electrically4u.com/solved-problems-on-multiplexer
https://en.wikipedia.org/wiki/Multiplexer

>>> mux(0, 1, 0)
0
>>> mux(0, 1, 1)
1
>>> mux(1, 0, 0)
1
>>> mux(1, 0, 1)
0
>>> mux(2, 1, 0)
Traceback (most recent call last):
    ...
ValueError: Inputs and select signal must be 0 or 1
>>> mux(0, -1, 0)
Traceback (most recent call last):
    ...
ValueError: Inputs and select signal must be 0 or 1
>>> mux(0, 1, 1.1)
Traceback (most recent call last):
    ...
ValueError: Inputs and select signal must be 0 or 1

File: nand_gate.py
 - Function 'nand_gate' takes 2 arguments: input_1, input_2.  Docstring: Calculate NAND of the input values
>>> nand_gate(0, 0)
1
>>> nand_gate(0, 1)
1
>>> nand_gate(1, 0)
1
>>> nand_gate(1, 1)
0

File: nimply_gate.py
 - Function 'nimply_gate' takes 2 arguments: input_1, input_2.  Docstring: Calculate NIMPLY of the input values

>>> nimply_gate(0, 0)
0
>>> nimply_gate(0, 1)
0
>>> nimply_gate(1, 0)
1
>>> nimply_gate(1, 1)
0

File: nor_gate.py
 - Function 'nor_gate' takes 2 arguments: input_1, input_2.  Docstring: >>> nor_gate(0, 0)
1
>>> nor_gate(0, 1)
0
>>> nor_gate(1, 0)
0
>>> nor_gate(1, 1)
0
>>> nor_gate(0.0, 0.0)
1
>>> nor_gate(0, -7)
0
 - Function 'truth_table' takes 1 arguments: func.  Docstring: >>> print(truth_table(nor_gate))
Truth Table of NOR Gate:
| Input 1  | Input 2  |  Output  |
|    0     |    0     |    1     |
|    0     |    1     |    0     |
|    1     |    0     |    0     |
|    1     |    1     |    0     |
 - Function 'make_table_row' takes 1 arguments: items.  Docstring: >>> make_table_row(("One", "Two", "Three"))
'|   One    |   Two    |  Three   |'

File: not_gate.py
 - Function 'not_gate' takes 1 arguments: input_1.  Docstring: Calculate NOT of the input values
>>> not_gate(0)
1
>>> not_gate(1)
0

File: or_gate.py
 - Function 'or_gate' takes 2 arguments: input_1, input_2.  Docstring: Calculate OR of the input values
>>> or_gate(0, 0)
0
>>> or_gate(0, 1)
1
>>> or_gate(1, 0)
1
>>> or_gate(1, 1)
1

File: quine_mc_cluskey.py
 - Function 'compare_string' takes 2 arguments: string1, string2.  Docstring: >>> compare_string('0010','0110')
'0_10'

>>> compare_string('0110','1101')
False
 - Function 'check' takes 1 arguments: binary.  Docstring: >>> check(['0.00.01.5'])
['0.00.01.5']
 - Function 'decimal_to_binary' takes 2 arguments: no_of_variable, minterms.  Docstring: >>> decimal_to_binary(3,[1.5])
['0.00.01.5']
 - Function 'is_for_table' takes 3 arguments: string1, string2, count.  Docstring: >>> is_for_table('__1','011',2)
True

>>> is_for_table('01_','001',1)
False
 - Function 'selection' takes 2 arguments: chart, prime_implicants.  Docstring: >>> selection([[1]],['0.00.01.5'])
['0.00.01.5']

>>> selection([[1]],['0.00.01.5'])
['0.00.01.5']
 - Function 'prime_implicant_chart' takes 2 arguments: prime_implicants, binary.  Docstring: >>> prime_implicant_chart(['0.00.01.5'],['0.00.01.5'])
[[1]]
 - Function 'main' takes 0 arguments: .  No docstring available.

File: xnor_gate.py
 - Function 'xnor_gate' takes 2 arguments: input_1, input_2.  Docstring: Calculate XOR of the input values
>>> xnor_gate(0, 0)
1
>>> xnor_gate(0, 1)
0
>>> xnor_gate(1, 0)
0
>>> xnor_gate(1, 1)
1

File: xor_gate.py
 - Function 'xor_gate' takes 2 arguments: input_1, input_2.  Docstring: calculate xor of the input values

>>> xor_gate(0, 0)
0
>>> xor_gate(0, 1)
1
>>> xor_gate(1, 0)
1
>>> xor_gate(1, 1)
0

File: conways_game_of_life.py
 - Function 'new_generation' takes 1 arguments: cells.  Docstring: Generates the next generation for a given state of Conway's Game of Life.
>>> new_generation(BLINKER)
[[0, 0, 0], [1, 1, 1], [0, 0, 0]]
 - Function 'generate_images' takes 2 arguments: cells, frames.  Docstring: Generates a list of images of subsequent Game of Life states.

File: game_of_life.py
 - Function 'create_canvas' takes 1 arguments: size.  No docstring available.
 - Function 'seed' takes 1 arguments: canvas.  No docstring available.
 - Function 'run' takes 1 arguments: canvas.  Docstring: This function runs the rules of game through all points, and changes their
status accordingly.(in the same canvas)
@Args:
--
canvas : canvas of population to run the rules on.

@returns:
--
canvas of population after one step
 - Function '__judge_point' takes 2 arguments: pt, neighbours.  No docstring available.

File: langtons_ant.py
 - Function '__init__' takes 3 arguments: self, width, height.  No docstring available.
 - Function 'move_ant' takes 4 arguments: self, axes, display, _frame.  Docstring: Performs three tasks:
    1. The ant turns either clockwise or anti-clockwise according to the colour
    of the square that it is currently on. If the square is white, the ant
    turns clockwise, and if the square is black the ant turns anti-clockwise
    2. The ant moves one square in the direction that it is currently facing
    3. The square the ant was previously on is inverted (White -> Black and
    Black -> White)

If display is True, the board will also be displayed on the axes

>>> la = LangtonsAnt(2, 2)
>>> la.move_ant(None, True, 0)
>>> la.board
[[True, True], [True, False]]
>>> la.move_ant(None, True, 0)
>>> la.board
[[True, False], [True, False]]
 - Function 'display' takes 2 arguments: self, frames.  Docstring: Displays the board without delay in a matplotlib plot
to visually understand and track the ant.

>>> _ = LangtonsAnt(WIDTH, HEIGHT)

File: nagel_schrekenberg.py
 - Function 'construct_highway' takes 6 arguments: number_of_cells, frequency, initial_speed, random_frequency, random_speed, max_speed.  Docstring: Build the highway following the parameters given
>>> construct_highway(10, 2, 6)
[[6, -1, 6, -1, 6, -1, 6, -1, 6, -1]]
>>> construct_highway(10, 10, 2)
[[2, -1, -1, -1, -1, -1, -1, -1, -1, -1]]
 - Function 'get_distance' takes 2 arguments: highway_now, car_index.  Docstring: Get the distance between a car (at index car_index) and the next car
>>> get_distance([6, -1, 6, -1, 6], 2)
1
>>> get_distance([2, -1, -1, -1, 3, 1, 0, 1, 3, 2], 0)
3
>>> get_distance([-1, -1, -1, -1, 2, -1, -1, -1, 3], -1)
4
 - Function 'update' takes 3 arguments: highway_now, probability, max_speed.  Docstring: Update the speed of the cars
>>> update([-1, -1, -1, -1, -1, 2, -1, -1, -1, -1, 3], 0.0, 5)
[-1, -1, -1, -1, -1, 3, -1, -1, -1, -1, 4]
>>> update([-1, -1, 2, -1, -1, -1, -1, 3], 0.0, 5)
[-1, -1, 3, -1, -1, -1, -1, 1]
 - Function 'simulate' takes 4 arguments: highway, number_of_update, probability, max_speed.  Docstring: The main function, it will simulate the evolution of the highway
>>> simulate([[-1, 2, -1, -1, -1, 3]], 2, 0.0, 3)
[[-1, 2, -1, -1, -1, 3], [-1, -1, -1, 2, -1, 0], [1, -1, -1, 0, -1, -1]]
>>> simulate([[-1, 2, -1, 3]], 4, 0.0, 3)
[[-1, 2, -1, 3], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0], [-1, 0, -1, 0]]

File: one_dimensional.py
 - Function 'format_ruleset' takes 1 arguments: ruleset.  Docstring: >>> format_ruleset(11100)
[0, 0, 0, 1, 1, 1, 0, 0]
>>> format_ruleset(0)
[0, 0, 0, 0, 0, 0, 0, 0]
>>> format_ruleset(11111111)
[1, 1, 1, 1, 1, 1, 1, 1]
 - Function 'new_generation' takes 3 arguments: cells, rule, time.  No docstring available.
 - Function 'generate_image' takes 1 arguments: cells.  Docstring: Convert the cells into a greyscale PIL.Image.Image and return it to the caller.
>>> from random import random
>>> cells = [[random() for w in range(31)] for h in range(16)]
>>> img = generate_image(cells)
>>> isinstance(img, Image.Image)
True
>>> img.width, img.height
(31, 16)

File: wa_tor.py
 - Function '__init__' takes 3 arguments: self, prey, coords.  No docstring available.
 - Function 'reset_reproduction_time' takes 1 arguments: self.  Docstring: >>> e = Entity(True, coords=(0, 0))
>>> e.reset_reproduction_time()
>>> e.remaining_reproduction_time == PREY_REPRODUCTION_TIME
True
>>> e = Entity(False, coords=(0, 0))
>>> e.reset_reproduction_time()
>>> e.remaining_reproduction_time == PREDATOR_REPRODUCTION_TIME
True
 - Function '__repr__' takes 1 arguments: self.  Docstring: >>> Entity(prey=True, coords=(1, 1))
Entity(prey=True, coords=(1, 1), remaining_reproduction_time=5)
>>> Entity(prey=False, coords=(2, 1))  # doctest: +NORMALIZE_WHITESPACE
Entity(prey=False, coords=(2, 1),
remaining_reproduction_time=20, energy_value=15)
 - Function '__init__' takes 3 arguments: self, width, height.  No docstring available.
 - Function 'set_planet' takes 2 arguments: self, planet.  Docstring: Ease of access for testing

>>> wt = WaTor(WIDTH, HEIGHT)
>>> planet = [
... [None, None, None],
... [None, Entity(True, coords=(1, 1)), None]
... ]
>>> wt.set_planet(planet)
>>> wt.planet == planet
True
>>> wt.width
3
>>> wt.height
2
 - Function 'add_entity' takes 2 arguments: self, prey.  Docstring: Adds an entity, making sure the entity does
not override another entity

>>> wt = WaTor(WIDTH, HEIGHT)
>>> wt.set_planet([[None, None], [None, None]])
>>> wt.add_entity(True)
>>> len(wt.get_entities())
1
>>> wt.add_entity(False)
>>> len(wt.get_entities())
2
 - Function 'get_entities' takes 1 arguments: self.  Docstring: Returns a list of all the entities within the planet.

>>> wt = WaTor(WIDTH, HEIGHT)
>>> len(wt.get_entities()) == PREDATOR_INITIAL_COUNT + PREY_INITIAL_COUNT
True
 - Function 'balance_predators_and_prey' takes 1 arguments: self.  Docstring: Balances predators and preys so that prey
can not dominate the predators, blocking up
space for them to reproduce.

>>> wt = WaTor(WIDTH, HEIGHT)
>>> for i in range(2000):
...     row, col = i // HEIGHT, i % WIDTH
...     wt.planet[row][col] = Entity(True, coords=(row, col))
>>> entities = len(wt.get_entities())
>>> wt.balance_predators_and_prey()
>>> len(wt.get_entities()) == entities
False
 - Function 'get_surrounding_prey' takes 2 arguments: self, entity.  Docstring: Returns all the prey entities around (N, S, E, W) a predator entity.

Subtly different to the try_to_move_to_unoccupied square.

>>> wt = WaTor(WIDTH, HEIGHT)
>>> wt.set_planet([
... [None, Entity(True, (0, 1)), None],
... [None, Entity(False, (1, 1)), None],
... [None, Entity(True, (2, 1)), None]])
>>> wt.get_surrounding_prey(
... Entity(False, (1, 1)))  # doctest: +NORMALIZE_WHITESPACE
[Entity(prey=True, coords=(0, 1), remaining_reproduction_time=5),
Entity(prey=True, coords=(2, 1), remaining_reproduction_time=5)]
>>> wt.set_planet([[Entity(False, (0, 0))]])
>>> wt.get_surrounding_prey(Entity(False, (0, 0)))
[]
>>> wt.set_planet([
... [Entity(True, (0, 0)), Entity(False, (1, 0)), Entity(False, (2, 0))],
... [None, Entity(False, (1, 1)), Entity(True, (2, 1))],
... [None, None, None]])
>>> wt.get_surrounding_prey(Entity(False, (1, 0)))
[Entity(prey=True, coords=(0, 0), remaining_reproduction_time=5)]
 - Function 'move_and_reproduce' takes 3 arguments: self, entity, direction_orders.  Docstring: Attempts to move to an unoccupied neighbouring square
in either of the four directions (North, South, East, West).
If the move was successful and the remaining_reproduction time is
equal to 0, then a new prey or predator can also be created
in the previous square.

:param direction_orders: Ordered list (like priority queue) depicting
                    order to attempt to move. Removes any systematic
                    approach of checking neighbouring squares.

>>> planet = [
... [None, None, None],
... [None, Entity(True, coords=(1, 1)), None],
... [None, None, None]
... ]
>>> wt = WaTor(WIDTH, HEIGHT)
>>> wt.set_planet(planet)
>>> wt.move_and_reproduce(Entity(True, coords=(1, 1)), direction_orders=["N"])
>>> wt.planet  # doctest: +NORMALIZE_WHITESPACE
[[None, Entity(prey=True, coords=(0, 1), remaining_reproduction_time=4), None],
[None, None, None],
[None, None, None]]
>>> wt.planet[0][0] = Entity(True, coords=(0, 0))
>>> wt.move_and_reproduce(Entity(True, coords=(0, 1)),
... direction_orders=["N", "W", "E", "S"])
>>> wt.planet  # doctest: +NORMALIZE_WHITESPACE
[[Entity(prey=True, coords=(0, 0), remaining_reproduction_time=5), None,
Entity(prey=True, coords=(0, 2), remaining_reproduction_time=4)],
[None, None, None],
[None, None, None]]
>>> wt.planet[0][1] = wt.planet[0][2]
>>> wt.planet[0][2] = None
>>> wt.move_and_reproduce(Entity(True, coords=(0, 1)),
... direction_orders=["N", "W", "S", "E"])
>>> wt.planet  # doctest: +NORMALIZE_WHITESPACE
[[Entity(prey=True, coords=(0, 0), remaining_reproduction_time=5), None, None],
[None, Entity(prey=True, coords=(1, 1), remaining_reproduction_time=4), None],
[None, None, None]]

>>> wt = WaTor(WIDTH, HEIGHT)
>>> reproducable_entity = Entity(False, coords=(0, 1))
>>> reproducable_entity.remaining_reproduction_time = 0
>>> wt.planet = [[None, reproducable_entity]]
>>> wt.move_and_reproduce(reproducable_entity,
... direction_orders=["N", "W", "S", "E"])
>>> wt.planet  # doctest: +NORMALIZE_WHITESPACE
[[Entity(prey=False, coords=(0, 0),
remaining_reproduction_time=20, energy_value=15),
Entity(prey=False, coords=(0, 1), remaining_reproduction_time=20,
energy_value=15)]]
 - Function 'perform_prey_actions' takes 3 arguments: self, entity, direction_orders.  Docstring: Performs the actions for a prey entity

For prey the rules are:
  1. At each chronon, a prey moves randomly to one of the adjacent unoccupied
    squares. If there are no free squares, no movement takes place.
  2. Once a prey has survived a certain number of chronons it may reproduce.
    This is done as it moves to a neighbouring square,
    leaving behind a new prey in its old position.
    Its reproduction time is also reset to zero.

>>> wt = WaTor(WIDTH, HEIGHT)
>>> reproducable_entity = Entity(True, coords=(0, 1))
>>> reproducable_entity.remaining_reproduction_time = 0
>>> wt.planet = [[None, reproducable_entity]]
>>> wt.perform_prey_actions(reproducable_entity,
... direction_orders=["N", "W", "S", "E"])
>>> wt.planet  # doctest: +NORMALIZE_WHITESPACE
[[Entity(prey=True, coords=(0, 0), remaining_reproduction_time=5),
Entity(prey=True, coords=(0, 1), remaining_reproduction_time=5)]]
 - Function 'perform_predator_actions' takes 4 arguments: self, entity, occupied_by_prey_coords, direction_orders.  Docstring: Performs the actions for a predator entity

:param occupied_by_prey_coords: Move to this location if there is prey there

For predators the rules are:
  1. At each chronon, a predator moves randomly to an adjacent square occupied
    by a prey. If there is none, the predator moves to a random adjacent
    unoccupied square. If there are no free squares, no movement takes place.
  2. At each chronon, each predator is deprived of a unit of energy.
  3. Upon reaching zero energy, a predator dies.
  4. If a predator moves to a square occupied by a prey,
    it eats the prey and earns a certain amount of energy.
  5. Once a predator has survived a certain number of chronons
  it may reproduce in exactly the same way as the prey.

>>> wt = WaTor(WIDTH, HEIGHT)
>>> wt.set_planet([[Entity(True, coords=(0, 0)), Entity(False, coords=(0, 1))]])
>>> wt.perform_predator_actions(Entity(False, coords=(0, 1)), (0, 0), [])
>>> wt.planet  # doctest: +NORMALIZE_WHITESPACE
[[Entity(prey=False, coords=(0, 0),
remaining_reproduction_time=20, energy_value=19), None]]
 - Function 'run' takes 1 arguments: self.  Docstring: Emulate time passing by looping iteration_count times

>>> wt = WaTor(WIDTH, HEIGHT)
>>> wt.run(iteration_count=PREDATOR_INITIAL_ENERGY_VALUE - 1)
>>> len(list(filter(lambda entity: entity.prey is False,
... wt.get_entities()))) >= PREDATOR_INITIAL_COUNT
True
 - Function 'visualise' takes 2 arguments: wt, iter_number.  Docstring: Visually displays the Wa-Tor planet using
an ascii code in terminal to clear and re-print
the Wa-Tor planet at intervals.

Uses ascii colour codes to colourfully display
the predators and prey.

(0x60f197) Prey = #
(0xfffff) Predator = x

>>> wt = WaTor(30, 30)
>>> wt.set_planet([
... [Entity(True, coords=(0, 0)), Entity(False, coords=(0, 1)), None],
... [Entity(False, coords=(1, 0)), None, Entity(False, coords=(1, 2))],
... [None, Entity(True, coords=(2, 1)), None]
... ])
>>> visualise(wt, 0, colour=False)  # doctest: +NORMALIZE_WHITESPACE
#  x  .
x  .  x
.  #  .
<BLANKLINE>
Iteration: 0 | Prey count: 2 | Predator count: 3 |

File: a1z26.py
 - Function 'encode' takes 1 arguments: plain.  Docstring: >>> encode("myname")
[13, 25, 14, 1, 13, 5]
 - Function 'decode' takes 1 arguments: encoded.  Docstring: >>> decode([13, 25, 14, 1, 13, 5])
'myname'
 - Function 'main' takes 0 arguments: .  No docstring available.

File: affine_cipher.py
 - Function 'check_keys' takes 3 arguments: key_a, key_b, mode.  No docstring available.
 - Function 'encrypt_message' takes 2 arguments: key, message.  Docstring: >>> encrypt_message(4545, 'The affine cipher is a type of monoalphabetic '
...                       'substitution cipher.')
'VL}p MM{I}p~{HL}Gp{vp pFsH}pxMpyxIx JHL O}F{~pvuOvF{FuF{xIp~{HL}Gi'
 - Function 'decrypt_message' takes 2 arguments: key, message.  Docstring: >>> decrypt_message(4545, 'VL}p MM{I}p~{HL}Gp{vp pFsH}pxMpyxIx JHL O}F{~pvuOvF{FuF'
...                       '{xIp~{HL}Gi')
'The affine cipher is a type of monoalphabetic substitution cipher.'
 - Function 'get_random_key' takes 0 arguments: .  No docstring available.
 - Function 'main' takes 0 arguments: .  Docstring: >>> key = get_random_key()
>>> msg = "This is a test!"
>>> decrypt_message(key, encrypt_message(key, msg)) == msg
True

File: atbash.py
 - Function 'atbash_slow' takes 1 arguments: sequence.  Docstring: >>> atbash_slow("ABCDEFG")
'ZYXWVUT'

>>> atbash_slow("aW;;123BX")
'zD;;123YC'
 - Function 'atbash' takes 1 arguments: sequence.  Docstring: >>> atbash("ABCDEFG")
'ZYXWVUT'

>>> atbash("aW;;123BX")
'zD;;123YC'
 - Function 'benchmark' takes 0 arguments: .  Docstring: Let's benchmark our functions side-by-side...

File: autokey.py
 - Function 'encrypt' takes 2 arguments: plaintext, key.  Docstring: Encrypt a given plaintext (string) and key (string), returning the
encrypted ciphertext.
>>> encrypt("hello world", "coffee")
'jsqqs avvwo'
>>> encrypt("coffee is good as python", "TheAlgorithms")
'vvjfpk wj ohvp su ddylsv'
>>> encrypt("coffee is good as python", 2)
Traceback (most recent call last):
    ...
TypeError: key must be a string
>>> encrypt("", "TheAlgorithms")
Traceback (most recent call last):
    ...
ValueError: plaintext is empty
 - Function 'decrypt' takes 2 arguments: ciphertext, key.  Docstring: Decrypt a given ciphertext (string) and key (string), returning the decrypted
ciphertext.
>>> decrypt("jsqqs avvwo", "coffee")
'hello world'
>>> decrypt("vvjfpk wj ohvp su ddylsv", "TheAlgorithms")
'coffee is good as python'
>>> decrypt("vvjfpk wj ohvp su ddylsv", "")
Traceback (most recent call last):
    ...
ValueError: key is empty
>>> decrypt(527.26, "TheAlgorithms")
Traceback (most recent call last):
    ...
TypeError: ciphertext must be a string

File: baconian_cipher.py
 - Function 'encode' takes 1 arguments: word.  Docstring: Encodes to Baconian cipher

>>> encode("hello")
'AABBBAABAAABABAABABAABBAB'
>>> encode("hello world")
'AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB'
>>> encode("hello world!")
Traceback (most recent call last):
    ...
Exception: encode() accepts only letters of the alphabet and spaces
 - Function 'decode' takes 1 arguments: coded.  Docstring: Decodes from Baconian cipher

>>> decode("AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB")
'hello world'
>>> decode("AABBBAABAAABABAABABAABBAB")
'hello'
>>> decode("AABBBAABAAABABAABABAABBAB BABAAABBABBAAAAABABAAAABB!")
Traceback (most recent call last):
    ...
Exception: decode() accepts only 'A', 'B' and spaces

File: base16.py
 - Function 'base16_encode' takes 1 arguments: data.  Docstring: Encodes the given bytes into base16.

>>> base16_encode(b'Hello World!')
'48656C6C6F20576F726C6421'
>>> base16_encode(b'HELLO WORLD!')
'48454C4C4F20574F524C4421'
>>> base16_encode(b'')
''
 - Function 'base16_decode' takes 1 arguments: data.  Docstring: Decodes the given base16 encoded data into bytes.

>>> base16_decode('48656C6C6F20576F726C6421')
b'Hello World!'
>>> base16_decode('48454C4C4F20574F524C4421')
b'HELLO WORLD!'
>>> base16_decode('')
b''
>>> base16_decode('486')
Traceback (most recent call last):
  ...
ValueError: Base16 encoded data is invalid:
Data does not have an even number of hex digits.
>>> base16_decode('48656c6c6f20576f726c6421')
Traceback (most recent call last):
  ...
ValueError: Base16 encoded data is invalid:
Data is not uppercase hex or it contains invalid characters.
>>> base16_decode('This is not base64 encoded data.')
Traceback (most recent call last):
  ...
ValueError: Base16 encoded data is invalid:
Data is not uppercase hex or it contains invalid characters.

File: base32.py
 - Function 'base32_encode' takes 1 arguments: data.  Docstring: >>> base32_encode(b"Hello World!")
b'JBSWY3DPEBLW64TMMQQQ===='
>>> base32_encode(b"123456")
b'GEZDGNBVGY======'
>>> base32_encode(b"some long complex string")
b'ONXW2ZJANRXW4ZZAMNXW24DMMV4CA43UOJUW4ZY='
 - Function 'base32_decode' takes 1 arguments: data.  Docstring: >>> base32_decode(b'JBSWY3DPEBLW64TMMQQQ====')
b'Hello World!'
>>> base32_decode(b'GEZDGNBVGY======')
b'123456'
>>> base32_decode(b'ONXW2ZJANRXW4ZZAMNXW24DMMV4CA43UOJUW4ZY=')
b'some long complex string'

File: base64.py
 - Function 'base64_encode' takes 1 arguments: data.  Docstring: Encodes data according to RFC4648.

The data is first transformed to binary and appended with binary digits so that its
length becomes a multiple of 6, then each 6 binary digits will match a character in
the B64_CHARSET string. The number of appended binary digits would later determine
how many "=" signs should be added, the padding.
For every 2 binary digits added, a "=" sign is added in the output.
We can add any binary digits to make it a multiple of 6, for instance, consider the
following example:
"AA" -> 0010100100101001 -> 001010 010010 1001
As can be seen above, 2 more binary digits should be added, so there's 4
possibilities here: 00, 01, 10 or 11.
That being said, Base64 encoding can be used in Steganography to hide data in these
appended digits.

>>> from base64 import b64encode
>>> a = b"This pull request is part of Hacktoberfest20!"
>>> b = b"https://tools.ietf.org/html/rfc4648"
>>> c = b"A"
>>> base64_encode(a) == b64encode(a)
True
>>> base64_encode(b) == b64encode(b)
True
>>> base64_encode(c) == b64encode(c)
True
>>> base64_encode("abc")
Traceback (most recent call last):
  ...
TypeError: a bytes-like object is required, not 'str'
 - Function 'base64_decode' takes 1 arguments: encoded_data.  Docstring: Decodes data according to RFC4648.

This does the reverse operation of base64_encode.
We first transform the encoded data back to a binary stream, take off the
previously appended binary digits according to the padding, at this point we
would have a binary stream whose length is multiple of 8, the last step is
to convert every 8 bits to a byte.

>>> from base64 import b64decode
>>> a = "VGhpcyBwdWxsIHJlcXVlc3QgaXMgcGFydCBvZiBIYWNrdG9iZXJmZXN0MjAh"
>>> b = "aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ2NDg="
>>> c = "QQ=="
>>> base64_decode(a) == b64decode(a)
True
>>> base64_decode(b) == b64decode(b)
True
>>> base64_decode(c) == b64decode(c)
True
>>> base64_decode("abc")
Traceback (most recent call last):
  ...
AssertionError: Incorrect padding

File: base85.py
 - Function '_base10_to_85' takes 1 arguments: d.  No docstring available.
 - Function '_base85_to_10' takes 1 arguments: digits.  No docstring available.
 - Function 'ascii85_encode' takes 1 arguments: data.  Docstring: >>> ascii85_encode(b"")
b''
>>> ascii85_encode(b"12345")
b'0etOA2#'
>>> ascii85_encode(b"base 85")
b'@UX=h+?24'
 - Function 'ascii85_decode' takes 1 arguments: data.  Docstring: >>> ascii85_decode(b"")
b''
>>> ascii85_decode(b"0etOA2#")
b'12345'
>>> ascii85_decode(b"@UX=h+?24")
b'base 85'

File: beaufort_cipher.py
 - Function 'generate_key' takes 2 arguments: message, key.  Docstring: >>> generate_key("THE GERMAN ATTACK","SECRET")
'SECRETSECRETSECRE'
 - Function 'cipher_text' takes 2 arguments: message, key_new.  Docstring: >>> cipher_text("THE GERMAN ATTACK","SECRETSECRETSECRE")
'BDC PAYUWL JPAIYI'
 - Function 'original_text' takes 2 arguments: cipher_text, key_new.  Docstring: >>> original_text("BDC PAYUWL JPAIYI","SECRETSECRETSECRE")
'THE GERMAN ATTACK'
 - Function 'main' takes 0 arguments: .  No docstring available.

File: bifid.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'letter_to_numbers' takes 2 arguments: self, letter.  Docstring: Return the pair of numbers that represents the given letter in the
polybius square

>>> np.array_equal(BifidCipher().letter_to_numbers('a'), [1,1])
True

>>> np.array_equal(BifidCipher().letter_to_numbers('u'), [4,5])
True
 - Function 'numbers_to_letter' takes 3 arguments: self, index1, index2.  Docstring: Return the letter corresponding to the position [index1, index2] in
the polybius square

>>> BifidCipher().numbers_to_letter(4, 5) == "u"
True

>>> BifidCipher().numbers_to_letter(1, 1) == "a"
True
 - Function 'encode' takes 2 arguments: self, message.  Docstring: Return the encoded version of message according to the polybius cipher

>>> BifidCipher().encode('testmessage') == 'qtltbdxrxlk'
True

>>> BifidCipher().encode('Test Message') == 'qtltbdxrxlk'
True

>>> BifidCipher().encode('test j') == BifidCipher().encode('test i')
True
 - Function 'decode' takes 2 arguments: self, message.  Docstring: Return the decoded version of message according to the polybius cipher

>>> BifidCipher().decode('qtltbdxrxlk') == 'testmessage'
True

File: brute_force_caesar_cipher.py
 - Function 'decrypt' takes 1 arguments: message.  Docstring: >>> decrypt('TMDETUX PMDVU')
Decryption using Key #0: TMDETUX PMDVU
Decryption using Key #1: SLCDSTW OLCUT
Decryption using Key #2: RKBCRSV NKBTS
Decryption using Key #3: QJABQRU MJASR
Decryption using Key #4: PIZAPQT LIZRQ
Decryption using Key #5: OHYZOPS KHYQP
Decryption using Key #6: NGXYNOR JGXPO
Decryption using Key #7: MFWXMNQ IFWON
Decryption using Key #8: LEVWLMP HEVNM
Decryption using Key #9: KDUVKLO GDUML
Decryption using Key #10: JCTUJKN FCTLK
Decryption using Key #11: IBSTIJM EBSKJ
Decryption using Key #12: HARSHIL DARJI
Decryption using Key #13: GZQRGHK CZQIH
Decryption using Key #14: FYPQFGJ BYPHG
Decryption using Key #15: EXOPEFI AXOGF
Decryption using Key #16: DWNODEH ZWNFE
Decryption using Key #17: CVMNCDG YVMED
Decryption using Key #18: BULMBCF XULDC
Decryption using Key #19: ATKLABE WTKCB
Decryption using Key #20: ZSJKZAD VSJBA
Decryption using Key #21: YRIJYZC URIAZ
Decryption using Key #22: XQHIXYB TQHZY
Decryption using Key #23: WPGHWXA SPGYX
Decryption using Key #24: VOFGVWZ ROFXW
Decryption using Key #25: UNEFUVY QNEWV
 - Function 'main' takes 0 arguments: .  No docstring available.

File: caesar_cipher.py
 - Function 'encrypt' takes 3 arguments: input_string, key, alphabet.  Docstring: encrypt
=======
Encodes a given string with the caesar cipher and returns the encoded
message

Parameters:
-----------
*   input_string: the plain-text that needs to be encoded
*   key: the number of letters to shift the message by

Optional:
*   alphabet (None): the alphabet used to encode the cipher, if not
    specified, the standard english alphabet with upper and lowercase
    letters is used

Returns:
*   A string containing the encoded cipher-text

More on the caesar cipher
=========================
The caesar cipher is named after Julius Caesar who used it when sending
secret military messages to his troops. This is a simple substitution cipher
where every character in the plain-text is shifted by a certain number known
as the "key" or "shift".

Example:
Say we have the following message:
"Hello, captain"

And our alphabet is made up of lower and uppercase letters:
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

And our shift is "2"

We can then encode the message, one letter at a time. "H" would become "J",
since "J" is two letters away, and so on. If the shift is ever two large, or
our letter is at the end of the alphabet, we just start at the beginning
("Z" would shift to "a" then "b" and so on).

Our final message would be "Jgnnq, ecrvckp"

Further reading
===============
*   https://en.m.wikipedia.org/wiki/Caesar_cipher

Doctests
========
>>> encrypt('The quick brown fox jumps over the lazy dog', 8)
'bpm yCqks jzwEv nwF rCuxA wDmz Bpm tiHG lwo'

>>> encrypt('A very large key', 8000)
's nWjq dSjYW cWq'

>>> encrypt('a lowercase alphabet', 5, 'abcdefghijklmnopqrstuvwxyz')
'f qtbjwhfxj fqumfgjy'
 - Function 'decrypt' takes 3 arguments: input_string, key, alphabet.  Docstring: decrypt
=======
Decodes a given string of cipher-text and returns the decoded plain-text

Parameters:
-----------
*   input_string: the cipher-text that needs to be decoded
*   key: the number of letters to shift the message backwards by to decode

Optional:
*   alphabet (None): the alphabet used to decode the cipher, if not
    specified, the standard english alphabet with upper and lowercase
    letters is used

Returns:
*   A string containing the decoded plain-text

More on the caesar cipher
=========================
The caesar cipher is named after Julius Caesar who used it when sending
secret military messages to his troops. This is a simple substitution cipher
where very character in the plain-text is shifted by a certain number known
as the "key" or "shift". Please keep in mind, here we will be focused on
decryption.

Example:
Say we have the following cipher-text:
"Jgnnq, ecrvckp"

And our alphabet is made up of lower and uppercase letters:
"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

And our shift is "2"

To decode the message, we would do the same thing as encoding, but in
reverse. The first letter, "J" would become "H" (remember: we are decoding)
because "H" is two letters in reverse (to the left) of "J". We would
continue doing this. A letter like "a" would shift back to the end of
the alphabet, and would become "Z" or "Y" and so on.

Our final message would be "Hello, captain"

Further reading
===============
*   https://en.m.wikipedia.org/wiki/Caesar_cipher

Doctests
========
>>> decrypt('bpm yCqks jzwEv nwF rCuxA wDmz Bpm tiHG lwo', 8)
'The quick brown fox jumps over the lazy dog'

>>> decrypt('s nWjq dSjYW cWq', 8000)
'A very large key'

>>> decrypt('f qtbjwhfxj fqumfgjy', 5, 'abcdefghijklmnopqrstuvwxyz')
'a lowercase alphabet'
 - Function 'brute_force' takes 2 arguments: input_string, alphabet.  Docstring: brute_force
===========
Returns all the possible combinations of keys and the decoded strings in the
form of a dictionary

Parameters:
-----------
*   input_string: the cipher-text that needs to be used during brute-force

Optional:
*   alphabet:  (None): the alphabet used to decode the cipher, if not
    specified, the standard english alphabet with upper and lowercase
    letters is used

More about brute force
======================
Brute force is when a person intercepts a message or password, not knowing
the key and tries every single combination. This is easy with the caesar
cipher since there are only all the letters in the alphabet. The more
complex the cipher, the larger amount of time it will take to do brute force

Ex:
Say we have a 5 letter alphabet (abcde), for simplicity and we intercepted the
following message:

"dbc"

we could then just write out every combination:
ecd... and so on, until we reach a combination that makes sense:
"cab"

Further reading
===============
*   https://en.wikipedia.org/wiki/Brute_force

Doctests
========
>>> brute_force("jFyuMy xIH'N vLONy zILwy Gy!")[20]
"Please don't brute force me!"

>>> brute_force(1)
Traceback (most recent call last):
TypeError: 'int' object is not iterable

File: cryptomath_module.py
 - Function 'find_mod_inverse' takes 2 arguments: a, m.  No docstring available.

File: decrypt_caesar_with_chi_squared.py
 - Function 'decrypt_caesar_with_chi_squared' takes 4 arguments: ciphertext, cipher_alphabet, frequencies_dict, case_sensitive.  Docstring: Basic Usage
===========
Arguments:
* ciphertext (str): the text to decode (encoded with the caesar cipher)

Optional Arguments:
* cipher_alphabet (list): the alphabet used for the cipher (each letter is
  a string separated by commas)
* frequencies_dict (dict): a dictionary of word frequencies where keys are
  the letters and values are a percentage representation of the frequency as
  a decimal/float
* case_sensitive (bool): a boolean value: True if the case matters during
  decryption, False if it doesn't

Returns:
* A tuple in the form of:
  (
    most_likely_cipher,
    most_likely_cipher_chi_squared_value,
    decoded_most_likely_cipher
  )

  where...
  - most_likely_cipher is an integer representing the shift of the smallest
    chi-squared statistic (most likely key)
  - most_likely_cipher_chi_squared_value is a float representing the
    chi-squared statistic of the most likely shift
  - decoded_most_likely_cipher is a string with the decoded cipher
    (decoded by the most_likely_cipher key)


The Chi-squared test
====================

The caesar cipher
-----------------
The caesar cipher is a very insecure encryption algorithm, however it has
been used since Julius Caesar. The cipher is a simple substitution cipher
where each character in the plain text is replaced by a character in the
alphabet a certain number of characters after the original character. The
number of characters away is called the shift or key. For example:

Plain text: hello
Key: 1
Cipher text: ifmmp
(each letter in hello has been shifted one to the right in the eng. alphabet)

As you can imagine, this doesn't provide lots of security. In fact
decrypting ciphertext by brute-force is extremely easy even by hand. However
 one way to do that is the chi-squared test.

The chi-squared test
-------------------
Each letter in the english alphabet has a frequency, or the amount of times
it shows up compared to other letters (usually expressed as a decimal
representing the percentage likelihood). The most common letter in the
english language is "e" with a frequency of 0.11162 or 11.162%. The test is
completed in the following fashion.

1. The ciphertext is decoded in a brute force way (every combination of the
   26 possible combinations)
2. For every combination, for each letter in the combination, the average
   amount of times the letter should appear the message is calculated by
   multiplying the total number of characters by the frequency of the letter

   For example:
   In a message of 100 characters, e should appear around 11.162 times.

 3. Then, to calculate the margin of error (the amount of times the letter
    SHOULD appear with the amount of times the letter DOES appear), we use
    the chi-squared test. The following formula is used:

    Let:
    - n be the number of times the letter actually appears
    - p be the predicted value of the number of times the letter should
      appear (see #2)
    - let v be the chi-squared test result (referred to here as chi-squared
      value/statistic)

    (n - p)^2
    --------- = v
       p

4. Each chi squared value for each letter is then added up to the total.
   The total is the chi-squared statistic for that encryption key.
5. The encryption key with the lowest chi-squared value is the most likely
   to be the decoded answer.

Further Reading
================

* http://practicalcryptography.com/cryptanalysis/text-characterisation/chi-squared-
    statistic/
* https://en.wikipedia.org/wiki/Letter_frequency
* https://en.wikipedia.org/wiki/Chi-squared_test
* https://en.m.wikipedia.org/wiki/Caesar_cipher

Doctests
========
>>> decrypt_caesar_with_chi_squared(
...    'dof pz aol jhlzhy jpwoly zv wvwbshy? pa pz avv lhzf av jyhjr!'
... )  # doctest: +NORMALIZE_WHITESPACE
(7, 3129.228005747531,
 'why is the caesar cipher so popular? it is too easy to crack!')

>>> decrypt_caesar_with_chi_squared('crybd cdbsxq')
(10, 233.35343938980898, 'short string')

>>> decrypt_caesar_with_chi_squared('Crybd Cdbsxq', case_sensitive=True)
(10, 233.35343938980898, 'Short String')

>>> decrypt_caesar_with_chi_squared(12)
Traceback (most recent call last):
AttributeError: 'int' object has no attribute 'lower'
 - Function 'chi_squared_statistic_values_sorting_key' takes 1 arguments: key.  No docstring available.

File: deterministic_miller_rabin.py
 - Function 'miller_rabin' takes 2 arguments: n, allow_probable.  Docstring: Deterministic Miller-Rabin algorithm for primes ~< 3.32e24.

Uses numerical analysis results to return whether or not the passed number
is prime. If the passed number is above the upper limit, and
allow_probable is True, then a return value of True indicates that n is
probably prime. This test does not allow False negatives- a return value
of False is ALWAYS composite.

Parameters
----------
n : int
    The integer to be tested. Since we usually care if a number is prime,
    n < 2 returns False instead of raising a ValueError.
allow_probable: bool, default False
    Whether or not to test n above the upper bound of the deterministic test.

Raises
------
ValueError

Reference
---------
https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test
 - Function 'test_miller_rabin' takes 0 arguments: .  Docstring: Testing a nontrivial (ends in 1, 3, 7, 9) composite
and a prime in each range.

File: diffie.py
 - Function 'find_primitive' takes 1 arguments: modulus.  Docstring: Find a primitive root modulo modulus, if one exists.

Args:
    modulus : The modulus for which to find a primitive root.

Returns:
    The primitive root if one exists, or None if there is none.

Examples:
>>> find_primitive(7)  # Modulo 7 has primitive root 3
3
>>> find_primitive(11)  # Modulo 11 has primitive root 2
2
>>> find_primitive(8) == None # Modulo 8 has no primitive root
True

File: diffie_hellman.py
 - Function '__init__' takes 2 arguments: self, group.  No docstring available.
 - Function 'get_private_key' takes 1 arguments: self.  No docstring available.
 - Function 'generate_public_key' takes 1 arguments: self.  No docstring available.
 - Function 'is_valid_public_key' takes 2 arguments: self, key.  No docstring available.
 - Function 'generate_shared_key' takes 2 arguments: self, other_key_str.  No docstring available.
 - Function 'is_valid_public_key_static' takes 2 arguments: remote_public_key_str, prime.  No docstring available.
 - Function 'generate_shared_key_static' takes 3 arguments: local_private_key_str, remote_public_key_str, group.  No docstring available.

File: elgamal_key_generator.py
 - Function 'primitive_root' takes 1 arguments: p_val.  No docstring available.
 - Function 'generate_key' takes 1 arguments: key_size.  No docstring available.
 - Function 'make_key_files' takes 2 arguments: name, key_size.  No docstring available.
 - Function 'main' takes 0 arguments: .  No docstring available.

File: enigma_machine2.py
 - Function '_validator' takes 3 arguments: rotpos, rotsel, pb.  Docstring: Checks if the values can be used for the 'enigma' function

>>> _validator((1,1,1), (rotor1, rotor2, rotor3), 'POLAND')
((1, 1, 1), ('EGZWVONAHDCLFQMSIPJBYUKXTR', 'FOBHMDKEXQNRAULPGSJVTYICZW', 'ZJXESIUQLHAVRMDOYGTNFWPBKC'), {'P': 'O', 'O': 'P', 'L': 'A', 'A': 'L', 'N': 'D', 'D': 'N'})

:param rotpos: rotor_positon
:param rotsel: rotor_selection
:param pb: plugb -> validated and transformed
:return: (rotpos, rotsel, pb)
 - Function '_plugboard' takes 1 arguments: pbstring.  Docstring: https://en.wikipedia.org/wiki/Enigma_machine#Plugboard

>>> _plugboard('PICTURES')
{'P': 'I', 'I': 'P', 'C': 'T', 'T': 'C', 'U': 'R', 'R': 'U', 'E': 'S', 'S': 'E'}
>>> _plugboard('POLAND')
{'P': 'O', 'O': 'P', 'L': 'A', 'A': 'L', 'N': 'D', 'D': 'N'}

In the code, 'pb' stands for 'plugboard'

Pairs can be separated by spaces
:param pbstring: string containing plugboard setting for the Enigma machine
:return: dictionary containing converted pairs
 - Function 'enigma' takes 4 arguments: text, rotor_position, rotor_selection, plugb.  Docstring: The only difference with real-world enigma is that I allowed string input.
All characters are converted to uppercase. (non-letter symbol are ignored)
How it works:
(for every letter in the message)

- Input letter goes into the plugboard.
If it is connected to another one, switch it.

- Letter goes through 3 rotors.
Each rotor can be represented as 2 sets of symbol, where one is shuffled.
Each symbol from the first set has corresponding symbol in
the second set and vice versa.

example:
| ABCDEFGHIJKLMNOPQRSTUVWXYZ | e.g. F=D and D=F
| VKLEPDBGRNWTFCJOHQAMUZYIXS |

- Symbol then goes through reflector (static rotor).
There it is switched with paired symbol
The reflector can be represented as2 sets, each with half of the alphanet.
There are usually 10 pairs of letters.

Example:
| ABCDEFGHIJKLM | e.g. E is paired to X
| ZYXWVUTSRQPON | so when E goes in X goes out and vice versa

- Letter then goes through the rotors again

- If the letter is connected to plugboard, it is switched.

- Return the letter

>>> enigma('Hello World!', (1, 2, 1), plugb='pictures')
'KORYH JUHHI!'
>>> enigma('KORYH, juhhi!', (1, 2, 1), plugb='pictures')
'HELLO, WORLD!'
>>> enigma('hello world!', (1, 1, 1), plugb='pictures')
'FPNCZ QWOBU!'
>>> enigma('FPNCZ QWOBU', (1, 1, 1), plugb='pictures')
'HELLO WORLD'


:param text: input message
:param rotor_position: tuple with 3 values in range 1..26
:param rotor_selection: tuple with 3 rotors ()
:param plugb: string containing plugboard configuration (default '')
:return: en/decrypted string

File: fractionated_morse_cipher.py
 - Function 'encode_to_morse' takes 1 arguments: plaintext.  Docstring: Encode a plaintext message into Morse code.

Args:
    plaintext: The plaintext message to encode.

Returns:
    The Morse code representation of the plaintext message.

Example:
    >>> encode_to_morse("defend the east")
    '-..x.x..-.x.x-.x-..xx-x....x.xx.x.-x...x-'
 - Function 'encrypt_fractionated_morse' takes 2 arguments: plaintext, key.  Docstring: Encrypt a plaintext message using Fractionated Morse Cipher.

Args:
    plaintext: The plaintext message to encrypt.
    key: The encryption key.

Returns:
    The encrypted ciphertext.

Example:
    >>> encrypt_fractionated_morse("defend the east","Roundtable")
    'ESOAVVLJRSSTRX'
 - Function 'decrypt_fractionated_morse' takes 2 arguments: ciphertext, key.  Docstring: Decrypt a ciphertext message encrypted with Fractionated Morse Cipher.

Args:
    ciphertext: The ciphertext message to decrypt.
    key: The decryption key.

Returns:
    The decrypted plaintext message.

Example:
    >>> decrypt_fractionated_morse("ESOAVVLJRSSTRX","Roundtable")
    'DEFEND THE EAST'

File: hill_cipher.py
 - Function '__init__' takes 2 arguments: self, encrypt_key.  Docstring: encrypt_key is an NxN numpy array
 - Function 'replace_letters' takes 2 arguments: self, letter.  Docstring: >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))
>>> hill_cipher.replace_letters('T')
19
>>> hill_cipher.replace_letters('0')
26
 - Function 'replace_digits' takes 2 arguments: self, num.  Docstring: >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))
>>> hill_cipher.replace_digits(19)
'T'
>>> hill_cipher.replace_digits(26)
'0'
 - Function 'check_determinant' takes 1 arguments: self.  Docstring: >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))
>>> hill_cipher.check_determinant()
 - Function 'process_text' takes 2 arguments: self, text.  Docstring: >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))
>>> hill_cipher.process_text('Testing Hill Cipher')
'TESTINGHILLCIPHERR'
>>> hill_cipher.process_text('hello')
'HELLOO'
 - Function 'encrypt' takes 2 arguments: self, text.  Docstring: >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))
>>> hill_cipher.encrypt('testing hill cipher')
'WHXYJOLM9C6XT085LL'
>>> hill_cipher.encrypt('hello')
'85FF00'
 - Function 'make_decrypt_key' takes 1 arguments: self.  Docstring: >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))
>>> hill_cipher.make_decrypt_key()
array([[ 6, 25],
       [ 5, 26]])
 - Function 'decrypt' takes 2 arguments: self, text.  Docstring: >>> hill_cipher = HillCipher(np.array([[2, 5], [1, 6]]))
>>> hill_cipher.decrypt('WHXYJOLM9C6XT085LL')
'TESTINGHILLCIPHERR'
>>> hill_cipher.decrypt('85FF00')
'HELLOO'
 - Function 'main' takes 0 arguments: .  No docstring available.

File: mixed_keyword_cypher.py
 - Function 'mixed_keyword' takes 4 arguments: keyword, plaintext, verbose, alphabet.  Docstring: For keyword: hello

H E L O
A B C D
F G I J
K M N P
Q R S T
U V W X
Y Z
and map vertically

>>> mixed_keyword("college", "UNIVERSITY", True)  # doctest: +NORMALIZE_WHITESPACE
{'A': 'C', 'B': 'A', 'C': 'I', 'D': 'P', 'E': 'U', 'F': 'Z', 'G': 'O', 'H': 'B',
 'I': 'J', 'J': 'Q', 'K': 'V', 'L': 'L', 'M': 'D', 'N': 'K', 'O': 'R', 'P': 'W',
 'Q': 'E', 'R': 'F', 'S': 'M', 'T': 'S', 'U': 'X', 'V': 'G', 'W': 'H', 'X': 'N',
 'Y': 'T', 'Z': 'Y'}
'XKJGUFMJST'

>>> mixed_keyword("college", "UNIVERSITY", False)  # doctest: +NORMALIZE_WHITESPACE
'XKJGUFMJST'

File: mono_alphabetic_ciphers.py
 - Function 'translate_message' takes 3 arguments: key, message, mode.  Docstring: >>> translate_message("QWERTYUIOPASDFGHJKLZXCVBNM","Hello World","encrypt")
'Pcssi Bidsm'
 - Function 'encrypt_message' takes 2 arguments: key, message.  Docstring: >>> encrypt_message("QWERTYUIOPASDFGHJKLZXCVBNM", "Hello World")
'Pcssi Bidsm'
 - Function 'decrypt_message' takes 2 arguments: key, message.  Docstring: >>> decrypt_message("QWERTYUIOPASDFGHJKLZXCVBNM", "Hello World")
'Itssg Vgksr'
 - Function 'main' takes 0 arguments: .  No docstring available.

File: morse_code.py
 - Function 'encrypt' takes 1 arguments: message.  Docstring: >>> encrypt("Sos!")
'... --- ... -.-.--'
>>> encrypt("SOS!") == encrypt("sos!")
True
 - Function 'decrypt' takes 1 arguments: message.  Docstring: >>> decrypt('... --- ... -.-.--')
'SOS!'
 - Function 'main' takes 0 arguments: .  Docstring: >>> s = "".join(MORSE_CODE_DICT)
>>> decrypt(encrypt(s)) == s
True

File: onepad_cipher.py
 - Function 'encrypt' takes 1 arguments: text.  Docstring: Function to encrypt text using pseudo-random numbers
>>> Onepad().encrypt("")
([], [])
>>> Onepad().encrypt([])
([], [])
>>> random.seed(1)
>>> Onepad().encrypt(" ")
([6969], [69])
>>> random.seed(1)
>>> Onepad().encrypt("Hello")
([9729, 114756, 4653, 31309, 10492], [69, 292, 33, 131, 61])
>>> Onepad().encrypt(1)
Traceback (most recent call last):
...
TypeError: 'int' object is not iterable
>>> Onepad().encrypt(1.1)
Traceback (most recent call last):
...
TypeError: 'float' object is not iterable
 - Function 'decrypt' takes 2 arguments: cipher, key.  Docstring: Function to decrypt text using pseudo-random numbers.
>>> Onepad().decrypt([], [])
''
>>> Onepad().decrypt([35], [])
''
>>> Onepad().decrypt([], [35])
Traceback (most recent call last):
...
IndexError: list index out of range
>>> random.seed(1)
>>> Onepad().decrypt([9729, 114756, 4653, 31309, 10492], [69, 292, 33, 131, 61])
'Hello'

File: permutation_cipher.py
 - Function 'generate_valid_block_size' takes 1 arguments: message_length.  Docstring: Generate a valid block size that is a factor of the message length.

Args:
    message_length (int): The length of the message.

Returns:
    int: A valid block size.

Example:
    >>> random.seed(1)
    >>> generate_valid_block_size(12)
    3
 - Function 'generate_permutation_key' takes 1 arguments: block_size.  Docstring: Generate a random permutation key of a specified block size.

Args:
    block_size (int): The size of each permutation block.

Returns:
    list[int]: A list containing a random permutation of digits.

Example:
    >>> random.seed(0)
    >>> generate_permutation_key(4)
    [2, 0, 1, 3]
 - Function 'encrypt' takes 3 arguments: message, key, block_size.  Docstring: Encrypt a message using a permutation cipher with block rearrangement using a key.

Args:
    message (str): The plaintext message to be encrypted.
    key (list[int]): The permutation key for decryption.
    block_size (int): The size of each permutation block.

Returns:
    tuple: A tuple containing the encrypted message and the encryption key.

Example:
    >>> encrypted_message, key = encrypt("HELLO WORLD")
    >>> decrypted_message = decrypt(encrypted_message, key)
    >>> decrypted_message
    'HELLO WORLD'
 - Function 'decrypt' takes 2 arguments: encrypted_message, key.  Docstring: Decrypt an encrypted message using a permutation cipher with block rearrangement.

Args:
    encrypted_message (str): The encrypted message.
    key (list[int]): The permutation key for decryption.

Returns:
    str: The decrypted plaintext message.

Example:
    >>> encrypted_message, key = encrypt("HELLO WORLD")
    >>> decrypted_message = decrypt(encrypted_message, key)
    >>> decrypted_message
    'HELLO WORLD'
 - Function 'main' takes 0 arguments: .  Docstring: Driver function to pass message to get encrypted, then decrypted.

Example:
>>> main()
Decrypted message: HELLO WORLD

File: playfair_cipher.py
 - Function 'chunker' takes 2 arguments: seq, size.  No docstring available.
 - Function 'prepare_input' takes 1 arguments: dirty.  Docstring: Prepare the plaintext by up-casing it
and separating repeated letters with X's
 - Function 'generate_table' takes 1 arguments: key.  No docstring available.
 - Function 'encode' takes 2 arguments: plaintext, key.  Docstring: Encode the given plaintext using the Playfair cipher.
Takes the plaintext and the key as input and returns the encoded string.

>>> encode("Hello", "MONARCHY")
'CFSUPM'
>>> encode("attack on the left flank", "EMERGENCY")
'DQZSBYFSDZFMFNLOHFDRSG'
>>> encode("Sorry!", "SPECIAL")
'AVXETX'
>>> encode("Number 1", "NUMBER")
'UMBENF'
>>> encode("Photosynthesis!", "THE SUN")
'OEMHQHVCHESUKE'
 - Function 'decode' takes 2 arguments: ciphertext, key.  Docstring: Decode the input string using the provided key.

>>> decode("BMZFAZRZDH", "HAZARD")
'FIREHAZARD'
>>> decode("HNBWBPQT", "AUTOMOBILE")
'DRIVINGX'
>>> decode("SLYSSAQS", "CASTLE")
'ATXTACKX'

File: polybius.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'letter_to_numbers' takes 2 arguments: self, letter.  Docstring: Return the pair of numbers that represents the given letter in the
polybius square
>>> np.array_equal(PolybiusCipher().letter_to_numbers('a'), [1,1])
True

>>> np.array_equal(PolybiusCipher().letter_to_numbers('u'), [4,5])
True
 - Function 'numbers_to_letter' takes 3 arguments: self, index1, index2.  Docstring: Return the letter corresponding to the position [index1, index2] in
the polybius square

>>> PolybiusCipher().numbers_to_letter(4, 5) == "u"
True

>>> PolybiusCipher().numbers_to_letter(1, 1) == "a"
True
 - Function 'encode' takes 2 arguments: self, message.  Docstring: Return the encoded version of message according to the polybius cipher

>>> PolybiusCipher().encode("test message") == "44154344 32154343112215"
True

>>> PolybiusCipher().encode("Test Message") == "44154344 32154343112215"
True
 - Function 'decode' takes 2 arguments: self, message.  Docstring: Return the decoded version of message according to the polybius cipher

>>> PolybiusCipher().decode("44154344 32154343112215") == "test message"
True

>>> PolybiusCipher().decode("4415434432154343112215") == "testmessage"
True

File: porta_cipher.py
 - Function 'generate_table' takes 1 arguments: key.  Docstring: >>> generate_table('marvin')  # doctest: +NORMALIZE_WHITESPACE
[('ABCDEFGHIJKLM', 'UVWXYZNOPQRST'), ('ABCDEFGHIJKLM', 'NOPQRSTUVWXYZ'),
 ('ABCDEFGHIJKLM', 'STUVWXYZNOPQR'), ('ABCDEFGHIJKLM', 'QRSTUVWXYZNOP'),
 ('ABCDEFGHIJKLM', 'WXYZNOPQRSTUV'), ('ABCDEFGHIJKLM', 'UVWXYZNOPQRST')]
 - Function 'encrypt' takes 2 arguments: key, words.  Docstring: >>> encrypt('marvin', 'jessica')
'QRACRWU'
 - Function 'decrypt' takes 2 arguments: key, words.  Docstring: >>> decrypt('marvin', 'QRACRWU')
'JESSICA'
 - Function 'get_position' takes 2 arguments: table, char.  Docstring: >>> get_position(generate_table('marvin')[0], 'M')
(0, 12)
 - Function 'get_opponent' takes 2 arguments: table, char.  Docstring: >>> get_opponent(generate_table('marvin')[0], 'M')
'T'

File: rabin_miller.py
 - Function 'rabin_miller' takes 1 arguments: num.  No docstring available.
 - Function 'is_prime_low_num' takes 1 arguments: num.  No docstring available.
 - Function 'generate_large_prime' takes 1 arguments: keysize.  No docstring available.

File: rail_fence_cipher.py
 - Function 'encrypt' takes 2 arguments: input_string, key.  Docstring: Shuffles the character of a string by placing each of them
in a grid (the height is dependent on the key) in a zigzag
formation and reading it left to right.

>>> encrypt("Hello World", 4)
'HWe olordll'

>>> encrypt("This is a message", 0)
Traceback (most recent call last):
    ...
ValueError: Height of grid can't be 0 or negative

>>> encrypt(b"This is a byte string", 5)
Traceback (most recent call last):
    ...
TypeError: sequence item 0: expected str instance, int found
 - Function 'decrypt' takes 2 arguments: input_string, key.  Docstring: Generates a template based on the key and fills it in with
the characters of the input string and then reading it in
a zigzag formation.

>>> decrypt("HWe olordll", 4)
'Hello World'

>>> decrypt("This is a message", -10)
Traceback (most recent call last):
    ...
ValueError: Height of grid can't be 0 or negative

>>> decrypt("My key is very big", 100)
'My key is very big'
 - Function 'bruteforce' takes 1 arguments: input_string.  Docstring: Uses decrypt function by guessing every key

>>> bruteforce("HWe olordll")[4]
'Hello World'

File: rot13.py
 - Function 'dencrypt' takes 2 arguments: s, n.  Docstring: https://en.wikipedia.org/wiki/ROT13

>>> msg = "My secret bank account number is 173-52946 so don't tell anyone!!"
>>> s = dencrypt(msg)
>>> s
"Zl frperg onax nppbhag ahzore vf 173-52946 fb qba'g gryy nalbar!!"
>>> dencrypt(s) == msg
True
 - Function 'main' takes 0 arguments: .  No docstring available.

File: rsa_cipher.py
 - Function 'get_blocks_from_text' takes 2 arguments: message, block_size.  No docstring available.
 - Function 'get_text_from_blocks' takes 3 arguments: block_ints, message_length, block_size.  No docstring available.
 - Function 'encrypt_message' takes 3 arguments: message, key, block_size.  No docstring available.
 - Function 'decrypt_message' takes 4 arguments: encrypted_blocks, message_length, key, block_size.  No docstring available.
 - Function 'read_key_file' takes 1 arguments: key_filename.  No docstring available.
 - Function 'encrypt_and_write_to_file' takes 4 arguments: message_filename, key_filename, message, block_size.  No docstring available.
 - Function 'read_from_file_and_decrypt' takes 2 arguments: message_filename, key_filename.  No docstring available.
 - Function 'main' takes 0 arguments: .  No docstring available.

File: rsa_factorization.py
 - Function 'rsafactor' takes 3 arguments: d, e, n.  Docstring: This function returns the factors of N, where p*q=N
  Return: [p, q]

We call N the RSA modulus, e the encryption exponent, and d the decryption exponent.
The pair (N, e) is the public key. As its name suggests, it is public and is used to
    encrypt messages.
The pair (N, d) is the secret key or private key and is known only to the recipient
    of encrypted messages.

>>> rsafactor(3, 16971, 25777)
[149, 173]
>>> rsafactor(7331, 11, 27233)
[113, 241]
>>> rsafactor(4021, 13, 17711)
[89, 199]

File: rsa_key_generator.py
 - Function 'main' takes 0 arguments: .  No docstring available.
 - Function 'generate_key' takes 1 arguments: key_size.  Docstring: >>> random.seed(0) # for repeatability
>>> public_key, private_key = generate_key(8)
>>> public_key
(26569, 239)
>>> private_key
(26569, 2855)
 - Function 'make_key_files' takes 2 arguments: name, key_size.  No docstring available.

File: running_key_cipher.py
 - Function 'running_key_encrypt' takes 2 arguments: key, plaintext.  Docstring: Encrypts the plaintext using the Running Key Cipher.

:param key: The running key (long piece of text).
:param plaintext: The plaintext to be encrypted.
:return: The ciphertext.
 - Function 'running_key_decrypt' takes 2 arguments: key, ciphertext.  Docstring: Decrypts the ciphertext using the Running Key Cipher.

:param key: The running key (long piece of text).
:param ciphertext: The ciphertext to be decrypted.
:return: The plaintext.
 - Function 'test_running_key_encrypt' takes 0 arguments: .  Docstring: >>> key = "How does the duck know that? said Victor"
>>> ciphertext = running_key_encrypt(key, "DEFEND THIS")
>>> running_key_decrypt(key, ciphertext) == "DEFENDTHIS"
True

File: shuffled_shift_cipher.py
 - Function '__init__' takes 2 arguments: self, passcode.  Docstring: Initializes a cipher object with a passcode as it's entity
Note: No new passcode is generated if user provides a passcode
while creating the object
 - Function '__str__' takes 1 arguments: self.  Docstring: :return: passcode of the cipher object
 - Function '__neg_pos' takes 2 arguments: self, iterlist.  Docstring: Mutates the list by changing the sign of each alternate element

:param iterlist: takes a list iterable
:return: the mutated list
 - Function '__passcode_creator' takes 1 arguments: self.  Docstring: Creates a random password from the selection buffer of
1. uppercase letters of the English alphabet
2. lowercase letters of the English alphabet
3. digits from 0 to 9

:rtype: list
:return: a password of a random length between 10 to 20
 - Function '__make_key_list' takes 1 arguments: self.  Docstring: Shuffles the ordered character choices by pivoting at breakpoints
Breakpoints are the set of characters in the passcode

eg:
    if, ABCDEFGHIJKLMNOPQRSTUVWXYZ are the possible characters
    and CAMERA is the passcode
    then, breakpoints = [A,C,E,M,R] # sorted set of characters from passcode
    shuffled parts: [A,CB,ED,MLKJIHGF,RQPON,ZYXWVUTS]
    shuffled __key_list : ACBEDMLKJIHGFRQPONZYXWVUTS

Shuffling only 26 letters of the english alphabet can generate 26!
combinations for the shuffled list. In the program we consider, a set of
97 characters (including letters, digits, punctuation and whitespaces),
thereby creating a possibility of 97! combinations (which is a 152 digit number
in itself), thus diminishing the possibility of a brute force approach.
Moreover, shift keys even introduce a multiple of 26 for a brute force approach
for each of the already 97! combinations.
 - Function '__make_shift_key' takes 1 arguments: self.  Docstring: sum() of the mutated list of ascii values of all characters where the
mutated list is the one returned by __neg_pos()
 - Function 'decrypt' takes 2 arguments: self, encoded_message.  Docstring: Performs shifting of the encoded_message w.r.t. the shuffled __key_list
to create the decoded_message

>>> ssc = ShuffledShiftCipher('4PYIXyqeQZr44')
>>> ssc.decrypt("d>**-1z6&'5z'5z:z+-='$'>=zp:>5:#z<'.&>#")
'Hello, this is a modified Caesar cipher'
 - Function 'encrypt' takes 2 arguments: self, plaintext.  Docstring: Performs shifting of the plaintext w.r.t. the shuffled __key_list
to create the encoded_message

>>> ssc = ShuffledShiftCipher('4PYIXyqeQZr44')
>>> ssc.encrypt('Hello, this is a modified Caesar cipher')
"d>**-1z6&'5z'5z:z+-='$'>=zp:>5:#z<'.&>#"
 - Function 'test_end_to_end' takes 1 arguments: msg.  Docstring: >>> test_end_to_end()
'Hello, this is a modified Caesar cipher'

File: simple_keyword_cypher.py
 - Function 'remove_duplicates' takes 1 arguments: key.  Docstring: Removes duplicate alphabetic characters in a keyword (letter is ignored after its
    first appearance).
:param key: Keyword to use
:return: String with duplicates removed
>>> remove_duplicates('Hello World!!')
'Helo Wrd'
 - Function 'create_cipher_map' takes 1 arguments: key.  Docstring: Returns a cipher map given a keyword.
:param key: keyword to use
:return: dictionary cipher map
 - Function 'encipher' takes 2 arguments: message, cipher_map.  Docstring: Enciphers a message given a cipher map.
:param message: Message to encipher
:param cipher_map: Cipher map
:return: enciphered string
>>> encipher('Hello World!!', create_cipher_map('Goodbye!!'))
'CYJJM VMQJB!!'
 - Function 'decipher' takes 2 arguments: message, cipher_map.  Docstring: Deciphers a message given a cipher map
:param message: Message to decipher
:param cipher_map: Dictionary mapping to use
:return: Deciphered string
>>> cipher_map = create_cipher_map('Goodbye!!')
>>> decipher(encipher('Hello World!!', cipher_map), cipher_map)
'HELLO WORLD!!'
 - Function 'main' takes 0 arguments: .  Docstring: Handles I/O
:return: void

File: simple_substitution_cipher.py
 - Function 'main' takes 0 arguments: .  No docstring available.
 - Function 'check_valid_key' takes 1 arguments: key.  No docstring available.
 - Function 'encrypt_message' takes 2 arguments: key, message.  Docstring: >>> encrypt_message('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Harshil Darji')
'Ilcrism Olcvs'
 - Function 'decrypt_message' takes 2 arguments: key, message.  Docstring: >>> decrypt_message('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Ilcrism Olcvs')
'Harshil Darji'
 - Function 'translate_message' takes 3 arguments: key, message, mode.  No docstring available.
 - Function 'get_random_key' takes 0 arguments: .  No docstring available.

File: transposition_cipher.py
 - Function 'main' takes 0 arguments: .  No docstring available.
 - Function 'encrypt_message' takes 2 arguments: key, message.  Docstring: >>> encrypt_message(6, 'Harshil Darji')
'Hlia rDsahrij'
 - Function 'decrypt_message' takes 2 arguments: key, message.  Docstring: >>> decrypt_message(6, 'Hlia rDsahrij')
'Harshil Darji'

File: transposition_cipher_encrypt_decrypt_file.py
 - Function 'main' takes 0 arguments: .  No docstring available.

File: trifid_cipher.py
 - Function '__encrypt_part' takes 2 arguments: message_part, character_to_number.  Docstring: Arrange the triagram value of each letter of 'message_part' vertically and join
them horizontally.

>>> __encrypt_part('ASK', TEST_CHARACTER_TO_NUMBER)
'132111112'
 - Function '__decrypt_part' takes 2 arguments: message_part, character_to_number.  Docstring: Convert each letter of the input string into their respective trigram values, join
them and split them into three equal groups of strings which are returned.

>>> __decrypt_part('ABCDE', TEST_CHARACTER_TO_NUMBER)
('11111', '21131', '21122')
 - Function '__prepare' takes 2 arguments: message, alphabet.  Docstring: A helper function that generates the triagrams and assigns each letter of the
alphabet to its corresponding triagram and stores this in a dictionary
("character_to_number" and "number_to_character") after confirming if the
alphabet's length is 27.

>>> test = __prepare('I aM a BOy','abCdeFghijkLmnopqrStuVwxYZ+')
>>> expected = ('IAMABOY','ABCDEFGHIJKLMNOPQRSTUVWXYZ+',
... TEST_CHARACTER_TO_NUMBER, TEST_NUMBER_TO_CHARACTER)
>>> test == expected
True

Testing with incomplete alphabet
>>> __prepare('I aM a BOy','abCdeFghijkLmnopqrStuVw')
Traceback (most recent call last):
    ...
KeyError: 'Length of alphabet has to be 27.'

Testing with extra long alphabets
>>> __prepare('I aM a BOy','abCdeFghijkLmnopqrStuVwxyzzwwtyyujjgfd')
Traceback (most recent call last):
    ...
KeyError: 'Length of alphabet has to be 27.'

Testing with punctuations that are not in the given alphabet
>>> __prepare('am i a boy?','abCdeFghijkLmnopqrStuVwxYZ+')
Traceback (most recent call last):
    ...
ValueError: Each message character has to be included in alphabet!

Testing with numbers
>>> __prepare(500,'abCdeFghijkLmnopqrStuVwxYZ+')
Traceback (most recent call last):
    ...
AttributeError: 'int' object has no attribute 'replace'
 - Function 'encrypt_message' takes 3 arguments: message, alphabet, period.  Docstring: encrypt_message
===============

Encrypts a message using the trifid_cipher. Any punctuatuions that
would be used should be added to the alphabet.

PARAMETERS
----------

*   message: The message you want to encrypt.
*   alphabet (optional): The characters to be used for the cipher .
*   period (optional): The number of characters you want in a group whilst
    encrypting.

>>> encrypt_message('I am a boy')
'BCDGBQY'

>>> encrypt_message(' ')
''

>>> encrypt_message('   aide toi le c  iel      ta id  era    ',
... 'FELIXMARDSTBCGHJKNOPQUVWYZ+',5)
'FMJFVOISSUFTFPUFEQQC'
 - Function 'decrypt_message' takes 3 arguments: message, alphabet, period.  Docstring: decrypt_message
===============

Decrypts a trifid_cipher encrypted message .

PARAMETERS
----------

*   message: The message you want to decrypt .
*   alphabet (optional): The characters used for the cipher.
*   period (optional): The number of characters used in grouping when it
    was encrypted.

>>> decrypt_message('BCDGBQY')
'IAMABOY'

Decrypting with your own alphabet and period
>>> decrypt_message('FMJFVOISSUFTFPUFEQQC','FELIXMARDSTBCGHJKNOPQUVWYZ+',5)
'AIDETOILECIELTAIDERA'

File: vernam_cipher.py
 - Function 'vernam_encrypt' takes 2 arguments: plaintext, key.  Docstring: >>> vernam_encrypt("HELLO","KEY")
'RIJVS'
 - Function 'vernam_decrypt' takes 2 arguments: ciphertext, key.  Docstring: >>> vernam_decrypt("RIJVS","KEY")
'HELLO'

File: vigenere_cipher.py
 - Function 'main' takes 0 arguments: .  No docstring available.
 - Function 'encrypt_message' takes 2 arguments: key, message.  Docstring: >>> encrypt_message('HDarji', 'This is Harshil Darji from Dharmaj.')
'Akij ra Odrjqqs Gaisq muod Mphumrs.'
 - Function 'decrypt_message' takes 2 arguments: key, message.  Docstring: >>> decrypt_message('HDarji', 'Akij ra Odrjqqs Gaisq muod Mphumrs.')
'This is Harshil Darji from Dharmaj.'
 - Function 'translate_message' takes 3 arguments: key, message, mode.  No docstring available.

File: xor_cipher.py
 - Function '__init__' takes 2 arguments: self, key.  Docstring: simple constructor that receives a key or uses
default key = 0
 - Function 'encrypt' takes 3 arguments: self, content, key.  Docstring: input: 'content' of type string and 'key' of type int
output: encrypted string 'content' as a list of chars
if key not passed the method uses the key by the constructor.
otherwise key = 1

Empty list
>>> XORCipher().encrypt("", 5)
[]

One key
>>> XORCipher().encrypt("hallo welt", 1)
['i', '`', 'm', 'm', 'n', '!', 'v', 'd', 'm', 'u']

Normal key
>>> XORCipher().encrypt("HALLO WELT", 32)
['h', 'a', 'l', 'l', 'o', '\x00', 'w', 'e', 'l', 't']

Key greater than 255
>>> XORCipher().encrypt("hallo welt", 256)
['h', 'a', 'l', 'l', 'o', ' ', 'w', 'e', 'l', 't']
 - Function 'decrypt' takes 3 arguments: self, content, key.  Docstring: input: 'content' of type list and 'key' of type int
output: decrypted string 'content' as a list of chars
if key not passed the method uses the key by the constructor.
otherwise key = 1

Empty list
>>> XORCipher().decrypt("", 5)
[]

One key
>>> XORCipher().decrypt("hallo welt", 1)
['i', '`', 'm', 'm', 'n', '!', 'v', 'd', 'm', 'u']

Normal key
>>> XORCipher().decrypt("HALLO WELT", 32)
['h', 'a', 'l', 'l', 'o', '\x00', 'w', 'e', 'l', 't']

Key greater than 255
>>> XORCipher().decrypt("hallo welt", 256)
['h', 'a', 'l', 'l', 'o', ' ', 'w', 'e', 'l', 't']
 - Function 'encrypt_string' takes 3 arguments: self, content, key.  Docstring: input: 'content' of type string and 'key' of type int
output: encrypted string 'content'
if key not passed the method uses the key by the constructor.
otherwise key = 1

Empty list
>>> XORCipher().encrypt_string("", 5)
''

One key
>>> XORCipher().encrypt_string("hallo welt", 1)
'i`mmn!vdmu'

Normal key
>>> XORCipher().encrypt_string("HALLO WELT", 32)
'hallo\x00welt'

Key greater than 255
>>> XORCipher().encrypt_string("hallo welt", 256)
'hallo welt'
 - Function 'decrypt_string' takes 3 arguments: self, content, key.  Docstring: input: 'content' of type string and 'key' of type int
output: decrypted string 'content'
if key not passed the method uses the key by the constructor.
otherwise key = 1

Empty list
>>> XORCipher().decrypt_string("", 5)
''

One key
>>> XORCipher().decrypt_string("hallo welt", 1)
'i`mmn!vdmu'

Normal key
>>> XORCipher().decrypt_string("HALLO WELT", 32)
'hallo\x00welt'

Key greater than 255
>>> XORCipher().decrypt_string("hallo welt", 256)
'hallo welt'
 - Function 'encrypt_file' takes 3 arguments: self, file, key.  Docstring: input: filename (str) and a key (int)
output: returns true if encrypt process was
successful otherwise false
if key not passed the method uses the key by the constructor.
otherwise key = 1
 - Function 'decrypt_file' takes 3 arguments: self, file, key.  Docstring: input: filename (str) and a key (int)
output: returns true if decrypt process was
successful otherwise false
if key not passed the method uses the key by the constructor.
otherwise key = 1

File: burrows_wheeler.py
 - Function 'all_rotations' takes 1 arguments: s.  Docstring: :param s: The string that will be rotated len(s) times.
:return: A list with the rotations.
:raises TypeError: If s is not an instance of str.
Examples:

>>> all_rotations("^BANANA|") # doctest: +NORMALIZE_WHITESPACE
['^BANANA|', 'BANANA|^', 'ANANA|^B', 'NANA|^BA', 'ANA|^BAN', 'NA|^BANA',
'A|^BANAN', '|^BANANA']
>>> all_rotations("a_asa_da_casa") # doctest: +NORMALIZE_WHITESPACE
['a_asa_da_casa', '_asa_da_casaa', 'asa_da_casaa_', 'sa_da_casaa_a',
'a_da_casaa_as', '_da_casaa_asa', 'da_casaa_asa_', 'a_casaa_asa_d',
'_casaa_asa_da', 'casaa_asa_da_', 'asaa_asa_da_c', 'saa_asa_da_ca',
'aa_asa_da_cas']
>>> all_rotations("panamabanana") # doctest: +NORMALIZE_WHITESPACE
['panamabanana', 'anamabananap', 'namabananapa', 'amabananapan',
'mabananapana', 'abananapanam', 'bananapanama', 'ananapanamab',
'nanapanamaba', 'anapanamaban', 'napanamabana', 'apanamabanan']
>>> all_rotations(5)
Traceback (most recent call last):
    ...
TypeError: The parameter s type must be str.
 - Function 'bwt_transform' takes 1 arguments: s.  Docstring: :param s: The string that will be used at bwt algorithm
:return: the string composed of the last char of each row of the ordered
rotations and the index of the original string at ordered rotations list
:raises TypeError: If the s parameter type is not str
:raises ValueError: If the s parameter is empty
Examples:

>>> bwt_transform("^BANANA")
{'bwt_string': 'BNN^AAA', 'idx_original_string': 6}
>>> bwt_transform("a_asa_da_casa")
{'bwt_string': 'aaaadss_c__aa', 'idx_original_string': 3}
>>> bwt_transform("panamabanana")
{'bwt_string': 'mnpbnnaaaaaa', 'idx_original_string': 11}
>>> bwt_transform(4)
Traceback (most recent call last):
    ...
TypeError: The parameter s type must be str.
>>> bwt_transform('')
Traceback (most recent call last):
    ...
ValueError: The parameter s must not be empty.
 - Function 'reverse_bwt' takes 2 arguments: bwt_string, idx_original_string.  Docstring: :param bwt_string: The string returned from bwt algorithm execution
:param idx_original_string: A 0-based index of the string that was used to
generate bwt_string at ordered rotations list
:return: The string used to generate bwt_string when bwt was executed
:raises TypeError: If the bwt_string parameter type is not str
:raises ValueError: If the bwt_string parameter is empty
:raises TypeError: If the idx_original_string type is not int or if not
possible to cast it to int
:raises ValueError: If the idx_original_string value is lower than 0 or
greater than len(bwt_string) - 1

>>> reverse_bwt("BNN^AAA", 6)
'^BANANA'
>>> reverse_bwt("aaaadss_c__aa", 3)
'a_asa_da_casa'
>>> reverse_bwt("mnpbnnaaaaaa", 11)
'panamabanana'
>>> reverse_bwt(4, 11)
Traceback (most recent call last):
    ...
TypeError: The parameter bwt_string type must be str.
>>> reverse_bwt("", 11)
Traceback (most recent call last):
    ...
ValueError: The parameter bwt_string must not be empty.
>>> reverse_bwt("mnpbnnaaaaaa", "asd") # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
    ...
TypeError: The parameter idx_original_string type must be int or passive
of cast to int.
>>> reverse_bwt("mnpbnnaaaaaa", -1)
Traceback (most recent call last):
    ...
ValueError: The parameter idx_original_string must not be lower than 0.
>>> reverse_bwt("mnpbnnaaaaaa", 12) # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
    ...
ValueError: The parameter idx_original_string must be lower than
len(bwt_string).
>>> reverse_bwt("mnpbnnaaaaaa", 11.0)
'panamabanana'
>>> reverse_bwt("mnpbnnaaaaaa", 11.4)
'panamabanana'

File: huffman.py
 - Function '__init__' takes 3 arguments: self, letter, freq.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 4 arguments: self, freq, left, right.  No docstring available.
 - Function 'parse_file' takes 1 arguments: file_path.  Docstring: Read the file and build a dict of all letters and their
frequencies, then convert the dict into a list of Letters.
 - Function 'build_tree' takes 1 arguments: letters.  Docstring: Run through the list of Letters and build the min heap
for the Huffman Tree.
 - Function 'traverse_tree' takes 2 arguments: root, bitstring.  Docstring: Recursively traverse the Huffman Tree to set each
Letter's bitstring dictionary, and return the list of Letters
 - Function 'huffman' takes 1 arguments: file_path.  Docstring: Parse the file, build the tree, then run through the file
again, using the letters dictionary to find and print out the
bitstring for each letter.

File: lempel_ziv.py
 - Function 'read_file_binary' takes 1 arguments: file_path.  Docstring: Reads given file as bytes and returns them as a long string
 - Function 'add_key_to_lexicon' takes 4 arguments: lexicon, curr_string, index, last_match_id.  Docstring: Adds new strings (curr_string + "0",  curr_string + "1") to the lexicon
 - Function 'compress_data' takes 1 arguments: data_bits.  Docstring: Compresses given data_bits using Lempel-Ziv-Welch compression algorithm
and returns the result as a string
 - Function 'add_file_length' takes 2 arguments: source_path, compressed.  Docstring: Adds given file's length in front (using Elias  gamma coding) of the compressed
string
 - Function 'write_file_binary' takes 2 arguments: file_path, to_write.  Docstring: Writes given to_write string (should only consist of 0's and 1's) as bytes in the
file
 - Function 'compress' takes 2 arguments: source_path, destination_path.  Docstring: Reads source file, compresses it and writes the compressed result in destination
file

File: lempel_ziv_decompress.py
 - Function 'read_file_binary' takes 1 arguments: file_path.  Docstring: Reads given file as bytes and returns them as a long string
 - Function 'decompress_data' takes 1 arguments: data_bits.  Docstring: Decompresses given data_bits using Lempel-Ziv-Welch compression algorithm
and returns the result as a string
 - Function 'write_file_binary' takes 2 arguments: file_path, to_write.  Docstring: Writes given to_write string (should only consist of 0's and 1's) as bytes in the
file
 - Function 'remove_prefix' takes 1 arguments: data_bits.  Docstring: Removes size prefix, that compressed file should have
Returns the result
 - Function 'compress' takes 2 arguments: source_path, destination_path.  Docstring: Reads source file, decompresses it and writes the result in destination file

File: lz77.py
 - Function '__repr__' takes 1 arguments: self.  Docstring: >>> token = Token(1, 2, "c")
>>> repr(token)
'(1, 2, c)'
>>> str(token)
'(1, 2, c)'
 - Function '__init__' takes 3 arguments: self, window_size, lookahead_buffer_size.  No docstring available.
 - Function 'compress' takes 2 arguments: self, text.  Docstring: Compress the given string text using LZ77 compression algorithm.

Args:
    text: string to be compressed

Returns:
    output: the compressed text as a list of Tokens

>>> lz77_compressor = LZ77Compressor()
>>> str(lz77_compressor.compress("ababcbababaa"))
'[(0, 0, a), (0, 0, b), (2, 2, c), (4, 3, a), (2, 2, a)]'
>>> str(lz77_compressor.compress("aacaacabcabaaac"))
'[(0, 0, a), (1, 1, c), (3, 4, b), (3, 3, a), (1, 2, c)]'
 - Function 'decompress' takes 2 arguments: self, tokens.  Docstring: Convert the list of tokens into an output string.

Args:
    tokens: list containing triplets (offset, length, char)

Returns:
    output: decompressed text

Tests:
    >>> lz77_compressor = LZ77Compressor()
    >>> lz77_compressor.decompress([Token(0, 0, 'c'), Token(0, 0, 'a'),
    ... Token(0, 0, 'b'), Token(0, 0, 'r'), Token(3, 1, 'c'),
    ... Token(2, 1, 'd'), Token(7, 4, 'r'), Token(3, 5, 'd')])
    'cabracadabrarrarrad'
    >>> lz77_compressor.decompress([Token(0, 0, 'a'), Token(0, 0, 'b'),
    ... Token(2, 2, 'c'), Token(4, 3, 'a'), Token(2, 2, 'a')])
    'ababcbababaa'
    >>> lz77_compressor.decompress([Token(0, 0, 'a'), Token(1, 1, 'c'),
    ... Token(3, 4, 'b'), Token(3, 3, 'a'), Token(1, 2, 'c')])
    'aacaacabcabaaac'
 - Function '_find_encoding_token' takes 3 arguments: self, text, search_buffer.  Docstring: Finds the encoding token for the first character in the text.

Tests:
    >>> lz77_compressor = LZ77Compressor()
    >>> lz77_compressor._find_encoding_token("abrarrarrad", "abracad").offset
    7
    >>> lz77_compressor._find_encoding_token("adabrarrarrad", "cabrac").length
    1
    >>> lz77_compressor._find_encoding_token("abc", "xyz").offset
    0
    >>> lz77_compressor._find_encoding_token("", "xyz").offset
    Traceback (most recent call last):
        ...
    ValueError: We need some text to work with.
    >>> lz77_compressor._find_encoding_token("abc", "").offset
    0
 - Function '_match_length_from_index' takes 5 arguments: self, text, window, text_index, window_index.  Docstring: Calculate the longest possible match of text and window characters from
text_index in text and window_index in window.

Args:
    text: _description_
    window: sliding window
    text_index: index of character in text
    window_index: index of character in sliding window

Returns:
    The maximum match between text and window, from given indexes.

Tests:
    >>> lz77_compressor = LZ77Compressor(13, 6)
    >>> lz77_compressor._match_length_from_index("rarrad", "adabrar", 0, 4)
    5
    >>> lz77_compressor._match_length_from_index("adabrarrarrad",
    ...     "cabrac", 0, 1)
    1

File: peak_signal_to_noise_ratio.py
 - Function 'peak_signal_to_noise_ratio' takes 2 arguments: original, contrast.  No docstring available.
 - Function 'main' takes 0 arguments: .  No docstring available.

File: run_length_encoding.py
 - Function 'run_length_encode' takes 1 arguments: text.  Docstring: Performs Run Length Encoding
>>> run_length_encode("AAAABBBCCDAA")
[('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)]
>>> run_length_encode("A")
[('A', 1)]
>>> run_length_encode("AA")
[('A', 2)]
>>> run_length_encode("AAADDDDDDFFFCCCAAVVVV")
[('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)]
 - Function 'run_length_decode' takes 1 arguments: encoded.  Docstring: Performs Run Length Decoding
>>> run_length_decode([('A', 4), ('B', 3), ('C', 2), ('D', 1), ('A', 2)])
'AAAABBBCCDAA'
>>> run_length_decode([('A', 1)])
'A'
>>> run_length_decode([('A', 2)])
'AA'
>>> run_length_decode([('A', 3), ('D', 6), ('F', 3), ('C', 3), ('A', 2), ('V', 4)])
'AAADDDDDDFFFCCCAAVVVV'

File: cnn_classification.py

File: flip_augmentation.py
 - Function 'main' takes 0 arguments: .  Docstring: Get images list and annotations list from input dir.
Update new images and annotations.
Save images and annotations in output dir.
 - Function 'get_dataset' takes 2 arguments: label_dir, img_dir.  Docstring: - label_dir <type: str>: Path to label include annotation of images
- img_dir <type: str>: Path to folder contain images
Return <type: list>: List of images path and labels
 - Function 'update_image_and_anno' takes 3 arguments: img_list, anno_list, flip_type.  Docstring: - img_list <type: list>: list of all images
- anno_list <type: list>: list of all annotations of specific image
- flip_type <type: int>: 0 is vertical, 1 is horizontal
Return:
    - new_imgs_list <type: narray>: image after resize
    - new_annos_lists <type: list>: list of new annotation after scale
    - path_list <type: list>: list the name of image file
 - Function 'random_chars' takes 1 arguments: number_char.  Docstring: Automatic generate random 32 characters.
Get random string code: '7b7ad245cdff75241935e4dd860f3bad'
>>> len(random_chars(32))
32

File: haralick_descriptors.py
 - Function 'root_mean_square_error' takes 2 arguments: original, reference.  Docstring: Simple implementation of Root Mean Squared Error
for two N dimensional numpy arrays.

Examples:
    >>> root_mean_square_error(np.array([1, 2, 3]), np.array([1, 2, 3]))
    0.0
    >>> root_mean_square_error(np.array([1, 2, 3]), np.array([2, 2, 2]))
    0.816496580927726
    >>> root_mean_square_error(np.array([1, 2, 3]), np.array([6, 4, 2]))
    3.1622776601683795
 - Function 'normalize_image' takes 3 arguments: image, cap, data_type.  Docstring: Normalizes image in Numpy 2D array format, between ranges 0-cap,
as to fit uint8 type.

Args:
    image: 2D numpy array representing image as matrix, with values in any range
    cap: Maximum cap amount for normalization
    data_type: numpy data type to set output variable to
Returns:
    return 2D numpy array of type uint8, corresponding to limited range matrix

Examples:
    >>> normalize_image(np.array([[1, 2, 3], [4, 5, 10]]),
    ...                 cap=1.0, data_type=np.float64)
    array([[0.        , 0.11111111, 0.22222222],
           [0.33333333, 0.44444444, 1.        ]])
    >>> normalize_image(np.array([[4, 4, 3], [1, 7, 2]]))
    array([[127, 127,  85],
           [  0, 255,  42]], dtype=uint8)
 - Function 'normalize_array' takes 2 arguments: array, cap.  Docstring: Normalizes a 1D array, between ranges 0-cap.

Args:
    array: List containing values to be normalized between cap range.
    cap: Maximum cap amount for normalization.
Returns:
    return 1D numpy array, corresponding to limited range array

Examples:
    >>> normalize_array(np.array([2, 3, 5, 7]))
    array([0. , 0.2, 0.6, 1. ])
    >>> normalize_array(np.array([[5], [7], [11], [13]]))
    array([[0.  ],
           [0.25],
           [0.75],
           [1.  ]])
 - Function 'grayscale' takes 1 arguments: image.  Docstring: Uses luminance weights to transform RGB channel to greyscale, by
taking the dot product between the channel and the weights.

Example:
    >>> grayscale(np.array([[[108, 201, 72], [255, 11,  127]],
    ...                     [[56,  56,  56], [128, 255, 107]]]))
    array([[158,  97],
           [ 56, 200]], dtype=uint8)
 - Function 'binarize' takes 2 arguments: image, threshold.  Docstring: Binarizes a grayscale image based on a given threshold value,
setting values to 1 or 0 accordingly.

Examples:
    >>> binarize(np.array([[128, 255], [101, 156]]))
    array([[1, 1],
           [0, 1]])
    >>> binarize(np.array([[0.07, 1], [0.51, 0.3]]), threshold=0.5)
    array([[0, 1],
           [1, 0]])
 - Function 'transform' takes 3 arguments: image, kind, kernel.  Docstring: Simple image transformation using one of two available filter functions:
Erosion and Dilation.

Args:
    image: binarized input image, onto which to apply transformation
    kind: Can be either 'erosion', in which case the :func:np.max
          function is called, or 'dilation', when :func:np.min is used instead.
    kernel: n x n kernel with shape < :attr:image.shape,
          to be used when applying convolution to original image

Returns:
    returns a numpy array with same shape as input image,
    corresponding to applied binary transformation.

Examples:
    >>> img = np.array([[1, 0.5], [0.2, 0.7]])
    >>> img = binarize(img, threshold=0.5)
    >>> transform(img, 'erosion')
    array([[1, 1],
           [1, 1]], dtype=uint8)
    >>> transform(img, 'dilation')
    array([[0, 0],
           [0, 0]], dtype=uint8)
 - Function 'opening_filter' takes 2 arguments: image, kernel.  Docstring: Opening filter, defined as the sequence of
erosion and then a dilation filter on the same image.

Examples:
    >>> img = np.array([[1, 0.5], [0.2, 0.7]])
    >>> img = binarize(img, threshold=0.5)
    >>> opening_filter(img)
    array([[1, 1],
           [1, 1]], dtype=uint8)
 - Function 'closing_filter' takes 2 arguments: image, kernel.  Docstring: Opening filter, defined as the sequence of
dilation and then erosion filter on the same image.

Examples:
    >>> img = np.array([[1, 0.5], [0.2, 0.7]])
    >>> img = binarize(img, threshold=0.5)
    >>> closing_filter(img)
    array([[0, 0],
           [0, 0]], dtype=uint8)
 - Function 'binary_mask' takes 2 arguments: image_gray, image_map.  Docstring: Apply binary mask, or thresholding based
on bit mask value (mapping mask is binary).

Returns the mapped true value mask and its complementary false value mask.

Example:
    >>> img = np.array([[[108, 201, 72], [255, 11,  127]],
    ...                 [[56,  56,  56], [128, 255, 107]]])
    >>> gray = grayscale(img)
    >>> binary = binarize(gray)
    >>> morphological = opening_filter(binary)
    >>> binary_mask(gray, morphological)
    (array([[1, 1],
           [1, 1]], dtype=uint8), array([[158,  97],
           [ 56, 200]], dtype=uint8))
 - Function 'matrix_concurrency' takes 2 arguments: image, coordinate.  Docstring: Calculate sample co-occurrence matrix based on input image
as well as selected coordinates on image.

Implementation is made using basic iteration,
as function to be performed (np.max) is non-linear and therefore
not callable on the frequency domain.

Example:
    >>> img = np.array([[[108, 201, 72], [255, 11,  127]],
    ...                 [[56,  56,  56], [128, 255, 107]]])
    >>> gray = grayscale(img)
    >>> binary = binarize(gray)
    >>> morphological = opening_filter(binary)
    >>> mask_1 = binary_mask(gray, morphological)[0]
    >>> matrix_concurrency(mask_1, (0, 1))
    array([[0., 0.],
           [0., 0.]])
 - Function 'haralick_descriptors' takes 1 arguments: matrix.  Docstring: Calculates all 8 Haralick descriptors based on co-occurrence input matrix.
All descriptors are as follows:
Maximum probability, Inverse Difference, Homogeneity, Entropy,
Energy, Dissimilarity, Contrast and Correlation

Args:
    matrix: Co-occurrence matrix to use as base for calculating descriptors.

Returns:
    Reverse ordered list of resulting descriptors

Example:
    >>> img = np.array([[[108, 201, 72], [255, 11,  127]],
    ...                 [[56,  56,  56], [128, 255, 107]]])
    >>> gray = grayscale(img)
    >>> binary = binarize(gray)
    >>> morphological = opening_filter(binary)
    >>> mask_1 = binary_mask(gray, morphological)[0]
    >>> concurrency = matrix_concurrency(mask_1, (0, 1))
    >>> haralick_descriptors(concurrency)
    [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
 - Function 'get_descriptors' takes 2 arguments: masks, coordinate.  Docstring: Calculate all Haralick descriptors for a sequence of
different co-occurrence matrices, given input masks and coordinates.

Example:
    >>> img = np.array([[[108, 201, 72], [255, 11,  127]],
    ...                 [[56,  56,  56], [128, 255, 107]]])
    >>> gray = grayscale(img)
    >>> binary = binarize(gray)
    >>> morphological = opening_filter(binary)
    >>> get_descriptors(binary_mask(gray, morphological), (0, 1))
    array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])
 - Function 'euclidean' takes 2 arguments: point_1, point_2.  Docstring: Simple method for calculating the euclidean distance between two points,
with type np.ndarray.

Example:
    >>> a = np.array([1, 0, -2])
    >>> b = np.array([2, -1, 1])
    >>> euclidean(a, b)
    3.3166247903554
 - Function 'get_distances' takes 2 arguments: descriptors, base.  Docstring: Calculate all Euclidean distances between a selected base descriptor
and all other Haralick descriptors
The resulting comparison is return in decreasing order,
showing which descriptor is the most similar to the selected base.

Args:
    descriptors: Haralick descriptors to compare with base index
    base: Haralick descriptor index to use as base when calculating respective
    euclidean distance to other descriptors.

Returns:
    Ordered distances between descriptors

Example:
    >>> index = 1
    >>> img = np.array([[[108, 201, 72], [255, 11,  127]],
    ...                 [[56,  56,  56], [128, 255, 107]]])
    >>> gray = grayscale(img)
    >>> binary = binarize(gray)
    >>> morphological = opening_filter(binary)
    >>> get_distances(get_descriptors(
    ...                 binary_mask(gray, morphological), (0, 1)),
    ...               index)
    [(0, 0.0), (1, 0.0), (2, 0.0), (3, 0.0), (4, 0.0), (5, 0.0), (6, 0.0), (7, 0.0), (8, 0.0), (9, 0.0), (10, 0.0), (11, 0.0), (12, 0.0), (13, 0.0), (14, 0.0), (15, 0.0)]

File: harris_corner.py
 - Function '__init__' takes 3 arguments: self, k, window_size.  Docstring: k : is an empirically determined constant in [0.04,0.06]
window_size : neighbourhoods considered
 - Function '__str__' takes 1 arguments: self.  No docstring available.
 - Function 'detect' takes 2 arguments: self, img_path.  Docstring: Returns the image with corners identified
img_path  : path of the image
output : list of the corner positions, image

File: horn_schunck.py
 - Function 'warp' takes 3 arguments: image, horizontal_flow, vertical_flow.  Docstring: Warps the pixels of an image into a new image using the horizontal and vertical
flows.
Pixels that are warped from an invalid location are set to 0.

Parameters:
    image: Grayscale image
    horizontal_flow: Horizontal flow
    vertical_flow: Vertical flow

Returns: Warped image

>>> warp(np.array([[0, 1, 2], [0, 3, 0], [2, 2, 2]]),     np.array([[0, 1, -1], [-1, 0, 0], [1, 1, 1]]),     np.array([[0, 0, 0], [0, 1, 0], [0, 0, 1]]))
array([[0, 0, 0],
       [3, 1, 0],
       [0, 2, 3]])
 - Function 'horn_schunck' takes 4 arguments: image0, image1, num_iter, alpha.  Docstring: This function performs the Horn-Schunck algorithm and returns the estimated
optical flow. It is assumed that the input images are grayscale and
normalized to be in [0, 1].

Parameters:
    image0: First image of the sequence
    image1: Second image of the sequence
    alpha: Regularization constant
    num_iter: Number of iterations performed

Returns: estimated horizontal & vertical flow

>>> np.round(horn_schunck(np.array([[0, 0, 2], [0, 0, 2]]),     np.array([[0, 2, 0], [0, 2, 0]]), alpha=0.1, num_iter=110)).    astype(np.int32)
array([[[ 0, -1, -1],
        [ 0, -1, -1]],
<BLANKLINE>
       [[ 0,  0,  0],
        [ 0,  0,  0]]], dtype=int32)

File: mean_threshold.py
 - Function 'mean_threshold' takes 1 arguments: image.  Docstring: image: is a grayscale PIL image object

File: mosaic_augmentation.py
 - Function 'main' takes 0 arguments: .  Docstring: Get images list and annotations list from input dir.
Update new images and annotations.
Save images and annotations in output dir.
 - Function 'get_dataset' takes 2 arguments: label_dir, img_dir.  Docstring: - label_dir <type: str>: Path to label include annotation of images
- img_dir <type: str>: Path to folder contain images
Return <type: list>: List of images path and labels
 - Function 'update_image_and_anno' takes 6 arguments: all_img_list, all_annos, idxs, output_size, scale_range, filter_scale.  Docstring: - all_img_list <type: list>: list of all images
- all_annos <type: list>: list of all annotations of specific image
- idxs <type: list>: index of image in list
- output_size <type: tuple>: size of output image (Height, Width)
- scale_range <type: tuple>: range of scale image
- filter_scale <type: float>: the condition of downscale image and bounding box
Return:
    - output_img <type: narray>: image after resize
    - new_anno <type: list>: list of new annotation after scale
    - path[0] <type: string>: get the name of image file
 - Function 'random_chars' takes 1 arguments: number_char.  Docstring: Automatic generate random 32 characters.
Get random string code: '7b7ad245cdff75241935e4dd860f3bad'
>>> len(random_chars(32))
32

File: pooling_functions.py
 - Function 'maxpooling' takes 3 arguments: arr, size, stride.  Docstring: This function is used to perform maxpooling on the input array of 2D matrix(image)
Args:
    arr: numpy array
    size: size of pooling matrix
    stride: the number of pixels shifts over the input matrix
Returns:
    numpy array of maxpooled matrix
Sample Input Output:
>>> maxpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2)
array([[ 6.,  8.],
       [14., 16.]])
>>> maxpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1)
array([[241., 180.],
       [241., 157.]])
 - Function 'avgpooling' takes 3 arguments: arr, size, stride.  Docstring: This function is used to perform avgpooling on the input array of 2D matrix(image)
Args:
    arr: numpy array
    size: size of pooling matrix
    stride: the number of pixels shifts over the input matrix
Returns:
    numpy array of avgpooled matrix
Sample Input Output:
>>> avgpooling([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], 2, 2)
array([[ 3.,  5.],
       [11., 13.]])
>>> avgpooling([[147, 180, 122],[241, 76, 32],[126, 13, 157]], 2, 1)
array([[161., 102.],
       [114.,  69.]])

File: astronomical_length_scale_conversion.py
 - Function 'length_conversion' takes 3 arguments: value, from_type, to_type.  Docstring: Conversion between astronomical length units.

>>> length_conversion(1, "meter", "kilometer")
0.001
>>> length_conversion(1, "meter", "megametre")
1e-06
>>> length_conversion(1, "gigametre", "meter")
1000000000
>>> length_conversion(1, "gigametre", "terametre")
0.001
>>> length_conversion(1, "petametre", "terametre")
1000
>>> length_conversion(1, "petametre", "exametre")
0.001
>>> length_conversion(1, "terametre", "zettametre")
1e-09
>>> length_conversion(1, "yottametre", "zettametre")
1000
>>> length_conversion(4, "wrongUnit", "inch")
Traceback (most recent call last):
  ...
ValueError: Invalid 'from_type' value: 'wrongUnit'.
Conversion abbreviations are: m, km, Mm, Gm, Tm, Pm, Em, Zm, Ym

File: binary_to_decimal.py
 - Function 'bin_to_decimal' takes 1 arguments: bin_string.  Docstring: Convert a binary value to its decimal equivalent

>>> bin_to_decimal("101")
5
>>> bin_to_decimal(" 1010   ")
10
>>> bin_to_decimal("-11101")
-29
>>> bin_to_decimal("0")
0
>>> bin_to_decimal("a")
Traceback (most recent call last):
    ...
ValueError: Non-binary value was passed to the function
>>> bin_to_decimal("")
Traceback (most recent call last):
    ...
ValueError: Empty string was passed to the function
>>> bin_to_decimal("39")
Traceback (most recent call last):
    ...
ValueError: Non-binary value was passed to the function

File: binary_to_hexadecimal.py
 - Function 'bin_to_hexadecimal' takes 1 arguments: binary_str.  Docstring: Converting a binary string into hexadecimal using Grouping Method

>>> bin_to_hexadecimal('101011111')
'0x15f'
>>> bin_to_hexadecimal(' 1010   ')
'0x0a'
>>> bin_to_hexadecimal('-11101')
'-0x1d'
>>> bin_to_hexadecimal('a')
Traceback (most recent call last):
    ...
ValueError: Non-binary value was passed to the function
>>> bin_to_hexadecimal('')
Traceback (most recent call last):
    ...
ValueError: Empty string was passed to the function

File: binary_to_octal.py
 - Function 'bin_to_octal' takes 1 arguments: bin_string.  No docstring available.

File: convert_number_to_words.py
 - Function 'max_value' takes 2 arguments: cls, system.  Docstring: Gets the max value supported by the given number system.

>>> NumberingSystem.max_value("short") == 10**18 - 1
True
>>> NumberingSystem.max_value("long") == 10**21 - 1
True
>>> NumberingSystem.max_value("indian") == 10**19 - 1
True
 - Function 'convert_small_number' takes 1 arguments: num.  Docstring: Converts small, non-negative integers with irregular constructions in English (i.e.,
numbers under 100) into words.

>>> convert_small_number(0)
'zero'
>>> convert_small_number(5)
'five'
>>> convert_small_number(10)
'ten'
>>> convert_small_number(15)
'fifteen'
>>> convert_small_number(20)
'twenty'
>>> convert_small_number(25)
'twenty-five'
>>> convert_small_number(-1)
Traceback (most recent call last):
...
ValueError: This function only accepts non-negative integers
>>> convert_small_number(123)
Traceback (most recent call last):
...
ValueError: This function only converts numbers less than 100
 - Function 'convert_number' takes 2 arguments: num, system.  Docstring: Converts an integer to English words.

:param num: The integer to be converted
:param system: The numbering system (short, long, or Indian)

>>> convert_number(0)
'zero'
>>> convert_number(1)
'one'
>>> convert_number(100)
'one hundred'
>>> convert_number(-100)
'negative one hundred'
>>> convert_number(123_456_789_012_345) # doctest: +NORMALIZE_WHITESPACE
'one hundred twenty-three trillion four hundred fifty-six billion
seven hundred eighty-nine million twelve thousand three hundred forty-five'
>>> convert_number(123_456_789_012_345, "long") # doctest: +NORMALIZE_WHITESPACE
'one hundred twenty-three thousand four hundred fifty-six milliard
seven hundred eighty-nine million twelve thousand three hundred forty-five'
>>> convert_number(12_34_56_78_90_12_345, "indian") # doctest: +NORMALIZE_WHITESPACE
'one crore crore twenty-three lakh crore
forty-five thousand six hundred seventy-eight crore
ninety lakh twelve thousand three hundred forty-five'
>>> convert_number(10**18)
Traceback (most recent call last):
...
ValueError: Input number is too large
>>> convert_number(10**21, "long")
Traceback (most recent call last):
...
ValueError: Input number is too large
>>> convert_number(10**19, "indian")
Traceback (most recent call last):
...
ValueError: Input number is too large

File: decimal_to_any.py
 - Function 'decimal_to_any' takes 2 arguments: num, base.  Docstring: Convert a positive integer to another base as str.
>>> decimal_to_any(0, 2)
'0'
>>> decimal_to_any(5, 4)
'11'
>>> decimal_to_any(20, 3)
'202'
>>> decimal_to_any(58, 16)
'3A'
>>> decimal_to_any(243, 17)
'E5'
>>> decimal_to_any(34923, 36)
'QY3'
>>> decimal_to_any(10, 11)
'A'
>>> decimal_to_any(16, 16)
'10'
>>> decimal_to_any(36, 36)
'10'
>>> # negatives will error
>>> decimal_to_any(-45, 8)  # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
ValueError: parameter must be positive int
>>> # floats will error
>>> decimal_to_any(34.4, 6) # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
TypeError: int() can't convert non-string with explicit base
>>> # a float base will error
>>> decimal_to_any(5, 2.5) # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
TypeError: 'float' object cannot be interpreted as an integer
>>> # a str base will error
>>> decimal_to_any(10, '16') # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
TypeError: 'str' object cannot be interpreted as an integer
>>> # a base less than 2 will error
>>> decimal_to_any(7, 0) # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
ValueError: base must be >= 2
>>> # a base greater than 36 will error
>>> decimal_to_any(34, 37) # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
ValueError: base must be <= 36

File: decimal_to_binary.py
 - Function 'decimal_to_binary_iterative' takes 1 arguments: num.  Docstring: Convert an Integer Decimal Number to a Binary Number as str.
>>> decimal_to_binary_iterative(0)
'0b0'
>>> decimal_to_binary_iterative(2)
'0b10'
>>> decimal_to_binary_iterative(7)
'0b111'
>>> decimal_to_binary_iterative(35)
'0b100011'
>>> # negatives work too
>>> decimal_to_binary_iterative(-2)
'-0b10'
>>> # other floats will error
>>> decimal_to_binary_iterative(16.16) # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
TypeError: 'float' object cannot be interpreted as an integer
>>> # strings will error as well
>>> decimal_to_binary_iterative('0xfffff') # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
TypeError: 'str' object cannot be interpreted as an integer
 - Function 'decimal_to_binary_recursive_helper' takes 1 arguments: decimal.  Docstring: Take a positive integer value and return its binary equivalent.
>>> decimal_to_binary_recursive_helper(1000)
'1111101000'
>>> decimal_to_binary_recursive_helper("72")
'1001000'
>>> decimal_to_binary_recursive_helper("number")
Traceback (most recent call last):
    ...
ValueError: invalid literal for int() with base 10: 'number'
 - Function 'decimal_to_binary_recursive' takes 1 arguments: number.  Docstring: Take an integer value and raise ValueError for wrong inputs,
call the function above and return the output with prefix "0b" & "-0b"
for positive and negative integers respectively.
>>> decimal_to_binary_recursive(0)
'0b0'
>>> decimal_to_binary_recursive(40)
'0b101000'
>>> decimal_to_binary_recursive(-40)
'-0b101000'
>>> decimal_to_binary_recursive(40.8)
Traceback (most recent call last):
    ...
ValueError: Input value is not an integer
>>> decimal_to_binary_recursive("forty")
Traceback (most recent call last):
    ...
ValueError: Input value is not an integer

File: decimal_to_hexadecimal.py
 - Function 'decimal_to_hexadecimal' takes 1 arguments: decimal.  Docstring: take integer decimal value, return hexadecimal representation as str beginning
with 0x
>>> decimal_to_hexadecimal(5)
'0x5'
>>> decimal_to_hexadecimal(15)
'0xf'
>>> decimal_to_hexadecimal(37)
'0x25'
>>> decimal_to_hexadecimal(255)
'0xff'
>>> decimal_to_hexadecimal(4096)
'0x1000'
>>> decimal_to_hexadecimal(999098)
'0xf3eba'
>>> # negatives work too
>>> decimal_to_hexadecimal(-256)
'-0x100'
>>> # floats are acceptable if equivalent to an int
>>> decimal_to_hexadecimal(17.0)
'0x11'
>>> # other floats will error
>>> decimal_to_hexadecimal(16.16) # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
AssertionError
>>> # strings will error as well
>>> decimal_to_hexadecimal('0xfffff') # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
AssertionError
>>> # results are the same when compared to Python's default hex function
>>> decimal_to_hexadecimal(-256) == hex(-256)
True

File: decimal_to_octal.py
 - Function 'decimal_to_octal' takes 1 arguments: num.  Docstring: Convert a Decimal Number to an Octal Number.

>>> all(decimal_to_octal(i) == oct(i) for i
...     in (0, 2, 8, 64, 65, 216, 255, 256, 512))
True
 - Function 'main' takes 0 arguments: .  Docstring: Print octal equivalents of decimal numbers.

File: energy_conversions.py
 - Function 'energy_conversion' takes 3 arguments: from_type, to_type, value.  Docstring: Conversion of energy units.
>>> energy_conversion("joule", "joule", 1)
1.0
>>> energy_conversion("joule", "kilojoule", 1)
0.001
>>> energy_conversion("joule", "megajoule", 1)
1e-06
>>> energy_conversion("joule", "gigajoule", 1)
1e-09
>>> energy_conversion("joule", "wattsecond", 1)
1.0
>>> energy_conversion("joule", "watthour", 1)
0.0002777777777777778
>>> energy_conversion("joule", "kilowatthour", 1)
2.7777777777777776e-07
>>> energy_conversion("joule", "newtonmeter", 1)
1.0
>>> energy_conversion("joule", "calorie_nutr", 1)
0.00023884589662749592
>>> energy_conversion("joule", "kilocalorie_nutr", 1)
2.388458966274959e-07
>>> energy_conversion("joule", "electronvolt", 1)
6.241509074460763e+18
>>> energy_conversion("joule", "britishthermalunit_it", 1)
0.0009478171226670134
>>> energy_conversion("joule", "footpound", 1)
0.7375621211696556
>>> energy_conversion("joule", "megajoule", 1000)
0.001
>>> energy_conversion("calorie_nutr", "kilocalorie_nutr", 1000)
1.0
>>> energy_conversion("kilowatthour", "joule", 10)
36000000.0
>>> energy_conversion("britishthermalunit_it", "footpound", 1)
778.1692306784539
>>> energy_conversion("watthour", "joule", "a") # doctest: +ELLIPSIS
Traceback (most recent call last):
  ...
TypeError: unsupported operand type(s) for /: 'str' and 'float'
>>> energy_conversion("wrongunit", "joule", 1) # doctest: +ELLIPSIS
Traceback (most recent call last):
  ...
ValueError: Incorrect 'from_type' or 'to_type' value: 'wrongunit', 'joule'
Valid values are: joule, ... footpound
>>> energy_conversion("joule", "wrongunit", 1) # doctest: +ELLIPSIS
Traceback (most recent call last):
  ...
ValueError: Incorrect 'from_type' or 'to_type' value: 'joule', 'wrongunit'
Valid values are: joule, ... footpound
>>> energy_conversion("123", "abc", 1) # doctest: +ELLIPSIS
Traceback (most recent call last):
  ...
ValueError: Incorrect 'from_type' or 'to_type' value: '123', 'abc'
Valid values are: joule, ... footpound

File: excel_title_to_column.py
 - Function 'excel_title_to_column' takes 1 arguments: column_title.  Docstring: Given a string column_title that represents
the column title in an Excel sheet, return
its corresponding column number.

>>> excel_title_to_column("A")
1
>>> excel_title_to_column("B")
2
>>> excel_title_to_column("AB")
28
>>> excel_title_to_column("Z")
26

File: hexadecimal_to_decimal.py
 - Function 'hex_to_decimal' takes 1 arguments: hex_string.  Docstring: Convert a hexadecimal value to its decimal equivalent
#https://www.programiz.com/python-programming/methods/built-in/hex

>>> hex_to_decimal("a")
10
>>> hex_to_decimal("12f")
303
>>> hex_to_decimal("   12f   ")
303
>>> hex_to_decimal("FfFf")
65535
>>> hex_to_decimal("-Ff")
-255
>>> hex_to_decimal("F-f")
Traceback (most recent call last):
    ...
ValueError: Non-hexadecimal value was passed to the function
>>> hex_to_decimal("")
Traceback (most recent call last):
    ...
ValueError: Empty string was passed to the function
>>> hex_to_decimal("12m")
Traceback (most recent call last):
    ...
ValueError: Non-hexadecimal value was passed to the function

File: hex_to_bin.py
 - Function 'hex_to_bin' takes 1 arguments: hex_num.  Docstring: Convert a hexadecimal value to its binary equivalent
#https://stackoverflow.com/questions/1425493/convert-hex-to-binary
Here, we have used the bitwise right shift operator: >>
Shifts the bits of the number to the right and fills 0 on voids left as a result.
Similar effect as of dividing the number with some power of two.
Example:
a = 10
a >> 1 = 5

>>> hex_to_bin("AC")
10101100
>>> hex_to_bin("9A4")
100110100100
>>> hex_to_bin("   12f   ")
100101111
>>> hex_to_bin("FfFf")
1111111111111111
>>> hex_to_bin("-fFfF")
-1111111111111111
>>> hex_to_bin("F-f")
Traceback (most recent call last):
    ...
ValueError: Invalid value was passed to the function
>>> hex_to_bin("")
Traceback (most recent call last):
    ...
ValueError: No value was passed to the function

File: ipv4_conversion.py
 - Function 'ipv4_to_decimal' takes 1 arguments: ipv4_address.  Docstring: Convert an IPv4 address to its decimal representation.

Args:
    ip_address: A string representing an IPv4 address (e.g., "192.168.0.1").

Returns:
    int: The decimal representation of the IP address.

>>> ipv4_to_decimal("192.168.0.1")
3232235521
>>> ipv4_to_decimal("10.0.0.255")
167772415
>>> ipv4_to_decimal("10.0.255")
Traceback (most recent call last):
    ...
ValueError: Invalid IPv4 address format
>>> ipv4_to_decimal("10.0.0.256")
Traceback (most recent call last):
    ...
ValueError: Invalid IPv4 octet 256
 - Function 'alt_ipv4_to_decimal' takes 1 arguments: ipv4_address.  Docstring: >>> alt_ipv4_to_decimal("192.168.0.1")
3232235521
>>> alt_ipv4_to_decimal("10.0.0.255")
167772415
 - Function 'decimal_to_ipv4' takes 1 arguments: decimal_ipv4.  Docstring: Convert a decimal representation of an IP address to its IPv4 format.

Args:
    decimal_ipv4: An integer representing the decimal IP address.

Returns:
    The IPv4 representation of the decimal IP address.

>>> decimal_to_ipv4(3232235521)
'192.168.0.1'
>>> decimal_to_ipv4(167772415)
'10.0.0.255'
>>> decimal_to_ipv4(-1)
Traceback (most recent call last):
    ...
ValueError: Invalid decimal IPv4 address

File: length_conversion.py
 - Function 'length_conversion' takes 3 arguments: value, from_type, to_type.  Docstring: Conversion between length units.

>>> length_conversion(4, "METER", "FEET")
13.12336
>>> length_conversion(4, "M", "FT")
13.12336
>>> length_conversion(1, "meter", "kilometer")
0.001
>>> length_conversion(1, "kilometer", "inch")
39370.1
>>> length_conversion(3, "kilometer", "mile")
1.8641130000000001
>>> length_conversion(2, "feet", "meter")
0.6096
>>> length_conversion(4, "feet", "yard")
1.333329312
>>> length_conversion(1, "inch", "meter")
0.0254
>>> length_conversion(2, "inch", "mile")
3.15656468e-05
>>> length_conversion(2, "centimeter", "millimeter")
20.0
>>> length_conversion(2, "centimeter", "yard")
0.0218722
>>> length_conversion(4, "yard", "meter")
3.6576
>>> length_conversion(4, "yard", "kilometer")
0.0036576
>>> length_conversion(3, "foot", "meter")
0.9144000000000001
>>> length_conversion(3, "foot", "inch")
36.00001944
>>> length_conversion(4, "mile", "kilometer")
6.43736
>>> length_conversion(2, "miles", "InChEs")
126719.753468
>>> length_conversion(3, "millimeter", "centimeter")
0.3
>>> length_conversion(3, "mm", "in")
0.1181103
>>> length_conversion(4, "wrongUnit", "inch")
Traceback (most recent call last):
  ...
ValueError: Invalid 'from_type' value: 'wrongUnit'.
Conversion abbreviations are: mm, cm, m, km, in, ft, yd, mi

File: molecular_chemistry.py
 - Function 'molarity_to_normality' takes 3 arguments: nfactor, moles, volume.  Docstring: Convert molarity to normality.
  Volume is taken in litres.

  Wikipedia reference: https://en.wikipedia.org/wiki/Equivalent_concentration
  Wikipedia reference: https://en.wikipedia.org/wiki/Molar_concentration

  >>> molarity_to_normality(2, 3.1, 0.31)
  20
  >>> molarity_to_normality(4, 11.4, 5.7)
  8
 - Function 'moles_to_pressure' takes 3 arguments: volume, moles, temperature.  Docstring: Convert moles to pressure.
  Ideal gas laws are used.
  Temperature is taken in kelvin.
  Volume is taken in litres.
  Pressure has atm as SI unit.

  Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws
  Wikipedia reference: https://en.wikipedia.org/wiki/Pressure
  Wikipedia reference: https://en.wikipedia.org/wiki/Temperature

  >>> moles_to_pressure(0.82, 3, 300)
  90
  >>> moles_to_pressure(8.2, 5, 200)
  10
 - Function 'moles_to_volume' takes 3 arguments: pressure, moles, temperature.  Docstring: Convert moles to volume.
  Ideal gas laws are used.
  Temperature is taken in kelvin.
  Volume is taken in litres.
  Pressure has atm as SI unit.

  Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws
  Wikipedia reference: https://en.wikipedia.org/wiki/Pressure
  Wikipedia reference: https://en.wikipedia.org/wiki/Temperature

  >>> moles_to_volume(0.82, 3, 300)
  90
  >>> moles_to_volume(8.2, 5, 200)
  10
 - Function 'pressure_and_volume_to_temperature' takes 3 arguments: pressure, moles, volume.  Docstring: Convert pressure and volume to temperature.
  Ideal gas laws are used.
  Temperature is taken in kelvin.
  Volume is taken in litres.
  Pressure has atm as SI unit.

  Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws
  Wikipedia reference: https://en.wikipedia.org/wiki/Pressure
  Wikipedia reference: https://en.wikipedia.org/wiki/Temperature

  >>> pressure_and_volume_to_temperature(0.82, 1, 2)
  20
  >>> pressure_and_volume_to_temperature(8.2, 5, 3)
  60

File: octal_to_binary.py
 - Function 'octal_to_binary' takes 1 arguments: octal_number.  Docstring: Convert an Octal number to Binary.

>>> octal_to_binary("17")
'001111'
>>> octal_to_binary("7")
'111'
>>> octal_to_binary("Av")
Traceback (most recent call last):
    ...
ValueError: Non-octal value was passed to the function
>>> octal_to_binary("@#")
Traceback (most recent call last):
    ...
ValueError: Non-octal value was passed to the function
>>> octal_to_binary("")
Traceback (most recent call last):
    ...
ValueError: Empty string was passed to the function

File: octal_to_decimal.py
 - Function 'oct_to_decimal' takes 1 arguments: oct_string.  Docstring: Convert a octal value to its decimal equivalent

>>> oct_to_decimal("")
Traceback (most recent call last):
    ...
ValueError: Empty string was passed to the function
>>> oct_to_decimal("-")
Traceback (most recent call last):
    ...
ValueError: Non-octal value was passed to the function
>>> oct_to_decimal("e")
Traceback (most recent call last):
    ...
ValueError: Non-octal value was passed to the function
>>> oct_to_decimal("8")
Traceback (most recent call last):
    ...
ValueError: Non-octal value was passed to the function
>>> oct_to_decimal("-e")
Traceback (most recent call last):
    ...
ValueError: Non-octal value was passed to the function
>>> oct_to_decimal("-8")
Traceback (most recent call last):
    ...
ValueError: Non-octal value was passed to the function
>>> oct_to_decimal("1")
1
>>> oct_to_decimal("-1")
-1
>>> oct_to_decimal("12")
10
>>> oct_to_decimal(" 12   ")
10
>>> oct_to_decimal("-45")
-37
>>> oct_to_decimal("-")
Traceback (most recent call last):
    ...
ValueError: Non-octal value was passed to the function
>>> oct_to_decimal("0")
0
>>> oct_to_decimal("-4055")
-2093
>>> oct_to_decimal("2-0Fm")
Traceback (most recent call last):
    ...
ValueError: Non-octal value was passed to the function
>>> oct_to_decimal("")
Traceback (most recent call last):
    ...
ValueError: Empty string was passed to the function
>>> oct_to_decimal("19")
Traceback (most recent call last):
    ...
ValueError: Non-octal value was passed to the function

File: octal_to_hexadecimal.py
 - Function 'octal_to_hex' takes 1 arguments: octal.  Docstring: Convert an Octal number to Hexadecimal number.
For more information: https://en.wikipedia.org/wiki/Octal

>>> octal_to_hex("100")
'0x40'
>>> octal_to_hex("235")
'0x9D'
>>> octal_to_hex(17)
Traceback (most recent call last):
    ...
TypeError: Expected a string as input
>>> octal_to_hex("Av")
Traceback (most recent call last):
    ...
ValueError: Not a Valid Octal Number
>>> octal_to_hex("")
Traceback (most recent call last):
    ...
ValueError: Empty string was passed to the function

File: prefix_conversions.py
 - Function 'convert_si_prefix' takes 3 arguments: known_amount, known_prefix, unknown_prefix.  Docstring: Wikipedia reference: https://en.wikipedia.org/wiki/Binary_prefix
Wikipedia reference: https://en.wikipedia.org/wiki/International_System_of_Units
>>> convert_si_prefix(1, SIUnit.giga, SIUnit.mega)
1000
>>> convert_si_prefix(1, SIUnit.mega, SIUnit.giga)
0.001
>>> convert_si_prefix(1, SIUnit.kilo, SIUnit.kilo)
1
>>> convert_si_prefix(1, 'giga', 'mega')
1000
>>> convert_si_prefix(1, 'gIGa', 'mEGa')
1000
 - Function 'convert_binary_prefix' takes 3 arguments: known_amount, known_prefix, unknown_prefix.  Docstring: Wikipedia reference: https://en.wikipedia.org/wiki/Metric_prefix
>>> convert_binary_prefix(1, BinaryUnit.giga, BinaryUnit.mega)
1024
>>> convert_binary_prefix(1, BinaryUnit.mega, BinaryUnit.giga)
0.0009765625
>>> convert_binary_prefix(1, BinaryUnit.kilo, BinaryUnit.kilo)
1
>>> convert_binary_prefix(1, 'giga', 'mega')
1024
>>> convert_binary_prefix(1, 'gIGa', 'mEGa')
1024

File: prefix_conversions_string.py
 - Function 'get_positive' takes 1 arguments: cls.  Docstring: Returns a dictionary with only the elements of this enum
that has a positive value
>>> from itertools import islice
>>> positive = SIUnit.get_positive()
>>> inc = iter(positive.items())
>>> dict(islice(inc, len(positive) // 2))
{'yotta': 24, 'zetta': 21, 'exa': 18, 'peta': 15, 'tera': 12}
>>> dict(inc)
{'giga': 9, 'mega': 6, 'kilo': 3, 'hecto': 2, 'deca': 1}
 - Function 'get_negative' takes 1 arguments: cls.  Docstring: Returns a dictionary with only the elements of this enum
that has a negative value
@example
>>> from itertools import islice
>>> negative = SIUnit.get_negative()
>>> inc = iter(negative.items())
>>> dict(islice(inc, len(negative) // 2))
{'deci': -1, 'centi': -2, 'milli': -3, 'micro': -6, 'nano': -9}
>>> dict(inc)
{'pico': -12, 'femto': -15, 'atto': -18, 'zepto': -21, 'yocto': -24}
 - Function 'add_si_prefix' takes 1 arguments: value.  Docstring: Function that converts a number to his version with SI prefix
@input value (an integer)
@example:
>>> add_si_prefix(10000)
'10.0 kilo'
 - Function 'add_binary_prefix' takes 1 arguments: value.  Docstring: Function that converts a number to his version with Binary prefix
@input value (an integer)
@example:
>>> add_binary_prefix(65536)
'64.0 kilo'

File: pressure_conversions.py
 - Function 'pressure_conversion' takes 3 arguments: value, from_type, to_type.  Docstring: Conversion between pressure units.
>>> pressure_conversion(4, "atm", "pascal")
405300
>>> pressure_conversion(1, "pascal", "psi")
0.00014401981999999998
>>> pressure_conversion(1, "bar", "atm")
0.986923
>>> pressure_conversion(3, "kilopascal", "bar")
0.029999991892499998
>>> pressure_conversion(2, "megapascal", "psi")
290.074434314
>>> pressure_conversion(4, "psi", "torr")
206.85984
>>> pressure_conversion(1, "inHg", "atm")
0.0334211
>>> pressure_conversion(1, "torr", "psi")
0.019336718261000002
>>> pressure_conversion(4, "wrongUnit", "atm")
Traceback (most recent call last):
    ...
ValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are:
atm, pascal, bar, kilopascal, megapascal, psi, inHg, torr

File: rgb_cmyk_conversion.py
 - Function 'rgb_to_cmyk' takes 3 arguments: r_input, g_input, b_input.  Docstring: Simple RGB to CMYK conversion. Returns percentages of CMYK paint.
https://www.programmingalgorithms.com/algorithm/rgb-to-cmyk/

Note: this is a very popular algorithm that converts colors linearly and gives
only approximate results. Actual preparation for printing requires advanced color
conversion considering the color profiles and parameters of the target device.

>>> rgb_to_cmyk(255, 200, "a")
Traceback (most recent call last):
    ...
ValueError: Expected int, found (<class 'int'>, <class 'int'>, <class 'str'>)

>>> rgb_to_cmyk(255, 255, 999)
Traceback (most recent call last):
    ...
ValueError: Expected int of the range 0..255

>>> rgb_to_cmyk(255, 255, 255)  # white
(0, 0, 0, 0)

>>> rgb_to_cmyk(128, 128, 128)  # gray
(0, 0, 0, 50)

>>> rgb_to_cmyk(0, 0, 0)    # black
(0, 0, 0, 100)

>>> rgb_to_cmyk(255, 0, 0)  # red
(0, 100, 100, 0)

>>> rgb_to_cmyk(0, 255, 0)  # green
(100, 0, 100, 0)

>>> rgb_to_cmyk(0, 0, 255)    # blue
(100, 100, 0, 0)

File: rgb_hsv_conversion.py
 - Function 'hsv_to_rgb' takes 3 arguments: hue, saturation, value.  Docstring: Conversion from the HSV-representation to the RGB-representation.
Expected RGB-values taken from
https://www.rapidtables.com/convert/color/hsv-to-rgb.html

>>> hsv_to_rgb(0, 0, 0)
[0, 0, 0]
>>> hsv_to_rgb(0, 0, 1)
[255, 255, 255]
>>> hsv_to_rgb(0, 1, 1)
[255, 0, 0]
>>> hsv_to_rgb(60, 1, 1)
[255, 255, 0]
>>> hsv_to_rgb(120, 1, 1)
[0, 255, 0]
>>> hsv_to_rgb(240, 1, 1)
[0, 0, 255]
>>> hsv_to_rgb(300, 1, 1)
[255, 0, 255]
>>> hsv_to_rgb(180, 0.5, 0.5)
[64, 128, 128]
>>> hsv_to_rgb(234, 0.14, 0.88)
[193, 196, 224]
>>> hsv_to_rgb(330, 0.75, 0.5)
[128, 32, 80]
 - Function 'rgb_to_hsv' takes 3 arguments: red, green, blue.  Docstring: Conversion from the RGB-representation to the HSV-representation.
The tested values are the reverse values from the hsv_to_rgb-doctests.
Function "approximately_equal_hsv" is needed because of small deviations due to
rounding for the RGB-values.

>>> approximately_equal_hsv(rgb_to_hsv(0, 0, 0), [0, 0, 0])
True
>>> approximately_equal_hsv(rgb_to_hsv(255, 255, 255), [0, 0, 1])
True
>>> approximately_equal_hsv(rgb_to_hsv(255, 0, 0), [0, 1, 1])
True
>>> approximately_equal_hsv(rgb_to_hsv(255, 255, 0), [60, 1, 1])
True
>>> approximately_equal_hsv(rgb_to_hsv(0, 255, 0), [120, 1, 1])
True
>>> approximately_equal_hsv(rgb_to_hsv(0, 0, 255), [240, 1, 1])
True
>>> approximately_equal_hsv(rgb_to_hsv(255, 0, 255), [300, 1, 1])
True
>>> approximately_equal_hsv(rgb_to_hsv(64, 128, 128), [180, 0.5, 0.5])
True
>>> approximately_equal_hsv(rgb_to_hsv(193, 196, 224), [234, 0.14, 0.88])
True
>>> approximately_equal_hsv(rgb_to_hsv(128, 32, 80), [330, 0.75, 0.5])
True
 - Function 'approximately_equal_hsv' takes 2 arguments: hsv_1, hsv_2.  Docstring: Utility-function to check that two hsv-colors are approximately equal

>>> approximately_equal_hsv([0, 0, 0], [0, 0, 0])
True
>>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.500001, 0.30001])
True
>>> approximately_equal_hsv([0, 0, 0], [1, 0, 0])
False
>>> approximately_equal_hsv([180, 0.5, 0.3], [179.9999, 0.6, 0.30001])
False

File: roman_numerals.py
 - Function 'roman_to_int' takes 1 arguments: roman.  Docstring: LeetCode No. 13 Roman to Integer
Given a roman numeral, convert it to an integer.
Input is guaranteed to be within the range from 1 to 3999.
https://en.wikipedia.org/wiki/Roman_numerals
>>> tests = {"III": 3, "CLIV": 154, "MIX": 1009, "MMD": 2500, "MMMCMXCIX": 3999}
>>> all(roman_to_int(key) == value for key, value in tests.items())
True
 - Function 'int_to_roman' takes 1 arguments: number.  Docstring: Given a integer, convert it to an roman numeral.
https://en.wikipedia.org/wiki/Roman_numerals
>>> tests = {"III": 3, "CLIV": 154, "MIX": 1009, "MMD": 2500, "MMMCMXCIX": 3999}
>>> all(int_to_roman(value) == key for key, value in tests.items())
True

File: speed_conversions.py
 - Function 'convert_speed' takes 3 arguments: speed, unit_from, unit_to.  Docstring: Convert speed from one unit to another using the speed_chart above.

"km/h": 1.0,
"m/s": 3.6,
"mph": 1.609344,
"knot": 1.852,

>>> convert_speed(100, "km/h", "m/s")
27.778
>>> convert_speed(100, "km/h", "mph")
62.137
>>> convert_speed(100, "km/h", "knot")
53.996
>>> convert_speed(100, "m/s", "km/h")
360.0
>>> convert_speed(100, "m/s", "mph")
223.694
>>> convert_speed(100, "m/s", "knot")
194.384
>>> convert_speed(100, "mph", "km/h")
160.934
>>> convert_speed(100, "mph", "m/s")
44.704
>>> convert_speed(100, "mph", "knot")
86.898
>>> convert_speed(100, "knot", "km/h")
185.2
>>> convert_speed(100, "knot", "m/s")
51.444
>>> convert_speed(100, "knot", "mph")
115.078

File: temperature_conversions.py
 - Function 'celsius_to_fahrenheit' takes 2 arguments: celsius, ndigits.  Docstring: Convert a given value from Celsius to Fahrenheit and round it to 2 decimal places.
Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit

>>> celsius_to_fahrenheit(273.354, 3)
524.037
>>> celsius_to_fahrenheit(273.354, 0)
524.0
>>> celsius_to_fahrenheit(-40.0)
-40.0
>>> celsius_to_fahrenheit(-20.0)
-4.0
>>> celsius_to_fahrenheit(0)
32.0
>>> celsius_to_fahrenheit(20)
68.0
>>> celsius_to_fahrenheit("40")
104.0
>>> celsius_to_fahrenheit("celsius")
Traceback (most recent call last):
    ...
ValueError: could not convert string to float: 'celsius'
 - Function 'celsius_to_kelvin' takes 2 arguments: celsius, ndigits.  Docstring: Convert a given value from Celsius to Kelvin and round it to 2 decimal places.
Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin

>>> celsius_to_kelvin(273.354, 3)
546.504
>>> celsius_to_kelvin(273.354, 0)
547.0
>>> celsius_to_kelvin(0)
273.15
>>> celsius_to_kelvin(20.0)
293.15
>>> celsius_to_kelvin("40")
313.15
>>> celsius_to_kelvin("celsius")
Traceback (most recent call last):
    ...
ValueError: could not convert string to float: 'celsius'
 - Function 'celsius_to_rankine' takes 2 arguments: celsius, ndigits.  Docstring: Convert a given value from Celsius to Rankine and round it to 2 decimal places.
Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale

>>> celsius_to_rankine(273.354, 3)
983.707
>>> celsius_to_rankine(273.354, 0)
984.0
>>> celsius_to_rankine(0)
491.67
>>> celsius_to_rankine(20.0)
527.67
>>> celsius_to_rankine("40")
563.67
>>> celsius_to_rankine("celsius")
Traceback (most recent call last):
    ...
ValueError: could not convert string to float: 'celsius'
 - Function 'fahrenheit_to_celsius' takes 2 arguments: fahrenheit, ndigits.  Docstring: Convert a given value from Fahrenheit to Celsius and round it to 2 decimal places.
Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
Wikipedia reference: https://en.wikipedia.org/wiki/Celsius

>>> fahrenheit_to_celsius(273.354, 3)
134.086
>>> fahrenheit_to_celsius(273.354, 0)
134.0
>>> fahrenheit_to_celsius(0)
-17.78
>>> fahrenheit_to_celsius(20.0)
-6.67
>>> fahrenheit_to_celsius(40.0)
4.44
>>> fahrenheit_to_celsius(60)
15.56
>>> fahrenheit_to_celsius(80)
26.67
>>> fahrenheit_to_celsius("100")
37.78
>>> fahrenheit_to_celsius("fahrenheit")
Traceback (most recent call last):
    ...
ValueError: could not convert string to float: 'fahrenheit'
 - Function 'fahrenheit_to_kelvin' takes 2 arguments: fahrenheit, ndigits.  Docstring: Convert a given value from Fahrenheit to Kelvin and round it to 2 decimal places.
Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin

>>> fahrenheit_to_kelvin(273.354, 3)
407.236
>>> fahrenheit_to_kelvin(273.354, 0)
407.0
>>> fahrenheit_to_kelvin(0)
255.37
>>> fahrenheit_to_kelvin(20.0)
266.48
>>> fahrenheit_to_kelvin(40.0)
277.59
>>> fahrenheit_to_kelvin(60)
288.71
>>> fahrenheit_to_kelvin(80)
299.82
>>> fahrenheit_to_kelvin("100")
310.93
>>> fahrenheit_to_kelvin("fahrenheit")
Traceback (most recent call last):
    ...
ValueError: could not convert string to float: 'fahrenheit'
 - Function 'fahrenheit_to_rankine' takes 2 arguments: fahrenheit, ndigits.  Docstring: Convert a given value from Fahrenheit to Rankine and round it to 2 decimal places.
Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale

>>> fahrenheit_to_rankine(273.354, 3)
733.024
>>> fahrenheit_to_rankine(273.354, 0)
733.0
>>> fahrenheit_to_rankine(0)
459.67
>>> fahrenheit_to_rankine(20.0)
479.67
>>> fahrenheit_to_rankine(40.0)
499.67
>>> fahrenheit_to_rankine(60)
519.67
>>> fahrenheit_to_rankine(80)
539.67
>>> fahrenheit_to_rankine("100")
559.67
>>> fahrenheit_to_rankine("fahrenheit")
Traceback (most recent call last):
    ...
ValueError: could not convert string to float: 'fahrenheit'
 - Function 'kelvin_to_celsius' takes 2 arguments: kelvin, ndigits.  Docstring: Convert a given value from Kelvin to Celsius and round it to 2 decimal places.
Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
Wikipedia reference: https://en.wikipedia.org/wiki/Celsius

>>> kelvin_to_celsius(273.354, 3)
0.204
>>> kelvin_to_celsius(273.354, 0)
0.0
>>> kelvin_to_celsius(273.15)
0.0
>>> kelvin_to_celsius(300)
26.85
>>> kelvin_to_celsius("315.5")
42.35
>>> kelvin_to_celsius("kelvin")
Traceback (most recent call last):
    ...
ValueError: could not convert string to float: 'kelvin'
 - Function 'kelvin_to_fahrenheit' takes 2 arguments: kelvin, ndigits.  Docstring: Convert a given value from Kelvin to Fahrenheit and round it to 2 decimal places.
Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit

>>> kelvin_to_fahrenheit(273.354, 3)
32.367
>>> kelvin_to_fahrenheit(273.354, 0)
32.0
>>> kelvin_to_fahrenheit(273.15)
32.0
>>> kelvin_to_fahrenheit(300)
80.33
>>> kelvin_to_fahrenheit("315.5")
108.23
>>> kelvin_to_fahrenheit("kelvin")
Traceback (most recent call last):
    ...
ValueError: could not convert string to float: 'kelvin'
 - Function 'kelvin_to_rankine' takes 2 arguments: kelvin, ndigits.  Docstring: Convert a given value from Kelvin to Rankine and round it to 2 decimal places.
Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale

>>> kelvin_to_rankine(273.354, 3)
492.037
>>> kelvin_to_rankine(273.354, 0)
492.0
>>> kelvin_to_rankine(0)
0.0
>>> kelvin_to_rankine(20.0)
36.0
>>> kelvin_to_rankine("40")
72.0
>>> kelvin_to_rankine("kelvin")
Traceback (most recent call last):
    ...
ValueError: could not convert string to float: 'kelvin'
 - Function 'rankine_to_celsius' takes 2 arguments: rankine, ndigits.  Docstring: Convert a given value from Rankine to Celsius and round it to 2 decimal places.
Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
Wikipedia reference: https://en.wikipedia.org/wiki/Celsius

>>> rankine_to_celsius(273.354, 3)
-121.287
>>> rankine_to_celsius(273.354, 0)
-121.0
>>> rankine_to_celsius(273.15)
-121.4
>>> rankine_to_celsius(300)
-106.48
>>> rankine_to_celsius("315.5")
-97.87
>>> rankine_to_celsius("rankine")
Traceback (most recent call last):
    ...
ValueError: could not convert string to float: 'rankine'
 - Function 'rankine_to_fahrenheit' takes 2 arguments: rankine, ndigits.  Docstring: Convert a given value from Rankine to Fahrenheit and round it to 2 decimal places.
Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit

>>> rankine_to_fahrenheit(273.15)
-186.52
>>> rankine_to_fahrenheit(300)
-159.67
>>> rankine_to_fahrenheit("315.5")
-144.17
>>> rankine_to_fahrenheit("rankine")
Traceback (most recent call last):
    ...
ValueError: could not convert string to float: 'rankine'
 - Function 'rankine_to_kelvin' takes 2 arguments: rankine, ndigits.  Docstring: Convert a given value from Rankine to Kelvin and round it to 2 decimal places.
Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin

>>> rankine_to_kelvin(0)
0.0
>>> rankine_to_kelvin(20.0)
11.11
>>> rankine_to_kelvin("40")
22.22
>>> rankine_to_kelvin("rankine")
Traceback (most recent call last):
    ...
ValueError: could not convert string to float: 'rankine'
 - Function 'reaumur_to_kelvin' takes 2 arguments: reaumur, ndigits.  Docstring: Convert a given value from reaumur to Kelvin and round it to 2 decimal places.
Reference:- http://www.csgnetwork.com/temp2conv.html

>>> reaumur_to_kelvin(0)
273.15
>>> reaumur_to_kelvin(20.0)
298.15
>>> reaumur_to_kelvin(40)
323.15
>>> reaumur_to_kelvin("reaumur")
Traceback (most recent call last):
    ...
ValueError: could not convert string to float: 'reaumur'
 - Function 'reaumur_to_fahrenheit' takes 2 arguments: reaumur, ndigits.  Docstring: Convert a given value from reaumur to fahrenheit and round it to 2 decimal places.
Reference:- http://www.csgnetwork.com/temp2conv.html

>>> reaumur_to_fahrenheit(0)
32.0
>>> reaumur_to_fahrenheit(20.0)
77.0
>>> reaumur_to_fahrenheit(40)
122.0
>>> reaumur_to_fahrenheit("reaumur")
Traceback (most recent call last):
    ...
ValueError: could not convert string to float: 'reaumur'
 - Function 'reaumur_to_celsius' takes 2 arguments: reaumur, ndigits.  Docstring: Convert a given value from reaumur to celsius and round it to 2 decimal places.
Reference:- http://www.csgnetwork.com/temp2conv.html

>>> reaumur_to_celsius(0)
0.0
>>> reaumur_to_celsius(20.0)
25.0
>>> reaumur_to_celsius(40)
50.0
>>> reaumur_to_celsius("reaumur")
Traceback (most recent call last):
    ...
ValueError: could not convert string to float: 'reaumur'
 - Function 'reaumur_to_rankine' takes 2 arguments: reaumur, ndigits.  Docstring: Convert a given value from reaumur to rankine and round it to 2 decimal places.
Reference:- http://www.csgnetwork.com/temp2conv.html

>>> reaumur_to_rankine(0)
491.67
>>> reaumur_to_rankine(20.0)
536.67
>>> reaumur_to_rankine(40)
581.67
>>> reaumur_to_rankine("reaumur")
Traceback (most recent call last):
    ...
ValueError: could not convert string to float: 'reaumur'

File: time_conversions.py
 - Function 'convert_time' takes 3 arguments: time_value, unit_from, unit_to.  Docstring: Convert time from one unit to another using the time_chart above.

>>> convert_time(3600, "seconds", "hours")
1.0
>>> convert_time(3500, "Seconds", "Hours")
0.972
>>> convert_time(1, "DaYs", "hours")
24.0
>>> convert_time(120, "minutes", "SeCoNdS")
7200.0
>>> convert_time(2, "WEEKS", "days")
14.0
>>> convert_time(0.5, "hours", "MINUTES")
30.0
>>> convert_time(-3600, "seconds", "hours")
Traceback (most recent call last):
    ...
ValueError: 'time_value' must be a non-negative number.
>>> convert_time("Hello", "hours", "minutes")
Traceback (most recent call last):
    ...
ValueError: 'time_value' must be a non-negative number.
>>> convert_time([0, 1, 2], "weeks", "days")
Traceback (most recent call last):
    ...
ValueError: 'time_value' must be a non-negative number.
>>> convert_time(1, "cool", "century")  # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
ValueError: Invalid unit cool is not in seconds, minutes, hours, days, weeks, ...
>>> convert_time(1, "seconds", "hot")  # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
ValueError: Invalid unit hot is not in seconds, minutes, hours, days, weeks, ...

File: volume_conversions.py
 - Function 'volume_conversion' takes 3 arguments: value, from_type, to_type.  Docstring: Conversion between volume units.
>>> volume_conversion(4, "cubic meter", "litre")
4000
>>> volume_conversion(1, "litre", "gallon")
0.264172
>>> volume_conversion(1, "kilolitre", "cubic meter")
1
>>> volume_conversion(3, "gallon", "cubic yard")
0.017814279
>>> volume_conversion(2, "cubic yard", "litre")
1529.1
>>> volume_conversion(4, "cubic foot", "cup")
473.396
>>> volume_conversion(1, "cup", "kilolitre")
0.000236588
>>> volume_conversion(4, "wrongUnit", "litre")
Traceback (most recent call last):
    ...
ValueError: Invalid 'from_type' value: 'wrongUnit'  Supported values are:
cubic meter, litre, kilolitre, gallon, cubic yard, cubic foot, cup

File: weight_conversion.py
 - Function 'weight_conversion' takes 3 arguments: from_type, to_type, value.  Docstring: Conversion of weight unit with the help of KILOGRAM_CHART

"kilogram" : 1,
"gram" : pow(10, 3),
"milligram" : pow(10, 6),
"metric-ton" : pow(10, -3),
"long-ton" : 0.0009842073,
"short-ton" : 0.0011023122,
"pound" : 2.2046244202,
"stone": 0.1574731728,
"ounce" : 35.273990723,
"carrat" : 5000,
"atomic-mass-unit" : 6.022136652E+26

>>> weight_conversion("kilogram","kilogram",4)
4
>>> weight_conversion("kilogram","gram",1)
1000
>>> weight_conversion("kilogram","milligram",4)
4000000
>>> weight_conversion("kilogram","metric-ton",4)
0.004
>>> weight_conversion("kilogram","long-ton",3)
0.0029526219
>>> weight_conversion("kilogram","short-ton",1)
0.0011023122
>>> weight_conversion("kilogram","pound",4)
8.8184976808
>>> weight_conversion("kilogram","stone",5)
0.7873658640000001
>>> weight_conversion("kilogram","ounce",4)
141.095962892
>>> weight_conversion("kilogram","carrat",3)
15000
>>> weight_conversion("kilogram","atomic-mass-unit",1)
6.022136652e+26
>>> weight_conversion("gram","kilogram",1)
0.001
>>> weight_conversion("gram","gram",3)
3.0
>>> weight_conversion("gram","milligram",2)
2000.0
>>> weight_conversion("gram","metric-ton",4)
4e-06
>>> weight_conversion("gram","long-ton",3)
2.9526219e-06
>>> weight_conversion("gram","short-ton",3)
3.3069366000000003e-06
>>> weight_conversion("gram","pound",3)
0.0066138732606
>>> weight_conversion("gram","stone",4)
0.0006298926912000001
>>> weight_conversion("gram","ounce",1)
0.035273990723
>>> weight_conversion("gram","carrat",2)
10.0
>>> weight_conversion("gram","atomic-mass-unit",1)
6.022136652e+23
>>> weight_conversion("milligram","kilogram",1)
1e-06
>>> weight_conversion("milligram","gram",2)
0.002
>>> weight_conversion("milligram","milligram",3)
3.0
>>> weight_conversion("milligram","metric-ton",3)
3e-09
>>> weight_conversion("milligram","long-ton",3)
2.9526219e-09
>>> weight_conversion("milligram","short-ton",1)
1.1023122e-09
>>> weight_conversion("milligram","pound",3)
6.6138732605999995e-06
>>> weight_conversion("milligram","ounce",2)
7.054798144599999e-05
>>> weight_conversion("milligram","carrat",1)
0.005
>>> weight_conversion("milligram","atomic-mass-unit",1)
6.022136652e+20
>>> weight_conversion("metric-ton","kilogram",2)
2000
>>> weight_conversion("metric-ton","gram",2)
2000000
>>> weight_conversion("metric-ton","milligram",3)
3000000000
>>> weight_conversion("metric-ton","metric-ton",2)
2.0
>>> weight_conversion("metric-ton","long-ton",3)
2.9526219
>>> weight_conversion("metric-ton","short-ton",2)
2.2046244
>>> weight_conversion("metric-ton","pound",3)
6613.8732606
>>> weight_conversion("metric-ton","ounce",4)
141095.96289199998
>>> weight_conversion("metric-ton","carrat",4)
20000000
>>> weight_conversion("metric-ton","atomic-mass-unit",1)
6.022136652e+29
>>> weight_conversion("long-ton","kilogram",4)
4064.18432
>>> weight_conversion("long-ton","gram",4)
4064184.32
>>> weight_conversion("long-ton","milligram",3)
3048138240.0
>>> weight_conversion("long-ton","metric-ton",4)
4.06418432
>>> weight_conversion("long-ton","long-ton",3)
2.999999907217152
>>> weight_conversion("long-ton","short-ton",1)
1.119999989746176
>>> weight_conversion("long-ton","pound",3)
6720.000000049448
>>> weight_conversion("long-ton","ounce",1)
35840.000000060514
>>> weight_conversion("long-ton","carrat",4)
20320921.599999998
>>> weight_conversion("long-ton","atomic-mass-unit",4)
2.4475073353955697e+30
>>> weight_conversion("short-ton","kilogram",3)
2721.5519999999997
>>> weight_conversion("short-ton","gram",3)
2721552.0
>>> weight_conversion("short-ton","milligram",1)
907184000.0
>>> weight_conversion("short-ton","metric-ton",4)
3.628736
>>> weight_conversion("short-ton","long-ton",3)
2.6785713457296
>>> weight_conversion("short-ton","short-ton",3)
2.9999999725344
>>> weight_conversion("short-ton","pound",2)
4000.0000000294335
>>> weight_conversion("short-ton","ounce",4)
128000.00000021611
>>> weight_conversion("short-ton","carrat",4)
18143680.0
>>> weight_conversion("short-ton","atomic-mass-unit",1)
5.463186016507968e+29
>>> weight_conversion("pound","kilogram",4)
1.814368
>>> weight_conversion("pound","gram",2)
907.184
>>> weight_conversion("pound","milligram",3)
1360776.0
>>> weight_conversion("pound","metric-ton",3)
0.001360776
>>> weight_conversion("pound","long-ton",2)
0.0008928571152432
>>> weight_conversion("pound","short-ton",1)
0.0004999999954224
>>> weight_conversion("pound","pound",3)
3.0000000000220752
>>> weight_conversion("pound","ounce",1)
16.000000000027015
>>> weight_conversion("pound","carrat",1)
2267.96
>>> weight_conversion("pound","atomic-mass-unit",4)
1.0926372033015936e+27
>>> weight_conversion("stone","kilogram",5)
31.751450000000002
>>> weight_conversion("stone","gram",2)
12700.58
>>> weight_conversion("stone","milligram",3)
19050870.0
>>> weight_conversion("stone","metric-ton",3)
0.01905087
>>> weight_conversion("stone","long-ton",3)
0.018750005325351003
>>> weight_conversion("stone","short-ton",3)
0.021000006421614002
>>> weight_conversion("stone","pound",2)
28.00000881870372
>>> weight_conversion("stone","ounce",1)
224.00007054835967
>>> weight_conversion("stone","carrat",2)
63502.9
>>> weight_conversion("ounce","kilogram",3)
0.0850485
>>> weight_conversion("ounce","gram",3)
85.0485
>>> weight_conversion("ounce","milligram",4)
113398.0
>>> weight_conversion("ounce","metric-ton",4)
0.000113398
>>> weight_conversion("ounce","long-ton",4)
0.0001116071394054
>>> weight_conversion("ounce","short-ton",4)
0.0001249999988556
>>> weight_conversion("ounce","pound",1)
0.0625000000004599
>>> weight_conversion("ounce","ounce",2)
2.000000000003377
>>> weight_conversion("ounce","carrat",1)
141.7475
>>> weight_conversion("ounce","atomic-mass-unit",1)
1.70724563015874e+25
>>> weight_conversion("carrat","kilogram",1)
0.0002
>>> weight_conversion("carrat","gram",4)
0.8
>>> weight_conversion("carrat","milligram",2)
400.0
>>> weight_conversion("carrat","metric-ton",2)
4.0000000000000003e-07
>>> weight_conversion("carrat","long-ton",3)
5.9052438e-07
>>> weight_conversion("carrat","short-ton",4)
8.818497600000002e-07
>>> weight_conversion("carrat","pound",1)
0.00044092488404000004
>>> weight_conversion("carrat","ounce",2)
0.0141095962892
>>> weight_conversion("carrat","carrat",4)
4.0
>>> weight_conversion("carrat","atomic-mass-unit",4)
4.8177093216e+23
>>> weight_conversion("atomic-mass-unit","kilogram",4)
6.642160796e-27
>>> weight_conversion("atomic-mass-unit","gram",2)
3.321080398e-24
>>> weight_conversion("atomic-mass-unit","milligram",2)
3.3210803980000002e-21
>>> weight_conversion("atomic-mass-unit","metric-ton",3)
4.9816205970000004e-30
>>> weight_conversion("atomic-mass-unit","long-ton",3)
4.9029473573977584e-30
>>> weight_conversion("atomic-mass-unit","short-ton",1)
1.830433719948128e-30
>>> weight_conversion("atomic-mass-unit","pound",3)
1.0982602420317504e-26
>>> weight_conversion("atomic-mass-unit","ounce",2)
1.1714775914938915e-25
>>> weight_conversion("atomic-mass-unit","carrat",2)
1.660540199e-23
>>> weight_conversion("atomic-mass-unit","atomic-mass-unit",2)
1.999999998903455
>>> weight_conversion("slug", "kilogram", 1)
Traceback (most recent call last):
...
ValueError: Invalid 'from_type' or 'to_type' value: 'slug', 'kilogram'
Supported values are: kilogram, gram, milligram, metric-ton, long-ton, short-ton, pound, stone, ounce, carrat, atomic-mass-unit

File: equilibrium_index_in_array.py
 - Function 'equilibrium_index' takes 1 arguments: arr.  Docstring: Find the equilibrium index of an array.

Args:
    arr (list[int]): The input array of integers.

Returns:
    int: The equilibrium index or -1 if no equilibrium index exists.

Examples:
    >>> equilibrium_index([-7, 1, 5, 2, -4, 3, 0])
    3
    >>> equilibrium_index([1, 2, 3, 4, 5])
    -1
    >>> equilibrium_index([1, 1, 1, 1, 1])
    2
    >>> equilibrium_index([2, 4, 6, 8, 10, 3])
    -1

File: find_triplets_with_0_sum.py
 - Function 'find_triplets_with_0_sum' takes 1 arguments: nums.  Docstring: Given a list of integers, return elements a, b, c such that a + b + c = 0.
Args:
    nums: list of integers
Returns:
    list of lists of integers where sum(each_list) == 0
Examples:
    >>> find_triplets_with_0_sum([-1, 0, 1, 2, -1, -4])
    [[-1, -1, 2], [-1, 0, 1]]
    >>> find_triplets_with_0_sum([])
    []
    >>> find_triplets_with_0_sum([0, 0, 0])
    [[0, 0, 0]]
    >>> find_triplets_with_0_sum([1, 2, 3, 0, -1, -2, -3])
    [[-3, 0, 3], [-3, 1, 2], [-2, -1, 3], [-2, 0, 2], [-1, 0, 1]]
 - Function 'find_triplets_with_0_sum_hashing' takes 1 arguments: arr.  Docstring: Function for finding the triplets with a given sum in the array using hashing.

Given a list of integers, return elements a, b, c such that a + b + c = 0.

Args:
    nums: list of integers
Returns:
    list of lists of integers where sum(each_list) == 0
Examples:
    >>> find_triplets_with_0_sum_hashing([-1, 0, 1, 2, -1, -4])
    [[-1, 0, 1], [-1, -1, 2]]
    >>> find_triplets_with_0_sum_hashing([])
    []
    >>> find_triplets_with_0_sum_hashing([0, 0, 0])
    [[0, 0, 0]]
    >>> find_triplets_with_0_sum_hashing([1, 2, 3, 0, -1, -2, -3])
    [[-1, 0, 1], [-3, 1, 2], [-2, 0, 2], [-2, -1, 3], [-3, 0, 3]]

Time complexity: O(N^2)
Auxiliary Space: O(N)

File: index_2d_array_in_1d.py
 - Function '__iter__' takes 1 arguments: self.  Docstring: >>> tuple(Index2DArrayIterator([[5], [-523], [-1], [34], [0]]))
(5, -523, -1, 34, 0)
>>> tuple(Index2DArrayIterator([[5, -523, -1], [34, 0]]))
(5, -523, -1, 34, 0)
>>> tuple(Index2DArrayIterator([[5, -523, -1, 34, 0]]))
(5, -523, -1, 34, 0)
>>> t = Index2DArrayIterator([[5, 2, 25], [23, 14, 5], [324, -1, 0]])
>>> tuple(t)
(5, 2, 25, 23, 14, 5, 324, -1, 0)
>>> list(t)
[5, 2, 25, 23, 14, 5, 324, -1, 0]
>>> sorted(t)
[-1, 0, 2, 5, 5, 14, 23, 25, 324]
>>> tuple(t)[3]
23
>>> sum(t)
397
>>> -1 in t
True
>>> t = iter(Index2DArrayIterator([[5], [-523], [-1], [34], [0]]))
>>> next(t)
5
>>> next(t)
-523
 - Function 'index_2d_array_in_1d' takes 2 arguments: array, index.  Docstring: Retrieves the value of the one-dimensional index from a two-dimensional array.

Args:
    array: A 2D array of integers where all rows are the same size and all
           columns are the same size.
    index: A 1D index.

Returns:
    int: The 0-indexed value of the 1D index in the array.

Examples:
>>> index_2d_array_in_1d([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], 5)
5
>>> index_2d_array_in_1d([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], -1)
Traceback (most recent call last):
    ...
ValueError: index out of range
>>> index_2d_array_in_1d([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], 12)
Traceback (most recent call last):
    ...
ValueError: index out of range
>>> index_2d_array_in_1d([[]], 0)
Traceback (most recent call last):
    ...
ValueError: no items in array

File: kth_largest_element.py
 - Function 'partition' takes 3 arguments: arr, low, high.  Docstring: Partitions list based on the pivot element.

This function rearranges the elements in the input list 'elements' such that
all elements greater than or equal to the chosen pivot are on the right side
of the pivot, and all elements smaller than the pivot are on the left side.

Args:
    arr: The list to be partitioned
    low: The lower index of the list
    high: The higher index of the list

Returns:
    int: The index of pivot element after partitioning

    Examples:
    >>> partition([3, 1, 4, 5, 9, 2, 6, 5, 3, 5], 0, 9)
    4
    >>> partition([7, 1, 4, 5, 9, 2, 6, 5, 8], 0, 8)
    1
    >>> partition(['apple', 'cherry', 'date', 'banana'], 0, 3)
    2
    >>> partition([3.1, 1.2, 5.6, 4.7], 0, 3)
    1
 - Function 'kth_largest_element' takes 2 arguments: arr, position.  Docstring: Finds the kth largest element in a list.
Should deliver similar results to:
```python
def kth_largest_element(arr, position):
    return sorted(arr)[-position]
```

Args:
    nums: The list of numbers.
    k: The position of the desired kth largest element.

Returns:
    int: The kth largest element.

Examples:
    >>> kth_largest_element([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 3)
    5
    >>> kth_largest_element([2, 5, 6, 1, 9, 3, 8, 4, 7, 3, 5], 1)
    9
    >>> kth_largest_element([2, 5, 6, 1, 9, 3, 8, 4, 7, 3, 5], -2)
    Traceback (most recent call last):
    ...
    ValueError: Invalid value of 'position'
    >>> kth_largest_element([9, 1, 3, 6, 7, 9, 8, 4, 2, 4, 9], 110)
    Traceback (most recent call last):
    ...
    ValueError: Invalid value of 'position'
    >>> kth_largest_element([1, 2, 4, 3, 5, 9, 7, 6, 5, 9, 3], 0)
    Traceback (most recent call last):
    ...
    ValueError: Invalid value of 'position'
    >>> kth_largest_element(['apple', 'cherry', 'date', 'banana'], 2)
    'cherry'
    >>> kth_largest_element([3.1, 1.2, 5.6, 4.7,7.9,5,0], 2)
    5.6
    >>> kth_largest_element([-2, -5, -4, -1], 1)
    -1
    >>> kth_largest_element([], 1)
    -1
    >>> kth_largest_element([3.1, 1.2, 5.6, 4.7, 7.9, 5, 0], 1.5)
    Traceback (most recent call last):
    ...
    ValueError: The position should be an integer
    >>> kth_largest_element((4, 6, 1, 2), 4)
    Traceback (most recent call last):
    ...
    TypeError: 'tuple' object does not support item assignment

File: median_two_array.py
 - Function 'find_median_sorted_arrays' takes 2 arguments: nums1, nums2.  Docstring: Find the median of two arrays.

Args:
    nums1: The first array.
    nums2: The second array.

Returns:
The median of the two arrays.

Examples:
    >>> find_median_sorted_arrays([1, 3], [2])
    2.0

    >>> find_median_sorted_arrays([1, 2], [3, 4])
    2.5

    >>> find_median_sorted_arrays([0, 0], [0, 0])
    0.0

    >>> find_median_sorted_arrays([], [])
    Traceback (most recent call last):
        ...
    ValueError: Both input arrays are empty.

    >>> find_median_sorted_arrays([], [1])
    1.0

    >>> find_median_sorted_arrays([-1000], [1000])
    0.0

    >>> find_median_sorted_arrays([-1.1, -2.2], [-3.3, -4.4])
    -2.75

File: monotonic_array.py
 - Function 'is_monotonic' takes 1 arguments: nums.  Docstring: Check if a list is monotonic.

>>> is_monotonic([1, 2, 2, 3])
True
>>> is_monotonic([6, 5, 4, 4])
True
>>> is_monotonic([1, 3, 2])
False

File: pairs_with_given_sum.py
 - Function 'pairs_with_sum' takes 2 arguments: arr, req_sum.  Docstring: Return the no. of pairs with sum "sum"
>>> pairs_with_sum([1, 5, 7, 1], 6)
2
>>> pairs_with_sum([1, 1, 1, 1, 1, 1, 1, 1], 2)
28
>>> pairs_with_sum([1, 7, 6, 2, 5, 4, 3, 1, 9, 8], 7)
4

File: permutations.py
 - Function 'permute_recursive' takes 1 arguments: nums.  Docstring: Return all permutations.

>>> permute_recursive([1, 2, 3])
[[3, 2, 1], [2, 3, 1], [1, 3, 2], [3, 1, 2], [2, 1, 3], [1, 2, 3]]
 - Function 'permute_backtrack' takes 1 arguments: nums.  Docstring: Return all permutations of the given list.

>>> permute_backtrack([1, 2, 3])
[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]
 - Function 'backtrack' takes 1 arguments: start.  No docstring available.

File: prefix_sum.py
 - Function '__init__' takes 2 arguments: self, array.  No docstring available.
 - Function 'get_sum' takes 3 arguments: self, start, end.  Docstring: The function returns the sum of array from the start to the end indexes.
Runtime : O(1)
Space: O(1)

>>> PrefixSum([1,2,3]).get_sum(0, 2)
6
>>> PrefixSum([1,2,3]).get_sum(1, 2)
5
>>> PrefixSum([1,2,3]).get_sum(2, 2)
3
>>> PrefixSum([1,2,3]).get_sum(2, 3)
Traceback (most recent call last):
...
IndexError: list index out of range
 - Function 'contains_sum' takes 2 arguments: self, target_sum.  Docstring: The function returns True if array contains the target_sum,
False otherwise.

Runtime : O(n)
Space: O(n)

>>> PrefixSum([1,2,3]).contains_sum(6)
True
>>> PrefixSum([1,2,3]).contains_sum(5)
True
>>> PrefixSum([1,2,3]).contains_sum(3)
True
>>> PrefixSum([1,2,3]).contains_sum(4)
False
>>> PrefixSum([1,2,3]).contains_sum(7)
False
>>> PrefixSum([1,-2,3]).contains_sum(2)
True

File: product_sum.py
 - Function 'product_sum' takes 2 arguments: arr, depth.  Docstring: Recursively calculates the product sum of an array.

The product sum of an array is defined as the sum of its elements multiplied by
their respective depths.  If an element is a list, its product sum is calculated
recursively by multiplying the sum of its elements with its depth plus one.

Args:
    arr: The array of integers and nested lists.
    depth: The current depth level.

Returns:
    int: The product sum of the array.

Examples:
    >>> product_sum([1, 2, 3], 1)
    6
    >>> product_sum([-1, 2, [-3, 4]], 2)
    8
    >>> product_sum([1, 2, 3], -1)
    -6
    >>> product_sum([1, 2, 3], 0)
    0
    >>> product_sum([1, 2, 3], 7)
    42
    >>> product_sum((1, 2, 3), 7)
    42
    >>> product_sum({1, 2, 3}, 7)
    42
    >>> product_sum([1, -1], 1)
    0
    >>> product_sum([1, -2], 1)
    -1
    >>> product_sum([-3.5, [1, [0.5]]], 1)
    1.5
 - Function 'product_sum_array' takes 1 arguments: array.  Docstring: Calculates the product sum of an array.

Args:
    array (List[Union[int, List]]): The array of integers and nested lists.

Returns:
    int: The product sum of the array.

Examples:
    >>> product_sum_array([1, 2, 3])
    6
    >>> product_sum_array([1, [2, 3]])
    11
    >>> product_sum_array([1, [2, [3, 4]]])
    47
    >>> product_sum_array([0])
    0
    >>> product_sum_array([-3.5, [1, [0.5]]])
    1.5
    >>> product_sum_array([1, -2])
    -1

File: sparse_table.py
 - Function 'build_sparse_table' takes 1 arguments: number_list.  Docstring: Precompute range minimum queries with power of two length and store the precomputed
values in a table.

>>> build_sparse_table([8, 1, 0, 3, 4, 9, 3])
[[8, 1, 0, 3, 4, 9, 3], [1, 0, 0, 3, 4, 3, 0], [0, 0, 0, 3, 0, 0, 0]]
>>> build_sparse_table([3, 1, 9])
[[3, 1, 9], [1, 1, 0]]
>>> build_sparse_table([])
Traceback (most recent call last):
...
ValueError: empty number list not allowed
 - Function 'query' takes 3 arguments: sparse_table, left_bound, right_bound.  Docstring: >>> query(build_sparse_table([8, 1, 0, 3, 4, 9, 3]), 0, 4)
0
>>> query(build_sparse_table([8, 1, 0, 3, 4, 9, 3]), 4, 6)
3
>>> query(build_sparse_table([3, 1, 9]), 2, 2)
9
>>> query(build_sparse_table([3, 1, 9]), 0, 1)
1
>>> query(build_sparse_table([8, 1, 0, 3, 4, 9, 3]), 0, 11)
Traceback (most recent call last):
...
IndexError: list index out of range
>>> query(build_sparse_table([]), 0, 0)
Traceback (most recent call last):
...
ValueError: empty number list not allowed

File: sudoku_solver.py
 - Function 'cross' takes 2 arguments: items_a, items_b.  Docstring: Cross product of elements in A and elements in B.
 - Function 'test' takes 0 arguments: .  Docstring: A set of unit tests.
 - Function 'parse_grid' takes 1 arguments: grid.  Docstring: Convert grid to a dict of possible values, {square: digits}, or
return False if a contradiction is detected.
 - Function 'grid_values' takes 1 arguments: grid.  Docstring: Convert grid into a dict of {square: char} with '0' or '.' for empties.
 - Function 'assign' takes 3 arguments: values, s, d.  Docstring: Eliminate all the other values (except d) from values[s] and propagate.
Return values, except return False if a contradiction is detected.
 - Function 'eliminate' takes 3 arguments: values, s, d.  Docstring: Eliminate d from values[s]; propagate when values or places <= 2.
Return values, except return False if a contradiction is detected.
 - Function 'display' takes 1 arguments: values.  Docstring: Display these values as a 2-D grid.
 - Function 'solve' takes 1 arguments: grid.  No docstring available.
 - Function 'some' takes 1 arguments: seq.  Docstring: Return some element of seq that is true.
 - Function 'search' takes 1 arguments: values.  Docstring: Using depth-first search and propagation, try all possible values.
 - Function 'solve_all' takes 3 arguments: grids, name, showif.  Docstring: Attempt to solve a sequence of grids. Report results.
When showif is a number of seconds, display puzzles that take longer.
When showif is None, don't display any puzzles.
 - Function 'time_solve' takes 1 arguments: grid.  No docstring available.
 - Function 'solved' takes 1 arguments: values.  Docstring: A puzzle is solved if each unit is a permutation of the digits 1 to 9.
 - Function 'unitsolved' takes 1 arguments: unit.  No docstring available.
 - Function 'from_file' takes 2 arguments: filename, sep.  Docstring: Parse a file into a list of strings, separated by sep.
 - Function 'random_puzzle' takes 1 arguments: assignments.  Docstring: Make a random puzzle with N or more assignments. Restart on contradictions.
Note the resulting puzzle is not guaranteed to be solvable, but empirically
about 99.8% of them are solvable. Some have multiple solutions.
 - Function 'shuffled' takes 1 arguments: seq.  Docstring: Return a randomly shuffled copy of the input sequence.

File: avl_tree.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'is_empty' takes 1 arguments: self.  No docstring available.
 - Function 'push' takes 2 arguments: self, data.  No docstring available.
 - Function 'pop' takes 1 arguments: self.  No docstring available.
 - Function 'count' takes 1 arguments: self.  No docstring available.
 - Function 'print_queue' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 2 arguments: self, data.  No docstring available.
 - Function 'get_data' takes 1 arguments: self.  No docstring available.
 - Function 'get_left' takes 1 arguments: self.  No docstring available.
 - Function 'get_right' takes 1 arguments: self.  No docstring available.
 - Function 'get_height' takes 1 arguments: self.  No docstring available.
 - Function 'set_data' takes 2 arguments: self, data.  No docstring available.
 - Function 'set_left' takes 2 arguments: self, node.  No docstring available.
 - Function 'set_right' takes 2 arguments: self, node.  No docstring available.
 - Function 'set_height' takes 2 arguments: self, height.  No docstring available.
 - Function 'get_height' takes 1 arguments: node.  No docstring available.
 - Function 'my_max' takes 2 arguments: a, b.  No docstring available.
 - Function 'right_rotation' takes 1 arguments: node.  Docstring:         A                      B
       / \                    / \
      B   C                  Bl  A
     / \       -->          /   / \
    Bl  Br                 UB Br  C
   /
 UB
UB = unbalanced node
 - Function 'left_rotation' takes 1 arguments: node.  Docstring: a mirror symmetry rotation of the left_rotation
 - Function 'lr_rotation' takes 1 arguments: node.  Docstring:         A              A                    Br
       / \            / \                  /  \
      B   C    LR    Br  C       RR       B    A
     / \       -->  /  \         -->    /     / \
    Bl  Br         B   UB              Bl    UB  C
         \        /
         UB     Bl
RR = right_rotation   LR = left_rotation
 - Function 'rl_rotation' takes 1 arguments: node.  No docstring available.
 - Function 'insert_node' takes 2 arguments: node, data.  No docstring available.
 - Function 'get_right_most' takes 1 arguments: root.  No docstring available.
 - Function 'get_left_most' takes 1 arguments: root.  No docstring available.
 - Function 'del_node' takes 2 arguments: root, data.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'get_height' takes 1 arguments: self.  No docstring available.
 - Function 'insert' takes 2 arguments: self, data.  No docstring available.
 - Function 'del_node' takes 2 arguments: self, data.  No docstring available.
 - Function '__str__' takes 1 arguments: self.  No docstring available.
 - Function '_test' takes 0 arguments: .  No docstring available.

File: basic_binary_tree.py
 - Function '__iter__' takes 1 arguments: self.  No docstring available.
 - Function '__len__' takes 1 arguments: self.  No docstring available.
 - Function 'is_full' takes 1 arguments: self.  No docstring available.
 - Function '__iter__' takes 1 arguments: self.  No docstring available.
 - Function '__len__' takes 1 arguments: self.  No docstring available.
 - Function 'small_tree' takes 1 arguments: cls.  Docstring: Return a small binary tree with 3 nodes.
>>> binary_tree = BinaryTree.small_tree()
>>> len(binary_tree)
3
>>> list(binary_tree)
[1, 2, 3]
 - Function 'medium_tree' takes 1 arguments: cls.  Docstring: Return a medium binary tree with 3 nodes.
>>> binary_tree = BinaryTree.medium_tree()
>>> len(binary_tree)
7
>>> list(binary_tree)
[1, 2, 3, 4, 5, 6, 7]
 - Function 'depth' takes 1 arguments: self.  Docstring: Returns the depth of the tree

>>> BinaryTree(Node(1)).depth()
1
>>> BinaryTree.small_tree().depth()
2
>>> BinaryTree.medium_tree().depth()
4
 - Function '_depth' takes 2 arguments: self, node.  No docstring available.
 - Function 'is_full' takes 1 arguments: self.  Docstring: Returns True if the tree is full

>>> BinaryTree(Node(1)).is_full()
True
>>> BinaryTree.small_tree().is_full()
True
>>> BinaryTree.medium_tree().is_full()
False

File: binary_search_tree.py
 - Function '__iter__' takes 1 arguments: self.  Docstring: >>> list(Node(0))
[0]
>>> list(Node(0, Node(-1), Node(1), None))
[-1, 0, 1]
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function 'is_right' takes 1 arguments: self.  No docstring available.
 - Function '__bool__' takes 1 arguments: self.  No docstring available.
 - Function '__iter__' takes 1 arguments: self.  No docstring available.
 - Function '__str__' takes 1 arguments: self.  Docstring: Return a string of all the Nodes using in order traversal
 - Function '__reassign_nodes' takes 3 arguments: self, node, new_children.  No docstring available.
 - Function 'empty' takes 1 arguments: self.  Docstring: Returns True if the tree does not have any element(s).
False if the tree has element(s).

>>> BinarySearchTree().empty()
True
>>> BinarySearchTree().insert(1).empty()
False
>>> BinarySearchTree().insert(8, 3, 6, 1, 10, 14, 13, 4, 7).empty()
False
 - Function '__insert' takes 2 arguments: self, value.  Docstring: Insert a new node in Binary Search Tree with value label
 - Function 'insert' takes 1 arguments: self.  No docstring available.
 - Function 'search' takes 2 arguments: self, value.  Docstring: >>> tree = BinarySearchTree().insert(10, 20, 30, 40, 50)
>>> tree.search(10)
{'10': (None, {'20': (None, {'30': (None, {'40': (None, 50)})})})}
>>> tree.search(20)
{'20': (None, {'30': (None, {'40': (None, 50)})})}
>>> tree.search(30)
{'30': (None, {'40': (None, 50)})}
>>> tree.search(40)
{'40': (None, 50)}
>>> tree.search(50)
50
>>> tree.search(5) is None  # element not present
True
>>> tree.search(0) is None  # element not present
True
>>> tree.search(-5) is None  # element not present
True
>>> BinarySearchTree().search(10)
Traceback (most recent call last):
    ...
IndexError: Warning: Tree is empty! please use another.
 - Function 'get_max' takes 2 arguments: self, node.  Docstring: We go deep on the right branch

>>> BinarySearchTree().insert(10, 20, 30, 40, 50).get_max()
50
>>> BinarySearchTree().insert(-5, -1, 0.1, -0.3, -4.5).get_max()
{'0.1': (-0.3, None)}
>>> BinarySearchTree().insert(1, 78.3, 30, 74.0, 1).get_max()
{'78.3': ({'30': (1, 74.0)}, None)}
>>> BinarySearchTree().insert(1, 783, 30, 740, 1).get_max()
{'783': ({'30': (1, 740)}, None)}
 - Function 'get_min' takes 2 arguments: self, node.  Docstring: We go deep on the left branch

>>> BinarySearchTree().insert(10, 20, 30, 40, 50).get_min()
{'10': (None, {'20': (None, {'30': (None, {'40': (None, 50)})})})}
>>> BinarySearchTree().insert(-5, -1, 0, -0.3, -4.5).get_min()
{'-5': (None, {'-1': (-4.5, {'0': (-0.3, None)})})}
>>> BinarySearchTree().insert(1, 78.3, 30, 74.0, 1).get_min()
{'1': (None, {'78.3': ({'30': (1, 74.0)}, None)})}
>>> BinarySearchTree().insert(1, 783, 30, 740, 1).get_min()
{'1': (None, {'783': ({'30': (1, 740)}, None)})}
 - Function 'remove' takes 2 arguments: self, value.  No docstring available.
 - Function 'preorder_traverse' takes 2 arguments: self, node.  No docstring available.
 - Function 'traversal_tree' takes 2 arguments: self, traversal_function.  Docstring: This function traversal the tree.
You can pass a function to traversal the tree as needed by client code
 - Function 'inorder' takes 3 arguments: self, arr, node.  Docstring: Perform an inorder traversal and append values of the nodes to
a list named arr
 - Function 'find_kth_smallest' takes 3 arguments: self, k, node.  Docstring: Return the kth smallest element in a binary search tree
 - Function 'inorder' takes 1 arguments: curr_node.  Docstring: inorder (left, self, right)
 - Function 'postorder' takes 1 arguments: curr_node.  Docstring: postOrder (left, right, self)

File: binary_search_tree_recursive.py
 - Function '__init__' takes 3 arguments: self, label, parent.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'empty' takes 1 arguments: self.  Docstring: Empties the tree

>>> t = BinarySearchTree()
>>> assert t.root is None
>>> t.put(8)
>>> assert t.root is not None
 - Function 'is_empty' takes 1 arguments: self.  Docstring: Checks if the tree is empty

>>> t = BinarySearchTree()
>>> t.is_empty()
True
>>> t.put(8)
>>> t.is_empty()
False
 - Function 'put' takes 2 arguments: self, label.  Docstring: Put a new node in the tree

>>> t = BinarySearchTree()
>>> t.put(8)
>>> assert t.root.parent is None
>>> assert t.root.label == 8

>>> t.put(10)
>>> assert t.root.right.parent == t.root
>>> assert t.root.right.label == 10

>>> t.put(3)
>>> assert t.root.left.parent == t.root
>>> assert t.root.left.label == 3
 - Function '_put' takes 4 arguments: self, node, label, parent.  No docstring available.
 - Function 'search' takes 2 arguments: self, label.  Docstring: Searches a node in the tree

>>> t = BinarySearchTree()
>>> t.put(8)
>>> t.put(10)
>>> node = t.search(8)
>>> assert node.label == 8

>>> node = t.search(3)
Traceback (most recent call last):
    ...
ValueError: Node with label 3 does not exist
 - Function '_search' takes 3 arguments: self, node, label.  No docstring available.
 - Function 'remove' takes 2 arguments: self, label.  Docstring: Removes a node in the tree

>>> t = BinarySearchTree()
>>> t.put(8)
>>> t.put(10)
>>> t.remove(8)
>>> assert t.root.label == 10

>>> t.remove(3)
Traceback (most recent call last):
    ...
ValueError: Node with label 3 does not exist
 - Function '_reassign_nodes' takes 3 arguments: self, node, new_children.  No docstring available.
 - Function '_get_lowest_node' takes 2 arguments: self, node.  No docstring available.
 - Function 'exists' takes 2 arguments: self, label.  Docstring: Checks if a node exists in the tree

>>> t = BinarySearchTree()
>>> t.put(8)
>>> t.put(10)
>>> t.exists(8)
True

>>> t.exists(3)
False
 - Function 'get_max_label' takes 1 arguments: self.  Docstring: Gets the max label inserted in the tree

>>> t = BinarySearchTree()
>>> t.get_max_label()
Traceback (most recent call last):
    ...
ValueError: Binary search tree is empty

>>> t.put(8)
>>> t.put(10)
>>> t.get_max_label()
10
 - Function 'get_min_label' takes 1 arguments: self.  Docstring: Gets the min label inserted in the tree

>>> t = BinarySearchTree()
>>> t.get_min_label()
Traceback (most recent call last):
    ...
ValueError: Binary search tree is empty

>>> t.put(8)
>>> t.put(10)
>>> t.get_min_label()
8
 - Function 'inorder_traversal' takes 1 arguments: self.  Docstring: Return the inorder traversal of the tree

>>> t = BinarySearchTree()
>>> [i.label for i in t.inorder_traversal()]
[]

>>> t.put(8)
>>> t.put(10)
>>> t.put(9)
>>> [i.label for i in t.inorder_traversal()]
[8, 9, 10]
 - Function '_inorder_traversal' takes 2 arguments: self, node.  No docstring available.
 - Function 'preorder_traversal' takes 1 arguments: self.  Docstring: Return the preorder traversal of the tree

>>> t = BinarySearchTree()
>>> [i.label for i in t.preorder_traversal()]
[]

>>> t.put(8)
>>> t.put(10)
>>> t.put(9)
>>> [i.label for i in t.preorder_traversal()]
[8, 10, 9]
 - Function '_preorder_traversal' takes 2 arguments: self, node.  No docstring available.
 - Function '_get_binary_search_tree' takes 0 arguments: .  Docstring:     8
   / \
  3   10
 / \    \
1   6    14
   / \   /
  4   7 13
   \
    5
 - Function 'test_put' takes 1 arguments: self.  No docstring available.
 - Function 'test_search' takes 1 arguments: self.  No docstring available.
 - Function 'test_remove' takes 1 arguments: self.  No docstring available.
 - Function 'test_remove_2' takes 1 arguments: self.  No docstring available.
 - Function 'test_empty' takes 1 arguments: self.  No docstring available.
 - Function 'test_is_empty' takes 1 arguments: self.  No docstring available.
 - Function 'test_exists' takes 1 arguments: self.  No docstring available.
 - Function 'test_get_max_label' takes 1 arguments: self.  No docstring available.
 - Function 'test_get_min_label' takes 1 arguments: self.  No docstring available.
 - Function 'test_inorder_traversal' takes 1 arguments: self.  No docstring available.
 - Function 'test_preorder_traversal' takes 1 arguments: self.  No docstring available.
 - Function 'binary_search_tree_example' takes 0 arguments: .  Docstring: Example
              8
             / \
            3   10
           / \    \
          1   6    14
             / \   /
            4   7 13
            \
            5

Example After Deletion
              4
             / \
            1   7
                 \
                  5

File: binary_tree_mirror.py
 - Function 'binary_tree_mirror_dict' takes 2 arguments: binary_tree_mirror_dictionary, root.  No docstring available.
 - Function 'binary_tree_mirror' takes 2 arguments: binary_tree, root.  Docstring: >>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 7: [8,9]}, 1)
{1: [3, 2], 2: [5, 4], 3: [7, 6], 7: [9, 8]}
>>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 4: [10,11]}, 1)
{1: [3, 2], 2: [5, 4], 3: [7, 6], 4: [11, 10]}
>>> binary_tree_mirror({ 1: [2,3], 2: [4,5], 3: [6,7], 4: [10,11]}, 5)
Traceback (most recent call last):
    ...
ValueError: root 5 is not present in the binary_tree
>>> binary_tree_mirror({}, 5)
Traceback (most recent call last):
    ...
ValueError: binary tree cannot be empty

File: binary_tree_node_sum.py
 - Function '__init__' takes 2 arguments: self, value.  No docstring available.
 - Function '__init__' takes 2 arguments: self, tree.  No docstring available.
 - Function 'depth_first_search' takes 2 arguments: self, node.  No docstring available.
 - Function '__iter__' takes 1 arguments: self.  No docstring available.

File: binary_tree_path_sum.py
 - Function '__init__' takes 2 arguments: self, value.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'depth_first_search' takes 3 arguments: self, node, path_sum.  No docstring available.
 - Function 'path_sum' takes 3 arguments: self, node, target.  No docstring available.

File: binary_tree_traversals.py
 - Function 'make_tree' takes 0 arguments: .  Docstring: The below tree
    1
   / \
  2   3
 / \
4   5
 - Function 'preorder' takes 1 arguments: root.  Docstring: Pre-order traversal visits root node, left subtree, right subtree.
>>> list(preorder(make_tree()))
[1, 2, 4, 5, 3]
 - Function 'postorder' takes 1 arguments: root.  Docstring: Post-order traversal visits left subtree, right subtree, root node.
>>> list(postorder(make_tree()))
[4, 5, 2, 3, 1]
 - Function 'inorder' takes 1 arguments: root.  Docstring: In-order traversal visits left subtree, root node, right subtree.
>>> list(inorder(make_tree()))
[4, 2, 5, 1, 3]
 - Function 'reverse_inorder' takes 1 arguments: root.  Docstring: Reverse in-order traversal visits right subtree, root node, left subtree.
>>> list(reverse_inorder(make_tree()))
[3, 1, 5, 2, 4]
 - Function 'height' takes 1 arguments: root.  Docstring: Recursive function for calculating the height of the binary tree.
>>> height(None)
0
>>> height(make_tree())
3
 - Function 'level_order' takes 1 arguments: root.  Docstring: Returns a list of nodes value from a whole binary tree in Level Order Traverse.
Level Order traverse: Visit nodes of the tree level-by-level.
>>> list(level_order(make_tree()))
[1, 2, 3, 4, 5]
 - Function 'get_nodes_from_left_to_right' takes 2 arguments: root, level.  Docstring: Returns a list of nodes value from a particular level:
Left to right direction of the binary tree.
>>> list(get_nodes_from_left_to_right(make_tree(), 1))
[1]
>>> list(get_nodes_from_left_to_right(make_tree(), 2))
[2, 3]
 - Function 'populate_output' takes 2 arguments: root, level.  No docstring available.
 - Function 'get_nodes_from_right_to_left' takes 2 arguments: root, level.  Docstring: Returns a list of nodes value from a particular level:
Right to left direction of the binary tree.
>>> list(get_nodes_from_right_to_left(make_tree(), 1))
[1]
>>> list(get_nodes_from_right_to_left(make_tree(), 2))
[3, 2]
 - Function 'populate_output' takes 2 arguments: root, level.  No docstring available.
 - Function 'zigzag' takes 1 arguments: root.  Docstring: ZigZag traverse:
Returns a list of nodes value from left to right and right to left, alternatively.
>>> list(zigzag(make_tree()))
[1, 3, 2, 4, 5]
 - Function 'main' takes 0 arguments: .  No docstring available.

File: diameter_of_binary_tree.py
 - Function 'depth' takes 1 arguments: self.  Docstring: >>> root = Node(1)
>>> root.depth()
1
>>> root.left = Node(2)
>>> root.depth()
2
>>> root.left.depth()
1
>>> root.right = Node(3)
>>> root.depth()
2
 - Function 'diameter' takes 1 arguments: self.  Docstring: >>> root = Node(1)
>>> root.diameter()
1
>>> root.left = Node(2)
>>> root.diameter()
2
>>> root.left.diameter()
1
>>> root.right = Node(3)
>>> root.diameter()
3

File: diff_views_of_binary_tree.py
 - Function 'make_tree' takes 0 arguments: .  Docstring: >>> make_tree().val
3
 - Function 'binary_tree_right_side_view' takes 1 arguments: root.  Docstring: Function returns the right side view of binary tree.

   3       <-  3
 / \
9   20    <-  20
   /  \
  15   7  <-  7

>>> binary_tree_right_side_view(make_tree())
[3, 20, 7]
>>> binary_tree_right_side_view(None)
[]
 - Function 'depth_first_search' takes 3 arguments: root, depth, right_view.  Docstring: A depth first search preorder traversal to append the values at
right side of tree.
 - Function 'binary_tree_left_side_view' takes 1 arguments: root.  Docstring: Function returns the left side view of binary tree.

3  ->    3
        / \
9  ->  9   20
          /  \
15 ->    15   7

>>> binary_tree_left_side_view(make_tree())
[3, 9, 15]
>>> binary_tree_left_side_view(None)
[]
 - Function 'depth_first_search' takes 3 arguments: root, depth, left_view.  Docstring: A depth first search preorder traversal to append the values
at left side of tree.
 - Function 'binary_tree_top_side_view' takes 1 arguments: root.  Docstring: Function returns the top side view of binary tree.

9 3 20 7
    

  3
 / \
9   20
   /  \
  15   7

>>> binary_tree_top_side_view(make_tree())
[9, 3, 20, 7]
>>> binary_tree_top_side_view(None)
[]
 - Function 'breadth_first_search' takes 2 arguments: root, top_view.  Docstring: A breadth first search traversal with defaultdict ds to append
the values of tree from top view
 - Function 'binary_tree_bottom_side_view' takes 1 arguments: root.  Docstring: Function returns the bottom side view of binary tree

  3
 / \
9   20
   /  \
  15   7
     
9 15 20 7

>>> binary_tree_bottom_side_view(make_tree())
[9, 15, 20, 7]
>>> binary_tree_bottom_side_view(None)
[]
 - Function 'breadth_first_search' takes 2 arguments: root, bottom_view.  Docstring: A breadth first search traversal with defaultdict ds to append
the values of tree from bottom view

File: distribute_coins.py
 - Function 'distribute_coins' takes 1 arguments: root.  Docstring: >>> distribute_coins(TreeNode(3, TreeNode(0), TreeNode(0)))
2
>>> distribute_coins(TreeNode(0, TreeNode(3), TreeNode(0)))
3
>>> distribute_coins(TreeNode(0, TreeNode(0), TreeNode(3)))
3
>>> distribute_coins(None)
0
>>> distribute_coins(TreeNode(0, TreeNode(0), TreeNode(0)))
Traceback (most recent call last):
 ...
ValueError: The nodes number should be same as the number of coins
>>> distribute_coins(TreeNode(0, TreeNode(1), TreeNode(1)))
Traceback (most recent call last):
 ...
ValueError: The nodes number should be same as the number of coins
 - Function 'count_nodes' takes 1 arguments: node.  Docstring: >>> count_nodes(None)
0
 - Function 'count_coins' takes 1 arguments: node.  Docstring: >>> count_coins(None)
0
 - Function 'get_distrib' takes 1 arguments: node.  Docstring: >>> get_distrib(None)
namedtuple("CoinsDistribResult", "0 2")

File: fenwick_tree.py
 - Function '__init__' takes 3 arguments: self, arr, size.  Docstring: Constructor for the Fenwick tree

Parameters:
    arr (list): list of elements to initialize the tree with (optional)
    size (int): size of the Fenwick tree (if arr is None)
 - Function 'init' takes 2 arguments: self, arr.  Docstring: Initialize the Fenwick tree with arr in O(N)

Parameters:
    arr (list): list of elements to initialize the tree with

Returns:
    None

>>> a = [1, 2, 3, 4, 5]
>>> f1 = FenwickTree(a)
>>> f2 = FenwickTree(size=len(a))
>>> for index, value in enumerate(a):
...     f2.add(index, value)
>>> f1.tree == f2.tree
True
 - Function 'get_array' takes 1 arguments: self.  Docstring: Get the Normal Array of the Fenwick tree in O(N)

Returns:
    list: Normal Array of the Fenwick tree

>>> a = [i for i in range(128)]
>>> f = FenwickTree(a)
>>> f.get_array() == a
True
 - Function 'next_' takes 1 arguments: index.  No docstring available.
 - Function 'prev' takes 1 arguments: index.  No docstring available.
 - Function 'add' takes 3 arguments: self, index, value.  Docstring: Add a value to index in O(lg N)

Parameters:
    index (int): index to add value to
    value (int): value to add to index

Returns:
    None

>>> f = FenwickTree([1, 2, 3, 4, 5])
>>> f.add(0, 1)
>>> f.add(1, 2)
>>> f.add(2, 3)
>>> f.add(3, 4)
>>> f.add(4, 5)
>>> f.get_array()
[2, 4, 6, 8, 10]
 - Function 'update' takes 3 arguments: self, index, value.  Docstring: Set the value of index in O(lg N)

Parameters:
    index (int): index to set value to
    value (int): value to set in index

Returns:
    None

>>> f = FenwickTree([5, 4, 3, 2, 1])
>>> f.update(0, 1)
>>> f.update(1, 2)
>>> f.update(2, 3)
>>> f.update(3, 4)
>>> f.update(4, 5)
>>> f.get_array()
[1, 2, 3, 4, 5]
 - Function 'prefix' takes 2 arguments: self, right.  Docstring: Prefix sum of all elements in [0, right) in O(lg N)

Parameters:
    right (int): right bound of the query (exclusive)

Returns:
    int: sum of all elements in [0, right)

>>> a = [i for i in range(128)]
>>> f = FenwickTree(a)
>>> res = True
>>> for i in range(len(a)):
...     res = res and f.prefix(i) == sum(a[:i])
>>> res
True
 - Function 'query' takes 3 arguments: self, left, right.  Docstring: Query the sum of all elements in [left, right) in O(lg N)

Parameters:
    left (int): left bound of the query (inclusive)
    right (int): right bound of the query (exclusive)

Returns:
    int: sum of all elements in [left, right)

>>> a = [i for i in range(128)]
>>> f = FenwickTree(a)
>>> res = True
>>> for i in range(len(a)):
...     for j in range(i + 1, len(a)):
...         res = res and f.query(i, j) == sum(a[i:j])
>>> res
True
 - Function 'get' takes 2 arguments: self, index.  Docstring: Get value at index in O(lg N)

Parameters:
    index (int): index to get the value

Returns:
    int: Value of element at index

>>> a = [i for i in range(128)]
>>> f = FenwickTree(a)
>>> res = True
>>> for i in range(len(a)):
...     res = res and f.get(i) == a[i]
>>> res
True
 - Function 'rank_query' takes 2 arguments: self, value.  Docstring: Find the largest index with prefix(i) <= value in O(lg N)
NOTE: Requires that all values are non-negative!

Parameters:
    value (int): value to find the largest index of

Returns:
    -1: if value is smaller than all elements in prefix sum
    int: largest index with prefix(i) <= value

>>> f = FenwickTree([1, 2, 0, 3, 0, 5])
>>> f.rank_query(0)
-1
>>> f.rank_query(2)
0
>>> f.rank_query(1)
0
>>> f.rank_query(3)
2
>>> f.rank_query(5)
2
>>> f.rank_query(6)
4
>>> f.rank_query(11)
5

File: flatten_binarytree_to_linkedlist.py
 - Function '__init__' takes 2 arguments: self, data.  No docstring available.
 - Function 'build_tree' takes 0 arguments: .  Docstring: Build and return a sample binary tree.

Returns:
    TreeNode: The root of the binary tree.

Examples:
    >>> root = build_tree()
    >>> root.data
    1
    >>> root.left.data
    2
    >>> root.right.data
    5
    >>> root.left.left.data
    3
    >>> root.left.right.data
    4
    >>> root.right.right.data
    6
 - Function 'flatten' takes 1 arguments: root.  Docstring: Flatten a binary tree into a linked list in-place, where the linked list is
represented using the right pointers of the tree nodes.

Args:
    root (TreeNode): The root of the binary tree to be flattened.

Examples:
    >>> root = TreeNode(1)
    >>> root.left = TreeNode(2)
    >>> root.right = TreeNode(5)
    >>> root.left.left = TreeNode(3)
    >>> root.left.right = TreeNode(4)
    >>> root.right.right = TreeNode(6)
    >>> flatten(root)
    >>> root.data
    1
    >>> root.right.right is None
    False
    >>> root.right.right = TreeNode(3)
    >>> root.right.right.right is None
    True
 - Function 'display_linked_list' takes 1 arguments: root.  Docstring: Display the flattened linked list.

Args:
    root (TreeNode | None): The root of the flattened linked list.

Examples:
    >>> root = TreeNode(1)
    >>> root.right = TreeNode(2)
    >>> root.right.right = TreeNode(3)
    >>> display_linked_list(root)
    1 2 3
    >>> root = None
    >>> display_linked_list(root)

File: floor_and_ceiling.py
 - Function '__iter__' takes 1 arguments: self.  No docstring available.
 - Function '__len__' takes 1 arguments: self.  No docstring available.
 - Function 'floor_ceiling' takes 2 arguments: root, key.  Docstring: Find the floor and ceiling values for a given key in a Binary Search Tree (BST).

Args:
    root: The root of the binary search tree.
    key: The key for which to find the floor and ceiling.

Returns:
    A tuple containing the floor and ceiling values, respectively.

Examples:
    >>> root = Node(10)
    >>> root.left = Node(5)
    >>> root.right = Node(20)
    >>> root.left.left = Node(3)
    >>> root.left.right = Node(7)
    >>> root.right.left = Node(15)
    >>> root.right.right = Node(25)
    >>> tuple(root)
    (3, 5, 7, 10, 15, 20, 25)
    >>> floor_ceiling(root, 8)
    (7, 10)
    >>> floor_ceiling(root, 14)
    (10, 15)
    >>> floor_ceiling(root, -1)
    (None, 3)
    >>> floor_ceiling(root, 30)
    (25, None)

File: inorder_tree_traversal_2022.py
 - Function '__init__' takes 2 arguments: self, data.  No docstring available.
 - Function 'insert' takes 2 arguments: node, new_value.  Docstring: If the binary search tree is empty, make a new node and declare it as root.
>>> node_a = BinaryTreeNode(12345)
>>> node_b = insert(node_a, 67890)
>>> node_a.left_child == node_b.left_child
True
>>> node_a.right_child == node_b.right_child
True
>>> node_a.data == node_b.data
True
 - Function 'inorder' takes 1 arguments: node.  Docstring: >>> inorder(make_tree())
[6, 10, 14, 15, 20, 25, 60]
 - Function 'make_tree' takes 0 arguments: .  No docstring available.
 - Function 'main' takes 0 arguments: .  No docstring available.

File: is_sorted.py
 - Function '__iter__' takes 1 arguments: self.  Docstring: >>> root = Node(data=2.1)
>>> list(root)
[2.1]
>>> root.left=Node(data=2.0)
>>> list(root)
[2.0, 2.1]
>>> root.right=Node(data=2.2)
>>> list(root)
[2.0, 2.1, 2.2]
 - Function 'is_sorted' takes 1 arguments: self.  Docstring: >>> Node(data='abc').is_sorted
True
>>> Node(data=2,
...      left=Node(data=1.999),
...      right=Node(data=3)).is_sorted
True
>>> Node(data=0,
...      left=Node(data=0),
...      right=Node(data=0)).is_sorted
True
>>> Node(data=0,
...      left=Node(data=-11),
...      right=Node(data=3)).is_sorted
True
>>> Node(data=5,
...      left=Node(data=1),
...      right=Node(data=4, left=Node(data=3))).is_sorted
False
>>> Node(data='a',
...      left=Node(data=1),
...      right=Node(data=4, left=Node(data=3))).is_sorted
Traceback (most recent call last):
    ...
TypeError: '<' not supported between instances of 'str' and 'int'
>>> Node(data=2,
...      left=Node([]),
...      right=Node(data=4, left=Node(data=3))).is_sorted
Traceback (most recent call last):
    ...
TypeError: '<' not supported between instances of 'int' and 'list'

File: is_sum_tree.py
 - Function '__iter__' takes 1 arguments: self.  Docstring: >>> root = Node(2)
>>> list(root)
[2]
>>> root.left = Node(1)
>>> tuple(root)
(1, 2)
 - Function '__len__' takes 1 arguments: self.  Docstring: >>> root = Node(2)
>>> len(root)
1
>>> root.left = Node(1)
>>> len(root)
2
 - Function 'is_sum_node' takes 1 arguments: self.  Docstring: >>> root = Node(3)
>>> root.is_sum_node
True
>>> root.left = Node(1)
>>> root.is_sum_node
False
>>> root.right = Node(2)
>>> root.is_sum_node
True
 - Function '__iter__' takes 1 arguments: self.  Docstring: >>> list(BinaryTree.build_a_tree())
[1, 2, 7, 11, 15, 29, 35, 40]
 - Function '__len__' takes 1 arguments: self.  Docstring: >>> len(BinaryTree.build_a_tree())
8
 - Function '__str__' takes 1 arguments: self.  Docstring: Returns a string representation of the inorder traversal of the binary tree.

>>> str(list(BinaryTree.build_a_tree()))
'[1, 2, 7, 11, 15, 29, 35, 40]'
 - Function 'is_sum_tree' takes 1 arguments: self.  Docstring: >>> BinaryTree.build_a_tree().is_sum_tree
False
>>> BinaryTree.build_a_sum_tree().is_sum_tree
True
 - Function 'build_a_tree' takes 1 arguments: cls.  Docstring: Create a binary tree with the specified structure:
      11
   /     \
  2       29
 / \     /  \
1   7  15    40
               \
                35
>>> list(BinaryTree.build_a_tree())
[1, 2, 7, 11, 15, 29, 35, 40]
 - Function 'build_a_sum_tree' takes 1 arguments: cls.  Docstring: Create a binary tree with the specified structure:
     26
    /  \
  10    3
 /  \    \
4    6    3
>>> list(BinaryTree.build_a_sum_tree())
[4, 10, 6, 26, 3, 3]

File: lazy_segment_tree.py
 - Function '__init__' takes 2 arguments: self, size.  No docstring available.
 - Function 'left' takes 2 arguments: self, idx.  Docstring: >>> segment_tree = SegmentTree(15)
>>> segment_tree.left(1)
2
>>> segment_tree.left(2)
4
>>> segment_tree.left(12)
24
 - Function 'right' takes 2 arguments: self, idx.  Docstring: >>> segment_tree = SegmentTree(15)
>>> segment_tree.right(1)
3
>>> segment_tree.right(2)
5
>>> segment_tree.right(12)
25
 - Function 'build' takes 5 arguments: self, idx, left_element, right_element, a.  No docstring available.
 - Function 'update' takes 7 arguments: self, idx, left_element, right_element, a, b, val.  Docstring: update with O(lg n) (Normal segment tree without lazy update will take O(nlg n)
for each update)

update(1, 1, size, a, b, v) for update val v to [a,b]
 - Function 'query' takes 6 arguments: self, idx, left_element, right_element, a, b.  Docstring: query(1, 1, size, a, b) for query max of [a,b]
>>> A = [1, 2, -4, 7, 3, -5, 6, 11, -20, 9, 14, 15, 5, 2, -8]
>>> segment_tree = SegmentTree(15)
>>> segment_tree.build(1, 1, 15, A)
>>> segment_tree.query(1, 1, 15, 4, 6)
7
>>> segment_tree.query(1, 1, 15, 7, 11)
14
>>> segment_tree.query(1, 1, 15, 7, 12)
15
 - Function '__str__' takes 1 arguments: self.  No docstring available.

File: lowest_common_ancestor.py
 - Function 'swap' takes 2 arguments: a, b.  Docstring: Return a tuple (b, a) when given two integers a and b
>>> swap(2,3)
(3, 2)
>>> swap(3,4)
(4, 3)
>>> swap(67, 12)
(12, 67)
 - Function 'create_sparse' takes 2 arguments: max_node, parent.  Docstring: creating sparse table which saves each nodes 2^i-th parent
 - Function 'lowest_common_ancestor' takes 4 arguments: u, v, level, parent.  No docstring available.
 - Function 'breadth_first_search' takes 5 arguments: level, parent, max_node, graph, root.  Docstring: sets every nodes direct parent
parent of root node is set to 0
calculates depth of each node from root node
 - Function 'main' takes 0 arguments: .  No docstring available.

File: maximum_fenwick_tree.py
 - Function '__init__' takes 2 arguments: self, size.  Docstring: Create empty Maximum Fenwick Tree with specified size

Parameters:
    size: size of Array

Returns:
    None
 - Function 'get_next' takes 1 arguments: index.  Docstring: Get next index in O(1)
 - Function 'get_prev' takes 1 arguments: index.  Docstring: Get previous index in O(1)
 - Function 'update' takes 3 arguments: self, index, value.  Docstring: Set index to value in O(lg^2 N)

Parameters:
    index: index to update
    value: value to set

Returns:
    None
 - Function 'query' takes 3 arguments: self, left, right.  Docstring: Answer the query of maximum range [l, r) in O(lg^2 N)

Parameters:
    left: left index of query range (inclusive)
    right: right index of query range (exclusive)

Returns:
    Maximum value of range [left, right)

File: merge_two_binary_trees.py
 - Function '__init__' takes 2 arguments: self, value.  No docstring available.
 - Function 'merge_two_binary_trees' takes 2 arguments: tree1, tree2.  Docstring: Returns root node of the merged tree.

>>> tree1 = Node(5)
>>> tree1.left = Node(6)
>>> tree1.right = Node(7)
>>> tree1.left.left = Node(2)
>>> tree2 = Node(4)
>>> tree2.left = Node(5)
>>> tree2.right = Node(8)
>>> tree2.left.right = Node(1)
>>> tree2.right.right = Node(4)
>>> merged_tree = merge_two_binary_trees(tree1, tree2)
>>> print_preorder(merged_tree)
9
11
2
1
15
4
 - Function 'print_preorder' takes 1 arguments: root.  Docstring: Print pre-order traversal of the tree.

>>> root = Node(1)
>>> root.left = Node(2)
>>> root.right = Node(3)
>>> print_preorder(root)
1
2
3
>>> print_preorder(root.right)
3

File: mirror_binary_tree.py
 - Function '__iter__' takes 1 arguments: self.  No docstring available.
 - Function '__len__' takes 1 arguments: self.  No docstring available.
 - Function 'mirror' takes 1 arguments: self.  Docstring: Mirror the binary tree rooted at this node by swapping left and right children.

>>> tree = Node(0)
>>> list(tree)
[0]
>>> list(tree.mirror())
[0]
>>> tree = Node(1, Node(0), Node(3, Node(2), Node(4, None, Node(5))))
>>> tuple(tree)
(0, 1, 2, 3, 4, 5)
>>> tuple(tree.mirror())
(5, 4, 3, 2, 1, 0)
 - Function 'make_tree_seven' takes 0 arguments: .  Docstring: Return a binary tree with 7 nodes that looks like this:
       1
     /   \
    2     3
   / \   / \
  4   5 6   7

>>> tree_seven = make_tree_seven()
>>> len(tree_seven)
7
>>> list(tree_seven)
[4, 2, 5, 1, 6, 3, 7]
 - Function 'make_tree_nine' takes 0 arguments: .  Docstring: Return a binary tree with 9 nodes that looks like this:
      1
     /  \
    2    3
   / \    \
  4   5    6
 / \   \
7   8   9

>>> tree_nine = make_tree_nine()
>>> len(tree_nine)
9
>>> list(tree_nine)
[7, 4, 8, 2, 5, 9, 1, 3, 6]
 - Function 'main' takes 0 arguments: .  Docstring: Mirror binary trees with the given root and returns the root

>>> tree = make_tree_nine()
>>> tuple(tree)
(7, 4, 8, 2, 5, 9, 1, 3, 6)
>>> tuple(tree.mirror())
(6, 3, 1, 9, 5, 2, 8, 4, 7)

nine_tree:
      1
     /  \
    2    3
   / \    \
  4   5    6
 / \   \
7   8   9

The mirrored tree looks like this:
      1
     /  \
    3    2
   /    / \
  6    5   4
      /   / \
     9   8   7

File: non_recursive_segment_tree.py
 - Function '__init__' takes 3 arguments: self, arr, fnc.  Docstring: Segment Tree constructor, it works just with commutative combiner.
:param arr: list of elements for the segment tree
:param fnc: commutative function for combine two elements

>>> SegmentTree(['a', 'b', 'c'], lambda a, b: f'{a}{b}').query(0, 2)
'abc'
>>> SegmentTree([(1, 2), (2, 3), (3, 4)],
...             lambda a, b: (a[0] + b[0], a[1] + b[1])).query(0, 2)
(6, 9)
 - Function 'build' takes 1 arguments: self.  No docstring available.
 - Function 'update' takes 3 arguments: self, p, v.  Docstring: Update an element in log(N) time
:param p: position to be update
:param v: new value

>>> st = SegmentTree([3, 1, 2, 4], min)
>>> st.query(0, 3)
1
>>> st.update(2, -1)
>>> st.query(0, 3)
-1
 - Function 'query' takes 3 arguments: self, left, right.  Docstring: Get range query value in log(N) time
:param left: left element index
:param right: right element index
:return: element combined in the range [left, right]

>>> st = SegmentTree([1, 2, 3, 4], lambda a, b: a + b)
>>> st.query(0, 2)
6
>>> st.query(1, 2)
5
>>> st.query(0, 3)
10
>>> st.query(2, 3)
7
 - Function 'test_all_segments' takes 0 arguments: .  Docstring: Test all possible segments

File: number_of_possible_binary_trees.py
 - Function 'binomial_coefficient' takes 2 arguments: n, k.  Docstring: Since Here we Find the Binomial Coefficient:
https://en.wikipedia.org/wiki/Binomial_coefficient
C(n,k) = n! / k!(n-k)!
:param n: 2 times of Number of nodes
:param k: Number of nodes
:return:  Integer Value

>>> binomial_coefficient(4, 2)
6
 - Function 'catalan_number' takes 1 arguments: node_count.  Docstring: We can find Catalan number many ways but here we use Binomial Coefficient because it
does the job in O(n)

return the Catalan number of n using 2nCn/(n+1).
:param n: number of nodes
:return: Catalan number of n nodes

>>> catalan_number(5)
42
>>> catalan_number(6)
132
 - Function 'factorial' takes 1 arguments: n.  Docstring: Return the factorial of a number.
:param n: Number to find the Factorial of.
:return: Factorial of n.

>>> import math
>>> all(factorial(i) == math.factorial(i) for i in range(10))
True
>>> factorial(-5)  # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
ValueError: factorial() not defined for negative values
 - Function 'binary_tree_count' takes 1 arguments: node_count.  Docstring: Return the number of possible of binary trees.
:param n: number of nodes
:return: Number of possible binary trees

>>> binary_tree_count(5)
5040
>>> binary_tree_count(6)
95040

File: red_black_tree.py
 - Function '__init__' takes 6 arguments: self, label, color, parent, left, right.  Docstring: Initialize a new Red-Black Tree node with the given values:
label: The value associated with this node
color: 0 if black, 1 if red
parent: The parent to this node
left: This node's left child
right: This node's right child
 - Function 'rotate_left' takes 1 arguments: self.  Docstring: Rotate the subtree rooted at this node to the left and
returns the new root to this subtree.
Performing one rotation can be done in O(1).
 - Function 'rotate_right' takes 1 arguments: self.  Docstring: Rotate the subtree rooted at this node to the right and
returns the new root to this subtree.
Performing one rotation can be done in O(1).
 - Function 'insert' takes 2 arguments: self, label.  Docstring: Inserts label into the subtree rooted at self, performs any
rotations necessary to maintain balance, and then returns the
new root to this subtree (likely self).
This is guaranteed to run in O(log(n)) time.
 - Function '_insert_repair' takes 1 arguments: self.  Docstring: Repair the coloring from inserting into a tree.
 - Function 'remove' takes 2 arguments: self, label.  Docstring: Remove label from this tree.
 - Function '_remove_repair' takes 1 arguments: self.  Docstring: Repair the coloring of the tree that may have been messed up.
 - Function 'check_color_properties' takes 1 arguments: self.  Docstring: Check the coloring of the tree, and return True iff the tree
is colored in a way which matches these five properties:
(wording stolen from wikipedia article)
 1. Each node is either red or black.
 2. The root node is black.
 3. All leaves are black.
 4. If a node is red, then both its children are black.
 5. Every path from any node to all of its descendent NIL nodes
    has the same number of black nodes.
This function runs in O(n) time, because properties 4 and 5 take
that long to check.
 - Function 'check_coloring' takes 1 arguments: self.  Docstring: A helper function to recursively check Property 4 of a
Red-Black Tree. See check_color_properties for more info.
 - Function 'black_height' takes 1 arguments: self.  Docstring: Returns the number of black nodes from this node to the
leaves of the tree, or None if there isn't one such value (the
tree is color incorrectly).
 - Function '__contains__' takes 2 arguments: self, label.  Docstring: Search through the tree for label, returning True iff it is
found somewhere in the tree.
Guaranteed to run in O(log(n)) time.
 - Function 'search' takes 2 arguments: self, label.  Docstring: Search through the tree for label, returning its node if
it's found, and None otherwise.
This method is guaranteed to run in O(log(n)) time.
 - Function 'floor' takes 2 arguments: self, label.  Docstring: Returns the largest element in this tree which is at most label.
This method is guaranteed to run in O(log(n)) time.
 - Function 'ceil' takes 2 arguments: self, label.  Docstring: Returns the smallest element in this tree which is at least label.
This method is guaranteed to run in O(log(n)) time.
 - Function 'get_max' takes 1 arguments: self.  Docstring: Returns the largest element in this tree.
This method is guaranteed to run in O(log(n)) time.
 - Function 'get_min' takes 1 arguments: self.  Docstring: Returns the smallest element in this tree.
This method is guaranteed to run in O(log(n)) time.
 - Function 'grandparent' takes 1 arguments: self.  Docstring: Get the current node's grandparent, or None if it doesn't exist.
 - Function 'sibling' takes 1 arguments: self.  Docstring: Get the current node's sibling, or None if it doesn't exist.
 - Function 'is_left' takes 1 arguments: self.  Docstring: Returns true iff this node is the left child of its parent.
 - Function 'is_right' takes 1 arguments: self.  Docstring: Returns true iff this node is the right child of its parent.
 - Function '__bool__' takes 1 arguments: self.  No docstring available.
 - Function '__len__' takes 1 arguments: self.  Docstring: Return the number of nodes in this tree.
 - Function 'preorder_traverse' takes 1 arguments: self.  No docstring available.
 - Function 'inorder_traverse' takes 1 arguments: self.  No docstring available.
 - Function 'postorder_traverse' takes 1 arguments: self.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function '__eq__' takes 2 arguments: self, other.  Docstring: Test if two trees are equal.
 - Function 'color' takes 1 arguments: node.  Docstring: Returns the color of a node, allowing for None leaves.
 - Function 'test_rotations' takes 0 arguments: .  Docstring: Test that the rotate_left and rotate_right functions work.
 - Function 'test_insertion_speed' takes 0 arguments: .  Docstring: Test that the tree balances inserts to O(log(n)) by doing a lot
of them.
 - Function 'test_insert' takes 0 arguments: .  Docstring: Test the insert() method of the tree correctly balances, colors,
and inserts.
 - Function 'test_insert_and_search' takes 0 arguments: .  Docstring: Tests searching through the tree for values.
 - Function 'test_insert_delete' takes 0 arguments: .  Docstring: Test the insert() and delete() method of the tree, verifying the
insertion and removal of elements, and the balancing of the tree.
 - Function 'test_floor_ceil' takes 0 arguments: .  Docstring: Tests the floor and ceiling functions in the tree.
 - Function 'test_min_max' takes 0 arguments: .  Docstring: Tests the min and max functions in the tree.
 - Function 'test_tree_traversal' takes 0 arguments: .  Docstring: Tests the three different tree traversal functions.
 - Function 'test_tree_chaining' takes 0 arguments: .  Docstring: Tests the three different tree chaining functions.
 - Function 'print_results' takes 2 arguments: msg, passes.  No docstring available.
 - Function 'pytests' takes 0 arguments: .  No docstring available.
 - Function 'main' takes 0 arguments: .  Docstring: >>> pytests()

File: segment_tree.py
 - Function '__init__' takes 2 arguments: self, a.  No docstring available.
 - Function 'left' takes 2 arguments: self, idx.  Docstring: Returns the left child index for a given index in a binary tree.

>>> s = SegmentTree([1, 2, 3])
>>> s.left(1)
2
>>> s.left(2)
4
 - Function 'right' takes 2 arguments: self, idx.  Docstring: Returns the right child index for a given index in a binary tree.

>>> s = SegmentTree([1, 2, 3])
>>> s.right(1)
3
>>> s.right(2)
5
 - Function 'build' takes 4 arguments: self, idx, left, right.  No docstring available.
 - Function 'update' takes 4 arguments: self, a, b, val.  Docstring: Update the values in the segment tree in the range [a,b] with the given value.

>>> s = SegmentTree([1, 2, 3, 4, 5])
>>> s.update(2, 4, 10)
True
>>> s.query(1, 5)
10
 - Function 'update_recursive' takes 7 arguments: self, idx, left, right, a, b, val.  Docstring: update(1, 1, N, a, b, v) for update val v to [a,b]
 - Function 'query' takes 3 arguments: self, a, b.  Docstring: Query the maximum value in the range [a,b].

>>> s = SegmentTree([1, 2, 3, 4, 5])
>>> s.query(1, 3)
3
>>> s.query(1, 5)
5
 - Function 'query_recursive' takes 6 arguments: self, idx, left, right, a, b.  Docstring: query(1, 1, N, a, b) for query max of [a,b]
 - Function 'show_data' takes 1 arguments: self.  No docstring available.

File: segment_tree_other.py
 - Function '__init__' takes 6 arguments: self, start, end, val, left, right.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 3 arguments: self, collection, function.  No docstring available.
 - Function 'update' takes 3 arguments: self, i, val.  Docstring: Update an element in log(N) time
:param i: position to be update
:param val: new value
>>> import operator
>>> num_arr = SegmentTree([2, 1, 5, 3, 4], operator.add)
>>> num_arr.update(1, 5)
>>> num_arr.query_range(1, 3)
13
 - Function 'query_range' takes 3 arguments: self, i, j.  Docstring: Get range query value in log(N) time
:param i: left element index
:param j: right element index
:return: element combined in the range [i, j]
>>> import operator
>>> num_arr = SegmentTree([2, 1, 5, 3, 4], operator.add)
>>> num_arr.update(1, 5)
>>> num_arr.query_range(3, 4)
7
>>> num_arr.query_range(2, 2)
5
>>> num_arr.query_range(1, 3)
13
>>>
 - Function '_build_tree' takes 3 arguments: self, start, end.  No docstring available.
 - Function '_update_tree' takes 4 arguments: self, node, i, val.  No docstring available.
 - Function '_query_range' takes 4 arguments: self, node, i, j.  No docstring available.
 - Function 'traverse' takes 1 arguments: self.  No docstring available.

File: serialize_deserialize_binary_tree.py
 - Function '__post_init__' takes 1 arguments: self.  No docstring available.
 - Function '__iter__' takes 1 arguments: self.  Docstring: Iterate through the tree in preorder.

Returns:
    An iterator of the tree nodes.

>>> list(TreeNode(1))
[1,null,null]
>>> tuple(TreeNode(1, TreeNode(2), TreeNode(3)))
(1,2,null,null,3,null,null, 2,null,null, 3,null,null)
 - Function '__len__' takes 1 arguments: self.  Docstring: Count the number of nodes in the tree.

Returns:
    The number of nodes in the tree.

>>> len(TreeNode(1))
1
>>> len(TreeNode(1, TreeNode(2), TreeNode(3)))
3
 - Function '__repr__' takes 1 arguments: self.  Docstring: Represent the tree as a string.

Returns:
    A string representation of the tree.

>>> repr(TreeNode(1))
'1,null,null'
>>> repr(TreeNode(1, TreeNode(2), TreeNode(3)))
'1,2,null,null,3,null,null'
>>> repr(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))))
'1,2,null,null,3,4,null,null,5,null,null'
 - Function 'five_tree' takes 1 arguments: cls.  Docstring: >>> repr(TreeNode.five_tree())
'1,2,null,null,3,4,null,null,5,null,null'
 - Function 'deserialize' takes 1 arguments: data.  Docstring: Deserialize a string to a binary tree.

Args:
    data(str): The serialized string.

Returns:
    The root of the binary tree.

>>> root = TreeNode.five_tree()
>>> serialzed_data = repr(root)
>>> deserialized = deserialize(serialzed_data)
>>> root == deserialized
True
>>> root is deserialized  # two separate trees
False
>>> root.right.right.value = 6
>>> root == deserialized
False
>>> serialzed_data = repr(root)
>>> deserialized = deserialize(serialzed_data)
>>> root == deserialized
True
>>> deserialize("")
Traceback (most recent call last):
    ...
ValueError: Data cannot be empty.
 - Function 'build_tree' takes 0 arguments: .  No docstring available.

File: symmetric_tree.py
 - Function 'make_symmetric_tree' takes 0 arguments: .  Docstring: Create a symmetric tree for testing.
The tree looks like this:
       1
     /   \
    2     2
  / \    / \
 3   4   4  3
 - Function 'make_asymmetric_tree' takes 0 arguments: .  Docstring: Create a asymmetric tree for testing.
The tree looks like this:
       1
     /   \
    2     2
  / \    / \
 3   4   3  4
 - Function 'is_symmetric_tree' takes 1 arguments: tree.  Docstring: Test cases for is_symmetric_tree function
>>> is_symmetric_tree(make_symmetric_tree())
True
>>> is_symmetric_tree(make_asymmetric_tree())
False
 - Function 'is_mirror' takes 2 arguments: left, right.  Docstring: >>> tree1 = make_symmetric_tree()
>>> tree1.right.right = Node(3)
>>> is_mirror(tree1.left, tree1.right)
True
>>> tree2 = make_asymmetric_tree()
>>> is_mirror(tree2.left, tree2.right)
False

File: treap.py
 - Function '__init__' takes 2 arguments: self, value.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function '__str__' takes 1 arguments: self.  No docstring available.
 - Function 'split' takes 2 arguments: root, value.  Docstring: We split current tree into 2 trees with value:

Left tree contains all values less than split value.
Right tree contains all values greater or equal, than split value
 - Function 'merge' takes 2 arguments: left, right.  Docstring: We merge 2 trees into one.
Note: all left tree's values must be less than all right tree's
 - Function 'insert' takes 2 arguments: root, value.  Docstring: Insert element

Split current tree with a value into left, right,
Insert new node into the middle
Merge left, node, right into root
 - Function 'erase' takes 2 arguments: root, value.  Docstring: Erase element

Split all nodes with values less into left,
Split all nodes with values greater into right.
Merge left, right
 - Function 'inorder' takes 1 arguments: root.  Docstring: Just recursive print of a tree
 - Function 'interact_treap' takes 2 arguments: root, args.  Docstring: Commands:
+ value to add value into treap
- value to erase all nodes with value

    >>> root = interact_treap(None, "+1")
    >>> inorder(root)
    1,
    >>> root = interact_treap(root, "+3 +5 +17 +19 +2 +16 +4 +0")
    >>> inorder(root)
    0,1,2,3,4,5,16,17,19,
    >>> root = interact_treap(root, "+4 +4 +4")
    >>> inorder(root)
    0,1,2,3,4,4,4,4,5,16,17,19,
    >>> root = interact_treap(root, "-0")
    >>> inorder(root)
    1,2,3,4,4,4,4,5,16,17,19,
    >>> root = interact_treap(root, "-4")
    >>> inorder(root)
    1,2,3,5,16,17,19,
    >>> root = interact_treap(root, "=0")
    Unknown command
 - Function 'main' takes 0 arguments: .  Docstring: After each command, program prints treap

File: wavelet_tree.py
 - Function '__init__' takes 2 arguments: self, length.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  Docstring: >>> node = Node(length=27)
>>> repr(node)
'Node(min_value=-1 max_value=-1)'
>>> repr(node) == str(node)
True
 - Function 'build_tree' takes 1 arguments: arr.  Docstring: Builds the tree for arr and returns the root
of the constructed tree

>>> build_tree(test_array)
Node(min_value=0 max_value=9)
 - Function 'rank_till_index' takes 3 arguments: node, num, index.  Docstring: Returns the number of occurrences of num in interval [0, index] in the list

>>> root = build_tree(test_array)
>>> rank_till_index(root, 6, 6)
1
>>> rank_till_index(root, 2, 0)
1
>>> rank_till_index(root, 1, 10)
2
>>> rank_till_index(root, 17, 7)
0
>>> rank_till_index(root, 0, 9)
1
 - Function 'rank' takes 4 arguments: node, num, start, end.  Docstring: Returns the number of occurrences of num in interval [start, end] in the list

>>> root = build_tree(test_array)
>>> rank(root, 6, 3, 13)
2
>>> rank(root, 2, 0, 19)
4
>>> rank(root, 9, 2 ,2)
0
>>> rank(root, 0, 5, 10)
2
 - Function 'quantile' takes 4 arguments: node, index, start, end.  Docstring: Returns the index'th smallest element in interval [start, end] in the list
index is 0-indexed

>>> root = build_tree(test_array)
>>> quantile(root, 2, 2, 5)
5
>>> quantile(root, 5, 2, 13)
4
>>> quantile(root, 0, 6, 6)
8
>>> quantile(root, 4, 2, 5)
-1
 - Function 'range_counting' takes 5 arguments: node, start, end, start_num, end_num.  Docstring: Returns the number of elements in range [start_num, end_num]
in interval [start, end] in the list

>>> root = build_tree(test_array)
>>> range_counting(root, 1, 10, 3, 7)
3
>>> range_counting(root, 2, 2, 1, 4)
1
>>> range_counting(root, 0, 19, 0, 100)
20
>>> range_counting(root, 1, 0, 1, 100)
0
>>> range_counting(root, 0, 17, 100, 1)
0

File: alternate_disjoint_set.py
 - Function '__init__' takes 2 arguments: self, set_counts.  Docstring: Initialize with a list of the number of items in each set
and with rank = 1 for each set
 - Function 'merge' takes 3 arguments: self, src, dst.  Docstring: Merge two sets together using Union by rank heuristic
Return True if successful
Merge two disjoint sets
>>> A = DisjointSet([1, 1, 1])
>>> A.merge(1, 2)
True
>>> A.merge(0, 2)
True
>>> A.merge(0, 1)
False
 - Function 'get_parent' takes 2 arguments: self, disj_set.  Docstring: Find the Parent of a given set
>>> A = DisjointSet([1, 1, 1])
>>> A.merge(1, 2)
True
>>> A.get_parent(0)
0
>>> A.get_parent(1)
2

File: disjoint_set.py
 - Function '__init__' takes 2 arguments: self, data.  No docstring available.
 - Function 'make_set' takes 1 arguments: x.  Docstring: Make x as a set.
 - Function 'union_set' takes 2 arguments: x, y.  Docstring: Union of two sets.
set with bigger rank should be parent, so that the
disjoint set tree will be more flat.
 - Function 'find_set' takes 1 arguments: x.  Docstring: Return the parent of x
 - Function 'find_python_set' takes 1 arguments: node.  Docstring: Return a Python Standard Library set that contains i.
 - Function 'test_disjoint_set' takes 0 arguments: .  Docstring: >>> test_disjoint_set()

File: bloom_filter.py
 - Function '__init__' takes 2 arguments: self, size.  No docstring available.
 - Function 'add' takes 2 arguments: self, value.  No docstring available.
 - Function 'exists' takes 2 arguments: self, value.  No docstring available.
 - Function '__contains__' takes 2 arguments: self, other.  No docstring available.
 - Function 'format_bin' takes 2 arguments: self, bitarray.  No docstring available.
 - Function 'bitstring' takes 1 arguments: self.  No docstring available.
 - Function 'hash_' takes 2 arguments: self, value.  No docstring available.
 - Function 'format_hash' takes 2 arguments: self, value.  No docstring available.
 - Function 'estimated_error_rate' takes 1 arguments: self.  No docstring available.

File: double_hash.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__hash_function_2' takes 3 arguments: self, value, data.  No docstring available.
 - Function '__hash_double_function' takes 4 arguments: self, key, data, increment.  No docstring available.
 - Function '_collision_resolution' takes 3 arguments: self, key, data.  Docstring: Examples:

1. Try to add three data elements when the size is three
>>> dh = DoubleHash(3)
>>> dh.insert_data(10)
>>> dh.insert_data(20)
>>> dh.insert_data(30)
>>> dh.keys()
{1: 10, 2: 20, 0: 30}

2. Try to add three data elements when the size is two
>>> dh = DoubleHash(2)
>>> dh.insert_data(10)
>>> dh.insert_data(20)
>>> dh.insert_data(30)
>>> dh.keys()
{10: 10, 9: 20, 8: 30}

3. Try to add three data elements when the size is four
>>> dh = DoubleHash(4)
>>> dh.insert_data(10)
>>> dh.insert_data(20)
>>> dh.insert_data(30)
>>> dh.keys()
{9: 20, 10: 10, 8: 30}

File: hash_map.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__bool__' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 3 arguments: self, initial_block_size, capacity_factor.  No docstring available.
 - Function '_get_bucket_index' takes 2 arguments: self, key.  No docstring available.
 - Function '_get_next_ind' takes 2 arguments: self, ind.  Docstring: Get next index.

Implements linear open addressing.
>>> HashMap(5)._get_next_ind(3)
4
>>> HashMap(5)._get_next_ind(5)
1
>>> HashMap(5)._get_next_ind(6)
2
>>> HashMap(5)._get_next_ind(9)
0
 - Function '_try_set' takes 4 arguments: self, ind, key, val.  Docstring: Try to add value to the bucket.

If bucket is empty or key is the same, does insert and return True.

If bucket has another key or deleted placeholder,
that means that we need to check next bucket.
 - Function '_is_full' takes 1 arguments: self.  Docstring: Return true if we have reached safe capacity.

So we need to increase the number of buckets to avoid collisions.

>>> hm = HashMap(2)
>>> hm._add_item(1, 10)
>>> hm._add_item(2, 20)
>>> hm._is_full()
True
>>> HashMap(2)._is_full()
False
 - Function '_is_sparse' takes 1 arguments: self.  Docstring: Return true if we need twice fewer buckets when we have now.
 - Function '_resize' takes 2 arguments: self, new_size.  No docstring available.
 - Function '_size_up' takes 1 arguments: self.  No docstring available.
 - Function '_size_down' takes 1 arguments: self.  No docstring available.
 - Function '_iterate_buckets' takes 2 arguments: self, key.  No docstring available.
 - Function '_add_item' takes 3 arguments: self, key, val.  Docstring: Try to add 3 elements when the size is 5
>>> hm = HashMap(5)
>>> hm._add_item(1, 10)
>>> hm._add_item(2, 20)
>>> hm._add_item(3, 30)
>>> hm
HashMap(1: 10, 2: 20, 3: 30)

Try to add 3 elements when the size is 5
>>> hm = HashMap(5)
>>> hm._add_item(-5, 10)
>>> hm._add_item(6, 30)
>>> hm._add_item(-7, 20)
>>> hm
HashMap(-5: 10, 6: 30, -7: 20)

Try to add 3 elements when size is 1
>>> hm = HashMap(1)
>>> hm._add_item(10, 13.2)
>>> hm._add_item(6, 5.26)
>>> hm._add_item(7, 5.155)
>>> hm
HashMap(10: 13.2)

Trying to add an element with a key that is a floating point value
>>> hm = HashMap(5)
>>> hm._add_item(1.5, 10)
>>> hm
HashMap(1.5: 10)

5. Trying to add an item with the same key
>>> hm = HashMap(5)
>>> hm._add_item(1, 10)
>>> hm._add_item(1, 20)
>>> hm
HashMap(1: 20)
 - Function '__setitem__' takes 3 arguments: self, key, val.  Docstring: 1. Changing value of item whose key is present
>>> hm = HashMap(5)
>>> hm._add_item(1, 10)
>>> hm.__setitem__(1, 20)
>>> hm
HashMap(1: 20)

2. Changing value of item whose key is not present
>>> hm = HashMap(5)
>>> hm._add_item(1, 10)
>>> hm.__setitem__(0, 20)
>>> hm
HashMap(0: 20, 1: 10)

3. Changing the value of the same item multiple times
>>> hm = HashMap(5)
>>> hm._add_item(1, 10)
>>> hm.__setitem__(1, 20)
>>> hm.__setitem__(1, 30)
>>> hm
HashMap(1: 30)
 - Function '__delitem__' takes 2 arguments: self, key.  Docstring: >>> hm = HashMap(5)
>>> hm._add_item(1, 10)
>>> hm._add_item(2, 20)
>>> hm._add_item(3, 30)
>>> hm.__delitem__(3)
>>> hm
HashMap(1: 10, 2: 20)
>>> hm = HashMap(5)
>>> hm._add_item(-5, 10)
>>> hm._add_item(6, 30)
>>> hm._add_item(-7, 20)
>>> hm.__delitem__(-5)
>>> hm
HashMap(6: 30, -7: 20)

# Trying to remove a non-existing item
>>> hm = HashMap(5)
>>> hm._add_item(1, 10)
>>> hm._add_item(2, 20)
>>> hm._add_item(3, 30)
>>> hm.__delitem__(4)
Traceback (most recent call last):
...
KeyError: 4
 - Function '__getitem__' takes 2 arguments: self, key.  Docstring: Returns the item at the given key

>>> hm = HashMap(5)
>>> hm._add_item(1, 10)
>>> hm.__getitem__(1)
10

>>> hm = HashMap(5)
>>> hm._add_item(10, -10)
>>> hm._add_item(20, -20)
>>> hm.__getitem__(20)
-20

>>> hm = HashMap(5)
>>> hm._add_item(-1, 10)
>>> hm.__getitem__(-1)
10
 - Function '__len__' takes 1 arguments: self.  Docstring: Returns the number of items present in hashmap

>>> hm = HashMap(5)
>>> hm._add_item(1, 10)
>>> hm._add_item(2, 20)
>>> hm._add_item(3, 30)
>>> hm.__len__()
3

>>> hm = HashMap(5)
>>> hm.__len__()
0
 - Function '__iter__' takes 1 arguments: self.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.

File: hash_table.py
 - Function '__init__' takes 4 arguments: self, size_table, charge_factor, lim_charge.  No docstring available.
 - Function 'keys' takes 1 arguments: self.  Docstring: The keys function returns a dictionary containing the key value pairs.
key being the index number in hash table and value being the data value.

Examples:
1. creating HashTable with size 10 and inserting 3 elements
>>> ht = HashTable(10)
>>> ht.insert_data(10)
>>> ht.insert_data(20)
>>> ht.insert_data(30)
>>> ht.keys()
{0: 10, 1: 20, 2: 30}

2. creating HashTable with size 5 and inserting 5 elements
>>> ht = HashTable(5)
>>> ht.insert_data(5)
>>> ht.insert_data(4)
>>> ht.insert_data(3)
>>> ht.insert_data(2)
>>> ht.insert_data(1)
>>> ht.keys()
{0: 5, 4: 4, 3: 3, 2: 2, 1: 1}
 - Function 'balanced_factor' takes 1 arguments: self.  No docstring available.
 - Function 'hash_function' takes 2 arguments: self, key.  Docstring: Generates hash for the given key value

Examples:

Creating HashTable with size 5
>>> ht = HashTable(5)
>>> ht.hash_function(10)
0
>>> ht.hash_function(20)
0
>>> ht.hash_function(4)
4
>>> ht.hash_function(18)
3
>>> ht.hash_function(-18)
2
>>> ht.hash_function(18.5)
3.5
>>> ht.hash_function(0)
0
>>> ht.hash_function(-0)
0
 - Function '_step_by_step' takes 2 arguments: self, step_ord.  No docstring available.
 - Function 'bulk_insert' takes 2 arguments: self, values.  Docstring: bulk_insert is used for entering more than one element at a time
in the HashTable.

Examples:
1.
>>> ht = HashTable(5)
>>> ht.bulk_insert((10,20,30))
step 1
[0, 1, 2, 3, 4]
[10, None, None, None, None]
step 2
[0, 1, 2, 3, 4]
[10, 20, None, None, None]
step 3
[0, 1, 2, 3, 4]
[10, 20, 30, None, None]

2.
>>> ht = HashTable(5)
>>> ht.bulk_insert([5,4,3,2,1])
step 1
[0, 1, 2, 3, 4]
[5, None, None, None, None]
step 2
[0, 1, 2, 3, 4]
[5, None, None, None, 4]
step 3
[0, 1, 2, 3, 4]
[5, None, None, 3, 4]
step 4
[0, 1, 2, 3, 4]
[5, None, 2, 3, 4]
step 5
[0, 1, 2, 3, 4]
[5, 1, 2, 3, 4]
 - Function '_set_value' takes 3 arguments: self, key, data.  Docstring: _set_value functions allows to update value at a particular hash

Examples:
1. _set_value in HashTable of size 5
>>> ht = HashTable(5)
>>> ht.insert_data(10)
>>> ht.insert_data(20)
>>> ht.insert_data(30)
>>> ht._set_value(0,15)
>>> ht.keys()
{0: 15, 1: 20, 2: 30}

2. _set_value in HashTable of size 2
>>> ht = HashTable(2)
>>> ht.insert_data(17)
>>> ht.insert_data(18)
>>> ht.insert_data(99)
>>> ht._set_value(3,15)
>>> ht.keys()
{3: 15, 2: 17, 4: 99}

3. _set_value in HashTable when hash is not present
>>> ht = HashTable(2)
>>> ht.insert_data(17)
>>> ht.insert_data(18)
>>> ht.insert_data(99)
>>> ht._set_value(0,15)
>>> ht.keys()
{3: 18, 2: 17, 4: 99, 0: 15}

4. _set_value in HashTable when multiple hash are not present
>>> ht = HashTable(2)
>>> ht.insert_data(17)
>>> ht.insert_data(18)
>>> ht.insert_data(99)
>>> ht._set_value(0,15)
>>> ht._set_value(1,20)
>>> ht.keys()
{3: 18, 2: 17, 4: 99, 0: 15, 1: 20}
 - Function '_collision_resolution' takes 3 arguments: self, key, data.  Docstring: This method is a type of open addressing which is used for handling collision.

In this implementation the concept of linear probing has been used.

The hash table is searched sequentially from the original location of the
hash, if the new hash/location we get is already occupied we check for the next
hash/location.

references:
    - https://en.wikipedia.org/wiki/Linear_probing

Examples:
1. The collision will be with keys 18 & 99, so new hash will be created for 99
>>> ht = HashTable(3)
>>> ht.insert_data(17)
>>> ht.insert_data(18)
>>> ht.insert_data(99)
>>> ht.keys()
{2: 17, 0: 18, 1: 99}

2. The collision will be with keys 17 & 101, so new hash
will be created for 101
>>> ht = HashTable(4)
>>> ht.insert_data(17)
>>> ht.insert_data(18)
>>> ht.insert_data(99)
>>> ht.insert_data(101)
>>> ht.keys()
{1: 17, 2: 18, 3: 99, 0: 101}

2. The collision will be with all keys, so new hash will be created for all
>>> ht = HashTable(1)
>>> ht.insert_data(17)
>>> ht.insert_data(18)
>>> ht.insert_data(99)
>>> ht.keys()
{2: 17, 3: 18, 4: 99}

3. Trying to insert float key in hash
>>> ht = HashTable(1)
>>> ht.insert_data(17)
>>> ht.insert_data(18)
>>> ht.insert_data(99.99)
Traceback (most recent call last):
...
TypeError: list indices must be integers or slices, not float
 - Function 'rehashing' takes 1 arguments: self.  No docstring available.
 - Function 'insert_data' takes 2 arguments: self, data.  Docstring: insert_data is used for inserting a single element at a time in the HashTable.

Examples:

>>> ht = HashTable(3)
>>> ht.insert_data(5)
>>> ht.keys()
{2: 5}
>>> ht = HashTable(5)
>>> ht.insert_data(30)
>>> ht.insert_data(50)
>>> ht.keys()
{0: 30, 1: 50}

File: hash_table_with_linked_list.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '_set_value' takes 3 arguments: self, key, data.  No docstring available.
 - Function 'balanced_factor' takes 1 arguments: self.  No docstring available.
 - Function '_collision_resolution' takes 3 arguments: self, key, data.  No docstring available.

File: quadratic_probing.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '_collision_resolution' takes 3 arguments: self, key, data.  Docstring: Quadratic probing is an open addressing scheme used for resolving
collisions in hash table.

It works by taking the original hash index and adding successive
values of an arbitrary quadratic polynomial until open slot is found.

Hash + 1, Hash + 2, Hash + 3 .... Hash + n

reference:
    - https://en.wikipedia.org/wiki/Quadratic_probing
e.g:
1. Create hash table with size 7
>>> qp = QuadraticProbing(7)
>>> qp.insert_data(90)
>>> qp.insert_data(340)
>>> qp.insert_data(24)
>>> qp.insert_data(45)
>>> qp.insert_data(99)
>>> qp.insert_data(73)
>>> qp.insert_data(7)
>>> qp.keys()
{11: 45, 14: 99, 7: 24, 0: 340, 5: 73, 6: 90, 8: 7}

2. Create hash table with size 8
>>> qp = QuadraticProbing(8)
>>> qp.insert_data(0)
>>> qp.insert_data(999)
>>> qp.insert_data(111)
>>> qp.keys()
{0: 0, 7: 999, 3: 111}

3. Try to add three data elements when the size is two
>>> qp =  QuadraticProbing(2)
>>> qp.insert_data(0)
>>> qp.insert_data(999)
>>> qp.insert_data(111)
>>> qp.keys()
{0: 0, 4: 999, 1: 111}

4. Try to add three data elements when the size is one
>>> qp =  QuadraticProbing(1)
>>> qp.insert_data(0)
>>> qp.insert_data(999)
>>> qp.insert_data(111)
>>> qp.keys()
{4: 999, 1: 111}

File: prime_numbers.py
 - Function 'slow_primes' takes 1 arguments: max_n.  Docstring: Return a list of all primes numbers up to max.
>>> list(slow_primes(0))
[]
>>> list(slow_primes(-1))
[]
>>> list(slow_primes(-10))
[]
>>> list(slow_primes(25))
[2, 3, 5, 7, 11, 13, 17, 19, 23]
>>> list(slow_primes(11))
[2, 3, 5, 7, 11]
>>> list(slow_primes(33))
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]
>>> list(slow_primes(1000))[-1]
997
 - Function 'primes' takes 1 arguments: max_n.  Docstring: Return a list of all primes numbers up to max.
>>> list(primes(0))
[]
>>> list(primes(-1))
[]
>>> list(primes(-10))
[]
>>> list(primes(25))
[2, 3, 5, 7, 11, 13, 17, 19, 23]
>>> list(primes(11))
[2, 3, 5, 7, 11]
>>> list(primes(33))
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]
>>> list(primes(1000))[-1]
997
 - Function 'fast_primes' takes 1 arguments: max_n.  Docstring: Return a list of all primes numbers up to max.
>>> list(fast_primes(0))
[]
>>> list(fast_primes(-1))
[]
>>> list(fast_primes(-10))
[]
>>> list(fast_primes(25))
[2, 3, 5, 7, 11, 13, 17, 19, 23]
>>> list(fast_primes(11))
[2, 3, 5, 7, 11]
>>> list(fast_primes(33))
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]
>>> list(fast_primes(1000))[-1]
997
 - Function 'benchmark' takes 0 arguments: .  Docstring: Let's benchmark our functions side-by-side...

File: test_hash_map.py
 - Function '_get' takes 1 arguments: k.  No docstring available.
 - Function '_set' takes 2 arguments: k, v.  No docstring available.
 - Function '_del' takes 1 arguments: k.  No docstring available.
 - Function '_run_operation' takes 2 arguments: obj, fun.  No docstring available.
 - Function 'test_hash_map_is_the_same_as_dict' takes 1 arguments: operations.  No docstring available.
 - Function 'test_no_new_methods_was_added_to_api' takes 0 arguments: .  No docstring available.
 - Function 'is_public' takes 1 arguments: name.  No docstring available.

File: binomial_heap.py
 - Function '__init__' takes 2 arguments: self, val.  No docstring available.
 - Function 'merge_trees' takes 2 arguments: self, other.  Docstring: In-place merge of two binomial trees of equal size.
Returns the root of the resulting tree
 - Function '__init__' takes 4 arguments: self, bottom_root, min_node, heap_size.  No docstring available.
 - Function 'merge_heaps' takes 2 arguments: self, other.  Docstring: In-place merge of two binomial heaps.
Both of them become the resulting merged heap
 - Function 'insert' takes 2 arguments: self, val.  Docstring: insert a value in the heap
 - Function 'peek' takes 1 arguments: self.  Docstring: return min element without deleting it
 - Function 'is_empty' takes 1 arguments: self.  No docstring available.
 - Function 'delete_min' takes 1 arguments: self.  Docstring: delete min element and return it
 - Function 'pre_order' takes 1 arguments: self.  Docstring: Returns the Pre-order representation of the heap including
values of nodes plus their level distance from the root;
Empty nodes appear as #
 - Function '__traversal' takes 4 arguments: self, curr_node, preorder, level.  Docstring: Pre-order traversal of nodes
 - Function '__str__' takes 1 arguments: self.  Docstring: Overwriting str for a pre-order print of nodes in heap;
Performance is poor, so use only for small examples

File: heap.py
 - Function '__lt__' takes 2 arguments: self, other.  No docstring available.
 - Function '__gt__' takes 2 arguments: self, other.  No docstring available.
 - Function '__eq__' takes 2 arguments: self, other.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function 'parent_index' takes 2 arguments: self, child_idx.  Docstring: returns the parent index based on the given child index

>>> h = Heap()
>>> h.build_max_heap([103, 9, 1, 7, 11, 15, 25, 201, 209, 107, 5])
>>> h
[209, 201, 25, 103, 107, 15, 1, 9, 7, 11, 5]

>>> h.parent_index(-1)  # returns none if index is <=0

>>> h.parent_index(0)   # returns none if index is <=0

>>> h.parent_index(1)
0
>>> h.parent_index(2)
0
>>> h.parent_index(3)
1
>>> h.parent_index(4)
1
>>> h.parent_index(5)
2
>>> h.parent_index(10.5)
4.0
>>> h.parent_index(209.0)
104.0
>>> h.parent_index("Test")
Traceback (most recent call last):
...
TypeError: '>' not supported between instances of 'str' and 'int'
 - Function 'left_child_idx' takes 2 arguments: self, parent_idx.  Docstring: return the left child index if the left child exists.
if not, return None.
 - Function 'right_child_idx' takes 2 arguments: self, parent_idx.  Docstring: return the right child index if the right child exists.
if not, return None.
 - Function 'max_heapify' takes 2 arguments: self, index.  Docstring: correct a single violation of the heap property in a subtree's root.

It is the function that is responsible for restoring the property
of Max heap i.e the maximum element is always at top.
 - Function 'build_max_heap' takes 2 arguments: self, collection.  Docstring: build max heap from an unsorted array

>>> h = Heap()
>>> h.build_max_heap([20,40,50,20,10])
>>> h
[50, 40, 20, 20, 10]

>>> h = Heap()
>>> h.build_max_heap([1,2,3,4,5,6,7,8,9,0])
>>> h
[9, 8, 7, 4, 5, 6, 3, 2, 1, 0]

>>> h = Heap()
>>> h.build_max_heap([514,5,61,57,8,99,105])
>>> h
[514, 57, 105, 5, 8, 99, 61]

>>> h = Heap()
>>> h.build_max_heap([514,5,61.6,57,8,9.9,105])
>>> h
[514, 57, 105, 5, 8, 9.9, 61.6]
 - Function 'extract_max' takes 1 arguments: self.  Docstring: get and remove max from heap

>>> h = Heap()
>>> h.build_max_heap([20,40,50,20,10])
>>> h.extract_max()
50

>>> h = Heap()
>>> h.build_max_heap([514,5,61,57,8,99,105])
>>> h.extract_max()
514

>>> h = Heap()
>>> h.build_max_heap([1,2,3,4,5,6,7,8,9,0])
>>> h.extract_max()
9
 - Function 'insert' takes 2 arguments: self, value.  Docstring: insert a new value into the max heap

>>> h = Heap()
>>> h.insert(10)
>>> h
[10]

>>> h = Heap()
>>> h.insert(10)
>>> h.insert(10)
>>> h
[10, 10]

>>> h = Heap()
>>> h.insert(10)
>>> h.insert(10.1)
>>> h
[10.1, 10]

>>> h = Heap()
>>> h.insert(0.1)
>>> h.insert(0)
>>> h.insert(9)
>>> h.insert(5)
>>> h
[9, 5, 0.1, 0]
 - Function 'heap_sort' takes 1 arguments: self.  No docstring available.

File: heap_generic.py
 - Function '__init__' takes 2 arguments: self, key.  No docstring available.
 - Function '_parent' takes 2 arguments: self, i.  Docstring: Returns parent index of given index if exists else None
 - Function '_left' takes 2 arguments: self, i.  Docstring: Returns left-child-index of given index if exists else None
 - Function '_right' takes 2 arguments: self, i.  Docstring: Returns right-child-index of given index if exists else None
 - Function '_swap' takes 3 arguments: self, i, j.  Docstring: Performs changes required for swapping two elements in the heap
 - Function '_cmp' takes 3 arguments: self, i, j.  Docstring: Compares the two items using default comparison
 - Function '_get_valid_parent' takes 2 arguments: self, i.  Docstring: Returns index of valid parent as per desired ordering among given index and
both it's children
 - Function '_heapify_up' takes 2 arguments: self, index.  Docstring: Fixes the heap in upward direction of given index
 - Function '_heapify_down' takes 2 arguments: self, index.  Docstring: Fixes the heap in downward direction of given index
 - Function 'update_item' takes 3 arguments: self, item, item_value.  Docstring: Updates given item value in heap if present
 - Function 'delete_item' takes 2 arguments: self, item.  Docstring: Deletes given item from heap if present
 - Function 'insert_item' takes 3 arguments: self, item, item_value.  Docstring: Inserts given item with given value in heap
 - Function 'get_top' takes 1 arguments: self.  Docstring: Returns top item tuple (Calculated value, item) from heap if present
 - Function 'extract_top' takes 1 arguments: self.  Docstring: Return top item tuple (Calculated value, item) from heap and removes it as well
if present
 - Function 'test_heap' takes 0 arguments: .  Docstring: >>> h = Heap()  # Max-heap
>>> h.insert_item(5, 34)
>>> h.insert_item(6, 31)
>>> h.insert_item(7, 37)
>>> h.get_top()
[7, 37]
>>> h.extract_top()
[7, 37]
>>> h.extract_top()
[5, 34]
>>> h.extract_top()
[6, 31]
>>> h = Heap(key=lambda x: -x)  # Min heap
>>> h.insert_item(5, 34)
>>> h.insert_item(6, 31)
>>> h.insert_item(7, 37)
>>> h.get_top()
[6, -31]
>>> h.extract_top()
[6, -31]
>>> h.extract_top()
[5, -34]
>>> h.extract_top()
[7, -37]
>>> h.insert_item(8, 45)
>>> h.insert_item(9, 40)
>>> h.insert_item(10, 50)
>>> h.get_top()
[9, -40]
>>> h.update_item(10, 30)
>>> h.get_top()
[10, -30]
>>> h.delete_item(10)
>>> h.get_top()
[9, -40]

File: max_heap.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__swap_up' takes 2 arguments: self, i.  Docstring: Swap the element up
 - Function 'insert' takes 2 arguments: self, value.  Docstring: Insert new element
 - Function '__swap_down' takes 2 arguments: self, i.  Docstring: Swap the element down
 - Function 'pop' takes 1 arguments: self.  Docstring: Pop the root element
 - Function 'get_list' takes 1 arguments: self.  No docstring available.
 - Function '__len__' takes 1 arguments: self.  Docstring: Length of the array

File: min_heap.py
 - Function '__init__' takes 3 arguments: self, name, val.  No docstring available.
 - Function '__str__' takes 1 arguments: self.  No docstring available.
 - Function '__lt__' takes 2 arguments: self, other.  No docstring available.
 - Function '__init__' takes 2 arguments: self, array.  No docstring available.
 - Function '__getitem__' takes 2 arguments: self, key.  No docstring available.
 - Function 'get_parent_idx' takes 2 arguments: self, idx.  No docstring available.
 - Function 'get_left_child_idx' takes 2 arguments: self, idx.  No docstring available.
 - Function 'get_right_child_idx' takes 2 arguments: self, idx.  No docstring available.
 - Function 'get_value' takes 2 arguments: self, key.  No docstring available.
 - Function 'build_heap' takes 2 arguments: self, array.  No docstring available.
 - Function 'sift_down' takes 3 arguments: self, idx, array.  No docstring available.
 - Function 'sift_up' takes 2 arguments: self, idx.  No docstring available.
 - Function 'peek' takes 1 arguments: self.  No docstring available.
 - Function 'remove' takes 1 arguments: self.  No docstring available.
 - Function 'insert' takes 2 arguments: self, node.  No docstring available.
 - Function 'is_empty' takes 1 arguments: self.  No docstring available.
 - Function 'decrease_key' takes 3 arguments: self, node, new_value.  No docstring available.

File: randomized_heap.py
 - Function '__init__' takes 2 arguments: self, value.  No docstring available.
 - Function 'value' takes 1 arguments: self.  Docstring: Return the value of the node.

>>> rhn = RandomizedHeapNode(10)
>>> rhn.value
10
>>> rhn = RandomizedHeapNode(-10)
>>> rhn.value
-10
 - Function 'merge' takes 2 arguments: root1, root2.  Docstring: Merge 2 nodes together.

>>> rhn1 = RandomizedHeapNode(10)
>>> rhn2 = RandomizedHeapNode(20)
>>> RandomizedHeapNode.merge(rhn1, rhn2).value
10

>>> rhn1 = RandomizedHeapNode(20)
>>> rhn2 = RandomizedHeapNode(10)
>>> RandomizedHeapNode.merge(rhn1, rhn2).value
10

>>> rhn1 = RandomizedHeapNode(5)
>>> rhn2 = RandomizedHeapNode(0)
>>> RandomizedHeapNode.merge(rhn1, rhn2).value
0
 - Function '__init__' takes 2 arguments: self, data.  Docstring: >>> rh = RandomizedHeap([3, 1, 3, 7])
>>> rh.to_sorted_list()
[1, 3, 3, 7]
 - Function 'insert' takes 2 arguments: self, value.  Docstring: Insert the value into the heap.

>>> rh = RandomizedHeap()
>>> rh.insert(3)
>>> rh.insert(1)
>>> rh.insert(3)
>>> rh.insert(7)
>>> rh.to_sorted_list()
[1, 3, 3, 7]
 - Function 'pop' takes 1 arguments: self.  Docstring: Pop the smallest value from the heap and return it.

>>> rh = RandomizedHeap([3, 1, 3, 7])
>>> rh.pop()
1
>>> rh.pop()
3
>>> rh.pop()
3
>>> rh.pop()
7
>>> rh.pop()
Traceback (most recent call last):
    ...
IndexError: Can't get top element for the empty heap.
 - Function 'top' takes 1 arguments: self.  Docstring: Return the smallest value from the heap.

>>> rh = RandomizedHeap()
>>> rh.insert(3)
>>> rh.top()
3
>>> rh.insert(1)
>>> rh.top()
1
>>> rh.insert(3)
>>> rh.top()
1
>>> rh.insert(7)
>>> rh.top()
1
 - Function 'clear' takes 1 arguments: self.  Docstring: Clear the heap.

>>> rh = RandomizedHeap([3, 1, 3, 7])
>>> rh.clear()
>>> rh.pop()
Traceback (most recent call last):
    ...
IndexError: Can't get top element for the empty heap.
 - Function 'to_sorted_list' takes 1 arguments: self.  Docstring: Returns sorted list containing all the values in the heap.

>>> rh = RandomizedHeap([3, 1, 3, 7])
>>> rh.to_sorted_list()
[1, 3, 3, 7]
 - Function '__bool__' takes 1 arguments: self.  Docstring: Check if the heap is not empty.

>>> rh = RandomizedHeap()
>>> bool(rh)
False
>>> rh.insert(1)
>>> bool(rh)
True
>>> rh.clear()
>>> bool(rh)
False

File: skew_heap.py
 - Function '__init__' takes 2 arguments: self, value.  No docstring available.
 - Function 'value' takes 1 arguments: self.  Docstring: Return the value of the node.

>>> SkewNode(0).value
0
>>> SkewNode(3.14159).value
3.14159
>>> SkewNode("hello").value
'hello'
>>> SkewNode(None).value

>>> SkewNode(True).value
True
>>> SkewNode([]).value
[]
>>> SkewNode({}).value
{}
>>> SkewNode(set()).value
set()
>>> SkewNode(0.0).value
0.0
>>> SkewNode(-1e-10).value
-1e-10
>>> SkewNode(10).value
10
>>> SkewNode(-10.5).value
-10.5
>>> SkewNode().value
Traceback (most recent call last):
...
TypeError: SkewNode.__init__() missing 1 required positional argument: 'value'
 - Function 'merge' takes 2 arguments: root1, root2.  Docstring: Merge 2 nodes together.
>>> SkewNode.merge(SkewNode(10),SkewNode(-10.5)).value
-10.5
>>> SkewNode.merge(SkewNode(10),SkewNode(10.5)).value
10
>>> SkewNode.merge(SkewNode(10),SkewNode(10)).value
10
>>> SkewNode.merge(SkewNode(-100),SkewNode(-10.5)).value
-100
 - Function '__init__' takes 2 arguments: self, data.  Docstring: >>> sh = SkewHeap([3, 1, 3, 7])
>>> list(sh)
[1, 3, 3, 7]
 - Function '__bool__' takes 1 arguments: self.  Docstring: Check if the heap is not empty.

>>> sh = SkewHeap()
>>> bool(sh)
False
>>> sh.insert(1)
>>> bool(sh)
True
>>> sh.clear()
>>> bool(sh)
False
 - Function '__iter__' takes 1 arguments: self.  Docstring: Returns sorted list containing all the values in the heap.

>>> sh = SkewHeap([3, 1, 3, 7])
>>> list(sh)
[1, 3, 3, 7]
 - Function 'insert' takes 2 arguments: self, value.  Docstring: Insert the value into the heap.

>>> sh = SkewHeap()
>>> sh.insert(3)
>>> sh.insert(1)
>>> sh.insert(3)
>>> sh.insert(7)
>>> list(sh)
[1, 3, 3, 7]
 - Function 'pop' takes 1 arguments: self.  Docstring: Pop the smallest value from the heap and return it.

>>> sh = SkewHeap([3, 1, 3, 7])
>>> sh.pop()
1
>>> sh.pop()
3
>>> sh.pop()
3
>>> sh.pop()
7
>>> sh.pop()
Traceback (most recent call last):
    ...
IndexError: Can't get top element for the empty heap.
 - Function 'top' takes 1 arguments: self.  Docstring: Return the smallest value from the heap.

>>> sh = SkewHeap()
>>> sh.insert(3)
>>> sh.top()
3
>>> sh.insert(1)
>>> sh.top()
1
>>> sh.insert(3)
>>> sh.top()
1
>>> sh.insert(7)
>>> sh.top()
1
 - Function 'clear' takes 1 arguments: self.  Docstring: Clear the heap.

>>> sh = SkewHeap([3, 1, 3, 7])
>>> sh.clear()
>>> sh.pop()
Traceback (most recent call last):
    ...
IndexError: Can't get top element for the empty heap.

File: build_kdtree.py
 - Function 'build_kdtree' takes 2 arguments: points, depth.  Docstring: Builds a KD-Tree from a list of points.

Args:
    points: The list of points to build the KD-Tree from.
    depth: The current depth in the tree
                 (used to determine axis for splitting).

Returns:
    The root node of the KD-Tree,
                   or None if no points are provided.

File: kd_node.py
 - Function '__init__' takes 4 arguments: self, point, left, right.  Docstring: Initializes a KDNode with the given point and child nodes.

Args:
    point (list[float]): The point stored in this node.
    left (Optional[KDNode]): The left child node.
    right (Optional[KDNode]): The right child node.

File: nearest_neighbour_search.py
 - Function 'nearest_neighbour_search' takes 2 arguments: root, query_point.  Docstring: Performs a nearest neighbor search in a KD-Tree for a given query point.

Args:
    root (KDNode | None): The root node of the KD-Tree.
    query_point (list[float]): The point for which the nearest neighbor
                                is being searched.

Returns:
    tuple[list[float] | None, float, int]:
        - The nearest point found in the KD-Tree to the query point,
          or None if no point is found.
        - The squared distance to the nearest point.
        - The number of nodes visited during the search.
 - Function 'search' takes 2 arguments: node, depth.  Docstring: Recursively searches for the nearest neighbor in the KD-Tree.

Args:
    node: The current node in the KD-Tree.
    depth: The current depth in the KD-Tree.

File: example_usage.py
 - Function 'main' takes 0 arguments: .  Docstring: Demonstrates the use of KD-Tree by building it from random points
in a 10-dimensional hypercube and performing a nearest neighbor search.

File: hypercube_points.py
 - Function 'hypercube_points' takes 3 arguments: num_points, hypercube_size, num_dimensions.  Docstring: Generates random points uniformly distributed within an n-dimensional hypercube.

Args:
    num_points: Number of points to generate.
    hypercube_size: Size of the hypercube.
    num_dimensions: Number of dimensions of the hypercube.

Returns:
    An array of shape (num_points, num_dimensions)
                with generated points.

File: test_kdtree.py
 - Function 'test_build_kdtree' takes 5 arguments: num_points, cube_size, num_dimensions, depth, expected_result.  Docstring: Test that KD-Tree is built correctly.

Cases:
    - Empty points list.
    - Positive depth value.
    - Negative depth value.
 - Function 'test_nearest_neighbour_search' takes 0 arguments: .  Docstring: Test the nearest neighbor search function.
 - Function 'test_edge_cases' takes 0 arguments: .  Docstring: Test edge cases such as an empty KD-Tree.

File: circular_linked_list.py
 - Function '__iter__' takes 1 arguments: self.  Docstring: Iterate through all nodes in the Circular Linked List yielding their data.
Yields:
    The data of each node in the linked list.
 - Function '__len__' takes 1 arguments: self.  Docstring: Get the length (number of nodes) in the Circular Linked List.
 - Function '__repr__' takes 1 arguments: self.  Docstring: Generate a string representation of the Circular Linked List.
Returns:
    A string of the format "1->2->....->N".
 - Function 'insert_tail' takes 2 arguments: self, data.  Docstring: Insert a node with the given data at the end of the Circular Linked List.
 - Function 'insert_head' takes 2 arguments: self, data.  Docstring: Insert a node with the given data at the beginning of the Circular Linked List.
 - Function 'insert_nth' takes 3 arguments: self, index, data.  Docstring: Insert the data of the node at the nth pos in the Circular Linked List.
Args:
    index: The index at which the data should be inserted.
    data: The data to be inserted.

Raises:
    IndexError: If the index is out of range.
 - Function 'delete_front' takes 1 arguments: self.  Docstring: Delete and return the data of the node at the front of the Circular Linked List.
Raises:
    IndexError: If the list is empty.
 - Function 'delete_tail' takes 1 arguments: self.  Docstring: Delete and return the data of the node at the end of the Circular Linked List.
Returns:
    Any: The data of the deleted node.
Raises:
    IndexError: If the index is out of range.
 - Function 'delete_nth' takes 2 arguments: self, index.  Docstring: Delete and return the data of the node at the nth pos in Circular Linked List.
Args:
    index (int): The index of the node to be deleted. Defaults to 0.
Returns:
    Any: The data of the deleted node.
Raises:
    IndexError: If the index is out of range.
 - Function 'is_empty' takes 1 arguments: self.  Docstring: Check if the Circular Linked List is empty.
Returns:
    bool: True if the list is empty, False otherwise.
 - Function 'test_circular_linked_list' takes 0 arguments: .  Docstring: Test cases for the CircularLinkedList class.
>>> test_circular_linked_list()

File: deque_doubly.py
 - Function '__init__' takes 4 arguments: self, link_p, element, link_n.  No docstring available.
 - Function 'has_next_and_prev' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__len__' takes 1 arguments: self.  No docstring available.
 - Function 'is_empty' takes 1 arguments: self.  No docstring available.
 - Function '_insert' takes 4 arguments: self, predecessor, e, successor.  No docstring available.
 - Function '_delete' takes 2 arguments: self, node.  No docstring available.
 - Function 'first' takes 1 arguments: self.  Docstring: return first element
>>> d = LinkedDeque()
>>> d.add_first('A').first()
'A'
>>> d.add_first('B').first()
'B'
 - Function 'last' takes 1 arguments: self.  Docstring: return last element
>>> d = LinkedDeque()
>>> d.add_last('A').last()
'A'
>>> d.add_last('B').last()
'B'
 - Function 'add_first' takes 2 arguments: self, element.  Docstring: insertion in the front
>>> LinkedDeque().add_first('AV').first()
'AV'
 - Function 'add_last' takes 2 arguments: self, element.  Docstring: insertion in the end
>>> LinkedDeque().add_last('B').last()
'B'
 - Function 'remove_first' takes 1 arguments: self.  Docstring: removal from the front
>>> d = LinkedDeque()
>>> d.is_empty()
True
>>> d.remove_first()
Traceback (most recent call last):
   ...
IndexError: remove_first from empty list
>>> d.add_first('A') # doctest: +ELLIPSIS
<data_structures.linked_list.deque_doubly.LinkedDeque object at ...
>>> d.remove_first()
'A'
>>> d.is_empty()
True
 - Function 'remove_last' takes 1 arguments: self.  Docstring: removal in the end
>>> d = LinkedDeque()
>>> d.is_empty()
True
>>> d.remove_last()
Traceback (most recent call last):
   ...
IndexError: remove_first from empty list
>>> d.add_first('A') # doctest: +ELLIPSIS
<data_structures.linked_list.deque_doubly.LinkedDeque object at ...
>>> d.remove_last()
'A'
>>> d.is_empty()
True

File: doubly_linked_list.py
 - Function '__init__' takes 2 arguments: self, data.  No docstring available.
 - Function '__str__' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__iter__' takes 1 arguments: self.  Docstring: >>> linked_list = DoublyLinkedList()
>>> linked_list.insert_at_head('b')
>>> linked_list.insert_at_head('a')
>>> linked_list.insert_at_tail('c')
>>> tuple(linked_list)
('a', 'b', 'c')
 - Function '__str__' takes 1 arguments: self.  Docstring: >>> linked_list = DoublyLinkedList()
>>> linked_list.insert_at_tail('a')
>>> linked_list.insert_at_tail('b')
>>> linked_list.insert_at_tail('c')
>>> str(linked_list)
'a->b->c'
 - Function '__len__' takes 1 arguments: self.  Docstring: >>> linked_list = DoublyLinkedList()
>>> for i in range(0, 5):
...     linked_list.insert_at_nth(i, i + 1)
>>> len(linked_list) == 5
True
 - Function 'insert_at_head' takes 2 arguments: self, data.  No docstring available.
 - Function 'insert_at_tail' takes 2 arguments: self, data.  No docstring available.
 - Function 'insert_at_nth' takes 3 arguments: self, index, data.  Docstring: >>> linked_list = DoublyLinkedList()
>>> linked_list.insert_at_nth(-1, 666)
Traceback (most recent call last):
    ....
IndexError: list index out of range
>>> linked_list.insert_at_nth(1, 666)
Traceback (most recent call last):
    ....
IndexError: list index out of range
>>> linked_list.insert_at_nth(0, 2)
>>> linked_list.insert_at_nth(0, 1)
>>> linked_list.insert_at_nth(2, 4)
>>> linked_list.insert_at_nth(2, 3)
>>> str(linked_list)
'1->2->3->4'
>>> linked_list.insert_at_nth(5, 5)
Traceback (most recent call last):
    ....
IndexError: list index out of range
 - Function 'delete_head' takes 1 arguments: self.  No docstring available.
 - Function 'delete_tail' takes 1 arguments: self.  No docstring available.
 - Function 'delete_at_nth' takes 2 arguments: self, index.  Docstring: >>> linked_list = DoublyLinkedList()
>>> linked_list.delete_at_nth(0)
Traceback (most recent call last):
    ....
IndexError: list index out of range
>>> for i in range(0, 5):
...     linked_list.insert_at_nth(i, i + 1)
>>> linked_list.delete_at_nth(0) == 1
True
>>> linked_list.delete_at_nth(3) == 5
True
>>> linked_list.delete_at_nth(1) == 3
True
>>> str(linked_list)
'2->4'
>>> linked_list.delete_at_nth(2)
Traceback (most recent call last):
    ....
IndexError: list index out of range
 - Function 'delete' takes 2 arguments: self, data.  No docstring available.
 - Function 'is_empty' takes 1 arguments: self.  Docstring: >>> linked_list = DoublyLinkedList()
>>> linked_list.is_empty()
True
>>> linked_list.insert_at_tail(1)
>>> linked_list.is_empty()
False
 - Function 'test_doubly_linked_list' takes 0 arguments: .  Docstring: >>> test_doubly_linked_list()

File: doubly_linked_list_two.py
 - Function '__init__' takes 4 arguments: self, data, previous, next_node.  No docstring available.
 - Function '__str__' takes 1 arguments: self.  No docstring available.
 - Function 'get_data' takes 1 arguments: self.  No docstring available.
 - Function 'get_next' takes 1 arguments: self.  No docstring available.
 - Function 'get_previous' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 2 arguments: self, head.  No docstring available.
 - Function '__iter__' takes 1 arguments: self.  No docstring available.
 - Function '__next__' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__str__' takes 1 arguments: self.  No docstring available.
 - Function '__contains__' takes 2 arguments: self, value.  No docstring available.
 - Function '__iter__' takes 1 arguments: self.  No docstring available.
 - Function 'get_head_data' takes 1 arguments: self.  No docstring available.
 - Function 'get_tail_data' takes 1 arguments: self.  No docstring available.
 - Function 'set_head' takes 2 arguments: self, node.  No docstring available.
 - Function 'set_tail' takes 2 arguments: self, node.  No docstring available.
 - Function 'insert' takes 2 arguments: self, value.  No docstring available.
 - Function 'insert_before_node' takes 3 arguments: self, node, node_to_insert.  No docstring available.
 - Function 'insert_after_node' takes 3 arguments: self, node, node_to_insert.  No docstring available.
 - Function 'insert_at_position' takes 3 arguments: self, position, value.  No docstring available.
 - Function 'get_node' takes 2 arguments: self, item.  No docstring available.
 - Function 'delete_value' takes 2 arguments: self, value.  No docstring available.
 - Function 'remove_node_pointers' takes 1 arguments: node.  No docstring available.
 - Function 'is_empty' takes 1 arguments: self.  No docstring available.
 - Function 'create_linked_list' takes 0 arguments: .  Docstring: >>> new_linked_list = LinkedList()
>>> new_linked_list.get_head_data() is None
True
>>> new_linked_list.get_tail_data() is None
True
>>> new_linked_list.is_empty()
True
>>> new_linked_list.insert(10)
>>> new_linked_list.get_head_data()
10
>>> new_linked_list.get_tail_data()
10
>>> new_linked_list.insert_at_position(position=3, value=20)
>>> new_linked_list.get_head_data()
10
>>> new_linked_list.get_tail_data()
20
>>> new_linked_list.set_head(Node(1000))
>>> new_linked_list.get_head_data()
1000
>>> new_linked_list.get_tail_data()
20
>>> new_linked_list.set_tail(Node(2000))
>>> new_linked_list.get_head_data()
1000
>>> new_linked_list.get_tail_data()
2000
>>> for value in new_linked_list:
...    print(value)
1000
10
20
2000
>>> new_linked_list.is_empty()
False
>>> for value in new_linked_list:
...    print(value)
1000
10
20
2000
>>> 10 in new_linked_list
True
>>> new_linked_list.delete_value(value=10)
>>> 10 in new_linked_list
False
>>> new_linked_list.delete_value(value=2000)
>>> new_linked_list.get_tail_data()
20
>>> new_linked_list.delete_value(value=1000)
>>> new_linked_list.get_tail_data()
20
>>> new_linked_list.get_head_data()
20
>>> for value in new_linked_list:
...    print(value)
20
>>> new_linked_list.delete_value(value=20)
>>> for value in new_linked_list:
...    print(value)
>>> for value in range(1,10):
...    new_linked_list.insert(value=value)
>>> for value in new_linked_list:
...    print(value)
1
2
3
4
5
6
7
8
9

File: floyds_cycle_detection.py
 - Function '__iter__' takes 1 arguments: self.  Docstring: Iterates through the linked list.

Returns:
    Iterator: An iterator over the linked list.

Examples:
>>> linked_list = LinkedList()
>>> list(linked_list)
[]
>>> linked_list.add_node(1)
>>> tuple(linked_list)
(1,)
 - Function 'add_node' takes 2 arguments: self, data.  Docstring: Adds a new node to the end of the linked list.

Args:
    data (Any): The data to be stored in the new node.

Examples:
>>> linked_list = LinkedList()
>>> linked_list.add_node(1)
>>> linked_list.add_node(2)
>>> linked_list.add_node(3)
>>> linked_list.add_node(4)
>>> tuple(linked_list)
(1, 2, 3, 4)
 - Function 'detect_cycle' takes 1 arguments: self.  Docstring: Detects if there is a cycle in the linked list using
Floyd's cycle detection algorithm.

Returns:
    bool: True if there is a cycle, False otherwise.

Examples:
>>> linked_list = LinkedList()
>>> linked_list.add_node(1)
>>> linked_list.add_node(2)
>>> linked_list.add_node(3)
>>> linked_list.add_node(4)

>>> linked_list.detect_cycle()
False

# Create a cycle in the linked list
>>> linked_list.head.next_node.next_node.next_node = linked_list.head.next_node

>>> linked_list.detect_cycle()
True

File: from_sequence.py
 - Function '__init__' takes 2 arguments: self, data.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  Docstring: Returns a visual representation of the node and all its following nodes.
 - Function 'make_linked_list' takes 1 arguments: elements_list.  Docstring: Creates a Linked List from the elements of the given sequence
(list/tuple) and returns the head of the Linked List.

File: has_loop.py
 - Function '__init__' takes 2 arguments: self, data.  No docstring available.
 - Function '__iter__' takes 1 arguments: self.  No docstring available.
 - Function 'has_loop' takes 1 arguments: self.  Docstring: A loop is when the exact same Node appears more than once in a linked list.
>>> root_node = Node(1)
>>> root_node.next_node = Node(2)
>>> root_node.next_node.next_node = Node(3)
>>> root_node.next_node.next_node.next_node = Node(4)
>>> root_node.has_loop
False
>>> root_node.next_node.next_node.next_node = root_node.next_node
>>> root_node.has_loop
True

File: is_palindrome.py
 - Function 'is_palindrome' takes 1 arguments: head.  Docstring: Check if a linked list is a palindrome.

Args:
    head: The head of the linked list.

Returns:
    bool: True if the linked list is a palindrome, False otherwise.

Examples:
    >>> is_palindrome(None)
    True

    >>> is_palindrome(ListNode(1))
    True

    >>> is_palindrome(ListNode(1, ListNode(2)))
    False

    >>> is_palindrome(ListNode(1, ListNode(2, ListNode(1))))
    True

    >>> is_palindrome(ListNode(1, ListNode(2, ListNode(2, ListNode(1)))))
    True
 - Function 'is_palindrome_stack' takes 1 arguments: head.  Docstring: Check if a linked list is a palindrome using a stack.

Args:
    head (ListNode): The head of the linked list.

Returns:
    bool: True if the linked list is a palindrome, False otherwise.

Examples:
    >>> is_palindrome_stack(None)
    True

    >>> is_palindrome_stack(ListNode(1))
    True

    >>> is_palindrome_stack(ListNode(1, ListNode(2)))
    False

    >>> is_palindrome_stack(ListNode(1, ListNode(2, ListNode(1))))
    True

    >>> is_palindrome_stack(ListNode(1, ListNode(2, ListNode(2, ListNode(1)))))
    True
 - Function 'is_palindrome_dict' takes 1 arguments: head.  Docstring: Check if a linked list is a palindrome using a dictionary.

Args:
    head (ListNode): The head of the linked list.

Returns:
    bool: True if the linked list is a palindrome, False otherwise.

Examples:
    >>> is_palindrome_dict(None)
    True

    >>> is_palindrome_dict(ListNode(1))
    True

    >>> is_palindrome_dict(ListNode(1, ListNode(2)))
    False

    >>> is_palindrome_dict(ListNode(1, ListNode(2, ListNode(1))))
    True

    >>> is_palindrome_dict(ListNode(1, ListNode(2, ListNode(2, ListNode(1)))))
    True

    >>> is_palindrome_dict(
    ...     ListNode(
    ...         1, ListNode(2, ListNode(1, ListNode(3, ListNode(2, ListNode(1)))))
    ...     )
    ... )
    False

File: merge_two_lists.py
 - Function '__init__' takes 2 arguments: self, ints.  No docstring available.
 - Function '__iter__' takes 1 arguments: self.  Docstring: >>> tuple(SortedLinkedList(test_data_odd)) == tuple(sorted(test_data_odd))
True
>>> tuple(SortedLinkedList(test_data_even)) == tuple(sorted(test_data_even))
True
 - Function '__len__' takes 1 arguments: self.  Docstring: >>> for i in range(3):
...     len(SortedLinkedList(range(i))) == i
True
True
True
>>> len(SortedLinkedList(test_data_odd))
8
 - Function '__str__' takes 1 arguments: self.  Docstring: >>> str(SortedLinkedList([]))
''
>>> str(SortedLinkedList(test_data_odd))
'-11 -> -1 -> 0 -> 1 -> 3 -> 5 -> 7 -> 9'
>>> str(SortedLinkedList(test_data_even))
'-2 -> 0 -> 2 -> 3 -> 4 -> 6 -> 8 -> 10'
 - Function 'merge_lists' takes 2 arguments: sll_one, sll_two.  Docstring: >>> SSL = SortedLinkedList
>>> merged = merge_lists(SSL(test_data_odd), SSL(test_data_even))
>>> len(merged)
16
>>> str(merged)
'-11 -> -2 -> -1 -> 0 -> 0 -> 1 -> 2 -> 3 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10'
>>> list(merged) == list(sorted(test_data_odd + test_data_even))
True

File: middle_element_of_linked_list.py
 - Function '__init__' takes 2 arguments: self, data.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'push' takes 2 arguments: self, new_data.  No docstring available.
 - Function 'middle_element' takes 1 arguments: self.  Docstring: >>> link = LinkedList()
>>> link.middle_element()
No element found.
>>> link.push(5)
5
>>> link.push(6)
6
>>> link.push(8)
8
>>> link.push(8)
8
>>> link.push(10)
10
>>> link.push(12)
12
>>> link.push(17)
17
>>> link.push(7)
7
>>> link.push(3)
3
>>> link.push(20)
20
>>> link.push(-20)
-20
>>> link.middle_element()
12
>>>

File: print_reverse.py
 - Function '__init__' takes 1 arguments: self.  Docstring: Initialize a LinkedList with the head node set to None.
>>> linked_list = LinkedList()
>>> (linked_list.head, linked_list.tail)
(None, None)
 - Function '__iter__' takes 1 arguments: self.  Docstring: Iterate the LinkedList yielding each Node's data.
>>> linked_list = LinkedList()
>>> items = (1, 2, 3, 4, 5)
>>> linked_list.extend(items)
>>> tuple(linked_list) == items
True
 - Function '__repr__' takes 1 arguments: self.  Docstring: Returns a string representation of the LinkedList.
>>> linked_list = LinkedList()
>>> str(linked_list)
''
>>> linked_list.append(1)
>>> str(linked_list)
'1'
>>> linked_list.extend([2, 3, 4, 5])
>>> str(linked_list)
'1 -> 2 -> 3 -> 4 -> 5'
 - Function 'append' takes 2 arguments: self, data.  Docstring: Appends a new node with the given data to the end of the LinkedList.
>>> linked_list = LinkedList()
>>> str(linked_list)
''
>>> linked_list.append(1)
>>> str(linked_list)
'1'
>>> linked_list.append(2)
>>> str(linked_list)
'1 -> 2'
 - Function 'extend' takes 2 arguments: self, items.  Docstring: Appends each item to the end of the LinkedList.
>>> linked_list = LinkedList()
>>> linked_list.extend([])
>>> str(linked_list)
''
>>> linked_list.extend([1, 2])
>>> str(linked_list)
'1 -> 2'
>>> linked_list.extend([3,4])
>>> str(linked_list)
'1 -> 2 -> 3 -> 4'
 - Function 'make_linked_list' takes 1 arguments: elements_list.  Docstring: Creates a Linked List from the elements of the given sequence
(list/tuple) and returns the head of the Linked List.
>>> make_linked_list([])
Traceback (most recent call last):
    ...
Exception: The Elements List is empty
>>> make_linked_list([7])
7
>>> make_linked_list(['abc'])
abc
>>> make_linked_list([7, 25])
7 -> 25
 - Function 'in_reverse' takes 1 arguments: linked_list.  Docstring: Prints the elements of the given Linked List in reverse order
>>> in_reverse(LinkedList())
''
>>> in_reverse(make_linked_list([69, 88, 73]))
'73 <- 88 <- 69'

File: reverse_k_group.py
 - Function '__init__' takes 2 arguments: self, ints.  No docstring available.
 - Function '__iter__' takes 1 arguments: self.  Docstring: >>> ints = []
>>> list(LinkedList(ints)) == ints
True
>>> ints = tuple(range(5))
>>> tuple(LinkedList(ints)) == ints
True
 - Function '__len__' takes 1 arguments: self.  Docstring: >>> for i in range(3):
...     len(LinkedList(range(i))) == i
True
True
True
>>> len(LinkedList("abcdefgh"))
8
 - Function '__str__' takes 1 arguments: self.  Docstring: >>> str(LinkedList([]))
''
>>> str(LinkedList(range(5)))
'0 -> 1 -> 2 -> 3 -> 4'
 - Function 'append' takes 2 arguments: self, data.  Docstring: >>> ll = LinkedList([1, 2])
>>> tuple(ll)
(1, 2)
>>> ll.append(3)
>>> tuple(ll)
(1, 2, 3)
>>> ll.append(4)
>>> tuple(ll)
(1, 2, 3, 4)
>>> len(ll)
4
 - Function 'reverse_k_nodes' takes 2 arguments: self, group_size.  Docstring: reverse nodes within groups of size k
>>> ll = LinkedList([1, 2, 3, 4, 5])
>>> ll.reverse_k_nodes(2)
>>> tuple(ll)
(2, 1, 4, 3, 5)
>>> str(ll)
'2 -> 1 -> 4 -> 3 -> 5'

File: rotate_to_the_right.py
 - Function 'print_linked_list' takes 1 arguments: head.  Docstring:     Print the entire linked list iteratively.

    This function prints the elements of a linked list separated by '->'.

    Parameters:
        head (Node | None): The head of the linked list to be printed,
or None if the linked list is empty.

    >>> head = insert_node(None, 0)
    >>> head = insert_node(head, 2)
    >>> head = insert_node(head, 1)
    >>> print_linked_list(head)
    0->2->1
    >>> head = insert_node(head, 4)
    >>> head = insert_node(head, 5)
    >>> print_linked_list(head)
    0->2->1->4->5
 - Function 'insert_node' takes 2 arguments: head, data.  Docstring: Insert a new node at the end of a linked list and return the new head.

Parameters:
    head (Node | None): The head of the linked list.
    data (int): The data to be inserted into the new node.

Returns:
    Node: The new head of the linked list.

>>> head = insert_node(None, 10)
>>> head = insert_node(head, 9)
>>> head = insert_node(head, 8)
>>> print_linked_list(head)
10->9->8
 - Function 'rotate_to_the_right' takes 2 arguments: head, places.  Docstring: Rotate a linked list to the right by places times.

Parameters:
    head: The head of the linked list.
    places: The number of places to rotate.

Returns:
    Node: The head of the rotated linked list.

>>> rotate_to_the_right(None, places=1)
Traceback (most recent call last):
    ...
ValueError: The linked list is empty.
>>> head = insert_node(None, 1)
>>> rotate_to_the_right(head, places=1) == head
True
>>> head = insert_node(None, 1)
>>> head = insert_node(head, 2)
>>> head = insert_node(head, 3)
>>> head = insert_node(head, 4)
>>> head = insert_node(head, 5)
>>> new_head = rotate_to_the_right(head, places=2)
>>> print_linked_list(new_head)
4->5->1->2->3

File: singly_linked_list.py
 - Function '__repr__' takes 1 arguments: self.  Docstring: Get the string representation of this node.
>>> Node(10).__repr__()
'Node(10)'
>>> repr(Node(10))
'Node(10)'
>>> str(Node(10))
'Node(10)'
>>> Node(10)
Node(10)
 - Function '__init__' takes 1 arguments: self.  Docstring: Create and initialize LinkedList class instance.
>>> linked_list = LinkedList()
>>> linked_list.head is None
True
 - Function '__iter__' takes 1 arguments: self.  Docstring: This function is intended for iterators to access
and iterate through data inside linked list.
>>> linked_list = LinkedList()
>>> linked_list.insert_tail("tail")
>>> linked_list.insert_tail("tail_1")
>>> linked_list.insert_tail("tail_2")
>>> for node in linked_list: # __iter__ used here.
...     node
'tail'
'tail_1'
'tail_2'
 - Function '__len__' takes 1 arguments: self.  Docstring: Return length of linked list i.e. number of nodes
>>> linked_list = LinkedList()
>>> len(linked_list)
0
>>> linked_list.insert_tail("tail")
>>> len(linked_list)
1
>>> linked_list.insert_head("head")
>>> len(linked_list)
2
>>> _ = linked_list.delete_tail()
>>> len(linked_list)
1
>>> _ = linked_list.delete_head()
>>> len(linked_list)
0
 - Function '__repr__' takes 1 arguments: self.  Docstring: String representation/visualization of a Linked Lists
>>> linked_list = LinkedList()
>>> linked_list.insert_tail(1)
>>> linked_list.insert_tail(3)
>>> linked_list.__repr__()
'1 -> 3'
>>> repr(linked_list)
'1 -> 3'
>>> str(linked_list)
'1 -> 3'
>>> linked_list.insert_tail(5)
>>> f"{linked_list}"
'1 -> 3 -> 5'
 - Function '__getitem__' takes 2 arguments: self, index.  Docstring: Indexing Support. Used to get a node at particular position
>>> linked_list = LinkedList()
>>> for i in range(0, 10):
...     linked_list.insert_nth(i, i)
>>> all(str(linked_list[i]) == str(i) for i in range(0, 10))
True
>>> linked_list[-10]
Traceback (most recent call last):
    ...
ValueError: list index out of range.
>>> linked_list[len(linked_list)]
Traceback (most recent call last):
    ...
ValueError: list index out of range.
 - Function '__setitem__' takes 3 arguments: self, index, data.  Docstring: >>> linked_list = LinkedList()
>>> for i in range(0, 10):
...     linked_list.insert_nth(i, i)
>>> linked_list[0] = 666
>>> linked_list[0]
666
>>> linked_list[5] = -666
>>> linked_list[5]
-666
>>> linked_list[-10] = 666
Traceback (most recent call last):
    ...
ValueError: list index out of range.
>>> linked_list[len(linked_list)] = 666
Traceback (most recent call last):
    ...
ValueError: list index out of range.
 - Function 'insert_tail' takes 2 arguments: self, data.  Docstring: Insert data to the end of linked list.
>>> linked_list = LinkedList()
>>> linked_list.insert_tail("tail")
>>> linked_list
tail
>>> linked_list.insert_tail("tail_2")
>>> linked_list
tail -> tail_2
>>> linked_list.insert_tail("tail_3")
>>> linked_list
tail -> tail_2 -> tail_3
 - Function 'insert_head' takes 2 arguments: self, data.  Docstring: Insert data to the beginning of linked list.
>>> linked_list = LinkedList()
>>> linked_list.insert_head("head")
>>> linked_list
head
>>> linked_list.insert_head("head_2")
>>> linked_list
head_2 -> head
>>> linked_list.insert_head("head_3")
>>> linked_list
head_3 -> head_2 -> head
 - Function 'insert_nth' takes 3 arguments: self, index, data.  Docstring: Insert data at given index.
>>> linked_list = LinkedList()
>>> linked_list.insert_tail("first")
>>> linked_list.insert_tail("second")
>>> linked_list.insert_tail("third")
>>> linked_list
first -> second -> third
>>> linked_list.insert_nth(1, "fourth")
>>> linked_list
first -> fourth -> second -> third
>>> linked_list.insert_nth(3, "fifth")
>>> linked_list
first -> fourth -> second -> fifth -> third
 - Function 'print_list' takes 1 arguments: self.  Docstring: This method prints every node data.
>>> linked_list = LinkedList()
>>> linked_list.insert_tail("first")
>>> linked_list.insert_tail("second")
>>> linked_list.insert_tail("third")
>>> linked_list
first -> second -> third
 - Function 'delete_head' takes 1 arguments: self.  Docstring: Delete the first node and return the
node's data.
>>> linked_list = LinkedList()
>>> linked_list.insert_tail("first")
>>> linked_list.insert_tail("second")
>>> linked_list.insert_tail("third")
>>> linked_list
first -> second -> third
>>> linked_list.delete_head()
'first'
>>> linked_list
second -> third
>>> linked_list.delete_head()
'second'
>>> linked_list
third
>>> linked_list.delete_head()
'third'
>>> linked_list.delete_head()
Traceback (most recent call last):
    ...
IndexError: List index out of range.
 - Function 'delete_tail' takes 1 arguments: self.  Docstring: Delete the tail end node and return the
node's data.
>>> linked_list = LinkedList()
>>> linked_list.insert_tail("first")
>>> linked_list.insert_tail("second")
>>> linked_list.insert_tail("third")
>>> linked_list
first -> second -> third
>>> linked_list.delete_tail()
'third'
>>> linked_list
first -> second
>>> linked_list.delete_tail()
'second'
>>> linked_list
first
>>> linked_list.delete_tail()
'first'
>>> linked_list.delete_tail()
Traceback (most recent call last):
    ...
IndexError: List index out of range.
 - Function 'delete_nth' takes 2 arguments: self, index.  Docstring: Delete node at given index and return the
node's data.
>>> linked_list = LinkedList()
>>> linked_list.insert_tail("first")
>>> linked_list.insert_tail("second")
>>> linked_list.insert_tail("third")
>>> linked_list
first -> second -> third
>>> linked_list.delete_nth(1) # delete middle
'second'
>>> linked_list
first -> third
>>> linked_list.delete_nth(5) # this raises error
Traceback (most recent call last):
    ...
IndexError: List index out of range.
>>> linked_list.delete_nth(-1) # this also raises error
Traceback (most recent call last):
    ...
IndexError: List index out of range.
 - Function 'is_empty' takes 1 arguments: self.  Docstring: Check if linked list is empty.
>>> linked_list = LinkedList()
>>> linked_list.is_empty()
True
>>> linked_list.insert_head("first")
>>> linked_list.is_empty()
False
 - Function 'reverse' takes 1 arguments: self.  Docstring: This reverses the linked list order.
>>> linked_list = LinkedList()
>>> linked_list.insert_tail("first")
>>> linked_list.insert_tail("second")
>>> linked_list.insert_tail("third")
>>> linked_list
first -> second -> third
>>> linked_list.reverse()
>>> linked_list
third -> second -> first
 - Function 'test_singly_linked_list' takes 0 arguments: .  Docstring: >>> test_singly_linked_list()
 - Function 'test_singly_linked_list_2' takes 0 arguments: .  Docstring: This section of the test used varying data types for input.
>>> test_singly_linked_list_2()
 - Function 'main' takes 0 arguments: .  No docstring available.

File: skip_list.py
 - Function '__init__' takes 3 arguments: self, key, value.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  Docstring: :return: Visual representation of Node

>>> node = Node("Key", 2)
>>> repr(node)
'Node(Key: 2)'
 - Function 'level' takes 1 arguments: self.  Docstring: :return: Number of forward references

>>> node = Node("Key", 2)
>>> node.level
0
>>> node.forward.append(Node("Key2", 4))
>>> node.level
1
>>> node.forward.append(Node("Key3", 6))
>>> node.level
2
 - Function '__init__' takes 3 arguments: self, p, max_level.  No docstring available.
 - Function '__str__' takes 1 arguments: self.  Docstring: :return: Visual representation of SkipList

>>> skip_list = SkipList()
>>> print(skip_list)
SkipList(level=0)
>>> skip_list.insert("Key1", "Value")
>>> print(skip_list) # doctest: +ELLIPSIS
SkipList(level=...
[root]--...
[Key1]--Key1...
None    *...
>>> skip_list.insert("Key2", "OtherValue")
>>> print(skip_list) # doctest: +ELLIPSIS
SkipList(level=...
[root]--...
[Key1]--Key1...
[Key2]--Key2...
None    *...
 - Function '__iter__' takes 1 arguments: self.  No docstring available.
 - Function 'random_level' takes 1 arguments: self.  Docstring: :return: Random level from [1, self.max_level] interval.
         Higher values are less likely.
 - Function '_locate_node' takes 2 arguments: self, key.  Docstring: :param key: Searched key,
:return: Tuple with searched node (or None if given key is not present)
         and list of nodes that refer (if key is present) of should refer to
         given node.
 - Function 'delete' takes 2 arguments: self, key.  Docstring: :param key: Key to remove from list.

>>> skip_list = SkipList()
>>> skip_list.insert(2, "Two")
>>> skip_list.insert(1, "One")
>>> skip_list.insert(3, "Three")
>>> list(skip_list)
[1, 2, 3]
>>> skip_list.delete(2)
>>> list(skip_list)
[1, 3]
 - Function 'insert' takes 3 arguments: self, key, value.  Docstring: :param key: Key to insert.
:param value: Value associated with given key.

>>> skip_list = SkipList()
>>> skip_list.insert(2, "Two")
>>> skip_list.find(2)
'Two'
>>> list(skip_list)
[2]
 - Function 'find' takes 2 arguments: self, key.  Docstring: :param key: Search key.
:return: Value associated with given key or None if given key is not present.

>>> skip_list = SkipList()
>>> skip_list.find(2)
>>> skip_list.insert(2, "Two")
>>> skip_list.find(2)
'Two'
>>> skip_list.insert(2, "Three")
>>> skip_list.find(2)
'Three'
 - Function 'test_insert' takes 0 arguments: .  No docstring available.
 - Function 'test_insert_overrides_existing_value' takes 0 arguments: .  No docstring available.
 - Function 'test_searching_empty_list_returns_none' takes 0 arguments: .  No docstring available.
 - Function 'test_search' takes 0 arguments: .  No docstring available.
 - Function 'test_deleting_item_from_empty_list_do_nothing' takes 0 arguments: .  No docstring available.
 - Function 'test_deleted_items_are_not_founded_by_find_method' takes 0 arguments: .  No docstring available.
 - Function 'test_delete_removes_only_given_key' takes 0 arguments: .  No docstring available.
 - Function 'test_delete_doesnt_leave_dead_nodes' takes 0 arguments: .  No docstring available.
 - Function 'traverse_keys' takes 1 arguments: node.  No docstring available.
 - Function 'test_iter_always_yields_sorted_values' takes 0 arguments: .  No docstring available.
 - Function 'is_sorted' takes 1 arguments: lst.  No docstring available.
 - Function 'pytests' takes 0 arguments: .  No docstring available.
 - Function 'main' takes 0 arguments: .  Docstring: >>> pytests()

File: swap_nodes.py
 - Function '__iter__' takes 1 arguments: self.  Docstring: >>> linked_list = LinkedList()
>>> list(linked_list)
[]
>>> linked_list.push(0)
>>> tuple(linked_list)
(0,)
 - Function '__len__' takes 1 arguments: self.  Docstring: >>> linked_list = LinkedList()
>>> len(linked_list)
0
>>> linked_list.push(0)
>>> len(linked_list)
1
 - Function 'push' takes 2 arguments: self, new_data.  Docstring: Add a new node with the given data to the beginning of the Linked List.

Args:
    new_data (Any): The data to be added to the new node.

Returns:
    None

Examples:
    >>> linked_list = LinkedList()
    >>> linked_list.push(5)
    >>> linked_list.push(4)
    >>> linked_list.push(3)
    >>> linked_list.push(2)
    >>> linked_list.push(1)
    >>> list(linked_list)
    [1, 2, 3, 4, 5]
 - Function 'swap_nodes' takes 3 arguments: self, node_data_1, node_data_2.  Docstring: Swap the positions of two nodes in the Linked List based on their data values.

Args:
    node_data_1: Data value of the first node to be swapped.
    node_data_2: Data value of the second node to be swapped.


Note:
    If either of the specified data values isn't found then, no swapping occurs.

Examples:
When both values are present in a linked list.
    >>> linked_list = LinkedList()
    >>> linked_list.push(5)
    >>> linked_list.push(4)
    >>> linked_list.push(3)
    >>> linked_list.push(2)
    >>> linked_list.push(1)
    >>> list(linked_list)
    [1, 2, 3, 4, 5]
    >>> linked_list.swap_nodes(1, 5)
    >>> tuple(linked_list)
    (5, 2, 3, 4, 1)

When one value is present and the other isn't in the linked list.
    >>> second_list = LinkedList()
    >>> second_list.push(6)
    >>> second_list.push(7)
    >>> second_list.push(8)
    >>> second_list.push(9)
    >>> second_list.swap_nodes(1, 6) is None
    True

When both values are absent in the linked list.
    >>> second_list = LinkedList()
    >>> second_list.push(10)
    >>> second_list.push(9)
    >>> second_list.push(8)
    >>> second_list.push(7)
    >>> second_list.swap_nodes(1, 3) is None
    True

When linkedlist is empty.
    >>> second_list = LinkedList()
    >>> second_list.swap_nodes(1, 3) is None
    True

Returns:
    None

File: circular_queue.py
 - Function '__init__' takes 2 arguments: self, n.  No docstring available.
 - Function '__len__' takes 1 arguments: self.  Docstring: >>> cq = CircularQueue(5)
>>> len(cq)
0
>>> cq.enqueue("A")  # doctest: +ELLIPSIS
<data_structures.queue.circular_queue.CircularQueue object at ...
>>> len(cq)
1
 - Function 'is_empty' takes 1 arguments: self.  Docstring: Checks whether the queue is empty or not
>>> cq = CircularQueue(5)
>>> cq.is_empty()
True
>>> cq.enqueue("A").is_empty()
False
 - Function 'first' takes 1 arguments: self.  Docstring: Returns the first element of the queue
>>> cq = CircularQueue(5)
>>> cq.first()
False
>>> cq.enqueue("A").first()
'A'
 - Function 'enqueue' takes 2 arguments: self, data.  Docstring: This function inserts an element at the end of the queue using self.rear value
as an index.
>>> cq = CircularQueue(5)
>>> cq.enqueue("A")  # doctest: +ELLIPSIS
<data_structures.queue.circular_queue.CircularQueue object at ...
>>> (cq.size, cq.first())
(1, 'A')
>>> cq.enqueue("B")  # doctest: +ELLIPSIS
<data_structures.queue.circular_queue.CircularQueue object at ...
>>> (cq.size, cq.first())
(2, 'A')
 - Function 'dequeue' takes 1 arguments: self.  Docstring: This function removes an element from the queue using on self.front value as an
index and returns it
>>> cq = CircularQueue(5)
>>> cq.dequeue()
Traceback (most recent call last):
   ...
Exception: UNDERFLOW
>>> cq.enqueue("A").enqueue("B").dequeue()
'A'
>>> (cq.size, cq.first())
(1, 'B')
>>> cq.dequeue()
'B'
>>> cq.dequeue()
Traceback (most recent call last):
   ...
Exception: UNDERFLOW

File: circular_queue_linked_list.py
 - Function '__init__' takes 2 arguments: self, initial_capacity.  No docstring available.
 - Function 'create_linked_list' takes 2 arguments: self, initial_capacity.  No docstring available.
 - Function 'is_empty' takes 1 arguments: self.  Docstring: Checks whether the queue is empty or not
>>> cq = CircularQueueLinkedList()
>>> cq.is_empty()
True
>>> cq.enqueue('a')
>>> cq.is_empty()
False
>>> cq.dequeue()
'a'
>>> cq.is_empty()
True
 - Function 'first' takes 1 arguments: self.  Docstring: Returns the first element of the queue
>>> cq = CircularQueueLinkedList()
>>> cq.first()
Traceback (most recent call last):
   ...
Exception: Empty Queue
>>> cq.enqueue('a')
>>> cq.first()
'a'
>>> cq.dequeue()
'a'
>>> cq.first()
Traceback (most recent call last):
   ...
Exception: Empty Queue
>>> cq.enqueue('b')
>>> cq.enqueue('c')
>>> cq.first()
'b'
 - Function 'enqueue' takes 2 arguments: self, data.  Docstring: Saves data at the end of the queue

>>> cq = CircularQueueLinkedList()
>>> cq.enqueue('a')
>>> cq.enqueue('b')
>>> cq.dequeue()
'a'
>>> cq.dequeue()
'b'
>>> cq.dequeue()
Traceback (most recent call last):
   ...
Exception: Empty Queue
 - Function 'dequeue' takes 1 arguments: self.  Docstring: Removes and retrieves the first element of the queue

>>> cq = CircularQueueLinkedList()
>>> cq.dequeue()
Traceback (most recent call last):
   ...
Exception: Empty Queue
>>> cq.enqueue('a')
>>> cq.dequeue()
'a'
>>> cq.dequeue()
Traceback (most recent call last):
   ...
Exception: Empty Queue
 - Function 'check_can_perform_operation' takes 1 arguments: self.  No docstring available.
 - Function 'check_is_full' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.

File: double_ended_queue.py
 - Function '__init__' takes 2 arguments: self, cur.  No docstring available.
 - Function '__iter__' takes 1 arguments: self.  Docstring: >>> our_deque = Deque([1, 2, 3])
>>> iterator = iter(our_deque)
 - Function '__next__' takes 1 arguments: self.  Docstring: >>> our_deque = Deque([1, 2, 3])
>>> iterator = iter(our_deque)
>>> next(iterator)
1
>>> next(iterator)
2
>>> next(iterator)
3
 - Function '__init__' takes 2 arguments: self, iterable.  No docstring available.
 - Function 'append' takes 2 arguments: self, val.  Docstring: Adds val to the end of the deque.
Time complexity: O(1)
>>> our_deque_1 = Deque([1, 2, 3])
>>> our_deque_1.append(4)
>>> our_deque_1
[1, 2, 3, 4]
>>> our_deque_2 = Deque('ab')
>>> our_deque_2.append('c')
>>> our_deque_2
['a', 'b', 'c']
>>> from collections import deque
>>> deque_collections_1 = deque([1, 2, 3])
>>> deque_collections_1.append(4)
>>> deque_collections_1
deque([1, 2, 3, 4])
>>> deque_collections_2 = deque('ab')
>>> deque_collections_2.append('c')
>>> deque_collections_2
deque(['a', 'b', 'c'])
>>> list(our_deque_1) == list(deque_collections_1)
True
>>> list(our_deque_2) == list(deque_collections_2)
True
 - Function 'appendleft' takes 2 arguments: self, val.  Docstring: Adds val to the beginning of the deque.
Time complexity: O(1)
>>> our_deque_1 = Deque([2, 3])
>>> our_deque_1.appendleft(1)
>>> our_deque_1
[1, 2, 3]
>>> our_deque_2 = Deque('bc')
>>> our_deque_2.appendleft('a')
>>> our_deque_2
['a', 'b', 'c']
>>> from collections import deque
>>> deque_collections_1 = deque([2, 3])
>>> deque_collections_1.appendleft(1)
>>> deque_collections_1
deque([1, 2, 3])
>>> deque_collections_2 = deque('bc')
>>> deque_collections_2.appendleft('a')
>>> deque_collections_2
deque(['a', 'b', 'c'])
>>> list(our_deque_1) == list(deque_collections_1)
True
>>> list(our_deque_2) == list(deque_collections_2)
True
 - Function 'extend' takes 2 arguments: self, iterable.  Docstring: Appends every value of iterable to the end of the deque.
Time complexity: O(n)
>>> our_deque_1 = Deque([1, 2, 3])
>>> our_deque_1.extend([4, 5])
>>> our_deque_1
[1, 2, 3, 4, 5]
>>> our_deque_2 = Deque('ab')
>>> our_deque_2.extend('cd')
>>> our_deque_2
['a', 'b', 'c', 'd']
>>> from collections import deque
>>> deque_collections_1 = deque([1, 2, 3])
>>> deque_collections_1.extend([4, 5])
>>> deque_collections_1
deque([1, 2, 3, 4, 5])
>>> deque_collections_2 = deque('ab')
>>> deque_collections_2.extend('cd')
>>> deque_collections_2
deque(['a', 'b', 'c', 'd'])
>>> list(our_deque_1) == list(deque_collections_1)
True
>>> list(our_deque_2) == list(deque_collections_2)
True
 - Function 'extendleft' takes 2 arguments: self, iterable.  Docstring: Appends every value of iterable to the beginning of the deque.
Time complexity: O(n)
>>> our_deque_1 = Deque([1, 2, 3])
>>> our_deque_1.extendleft([0, -1])
>>> our_deque_1
[-1, 0, 1, 2, 3]
>>> our_deque_2 = Deque('cd')
>>> our_deque_2.extendleft('ba')
>>> our_deque_2
['a', 'b', 'c', 'd']
>>> from collections import deque
>>> deque_collections_1 = deque([1, 2, 3])
>>> deque_collections_1.extendleft([0, -1])
>>> deque_collections_1
deque([-1, 0, 1, 2, 3])
>>> deque_collections_2 = deque('cd')
>>> deque_collections_2.extendleft('ba')
>>> deque_collections_2
deque(['a', 'b', 'c', 'd'])
>>> list(our_deque_1) == list(deque_collections_1)
True
>>> list(our_deque_2) == list(deque_collections_2)
True
 - Function 'pop' takes 1 arguments: self.  Docstring: Removes the last element of the deque and returns it.
Time complexity: O(1)
@returns topop.val: the value of the node to pop.
>>> our_deque1 = Deque([1])
>>> our_popped1 = our_deque1.pop()
>>> our_popped1
1
>>> our_deque1
[]

>>> our_deque2 = Deque([1, 2, 3, 15182])
>>> our_popped2 = our_deque2.pop()
>>> our_popped2
15182
>>> our_deque2
[1, 2, 3]

>>> from collections import deque
>>> deque_collections = deque([1, 2, 3, 15182])
>>> collections_popped = deque_collections.pop()
>>> collections_popped
15182
>>> deque_collections
deque([1, 2, 3])
>>> list(our_deque2) == list(deque_collections)
True
>>> our_popped2 == collections_popped
True
 - Function 'popleft' takes 1 arguments: self.  Docstring: Removes the first element of the deque and returns it.
Time complexity: O(1)
@returns topop.val: the value of the node to pop.
>>> our_deque1 = Deque([1])
>>> our_popped1 = our_deque1.pop()
>>> our_popped1
1
>>> our_deque1
[]
>>> our_deque2 = Deque([15182, 1, 2, 3])
>>> our_popped2 = our_deque2.popleft()
>>> our_popped2
15182
>>> our_deque2
[1, 2, 3]
>>> from collections import deque
>>> deque_collections = deque([15182, 1, 2, 3])
>>> collections_popped = deque_collections.popleft()
>>> collections_popped
15182
>>> deque_collections
deque([1, 2, 3])
>>> list(our_deque2) == list(deque_collections)
True
>>> our_popped2 == collections_popped
True
 - Function 'is_empty' takes 1 arguments: self.  Docstring: Checks if the deque is empty.
Time complexity: O(1)
>>> our_deque = Deque([1, 2, 3])
>>> our_deque.is_empty()
False
>>> our_empty_deque = Deque()
>>> our_empty_deque.is_empty()
True
>>> from collections import deque
>>> empty_deque_collections = deque()
>>> list(our_empty_deque) == list(empty_deque_collections)
True
 - Function '__len__' takes 1 arguments: self.  Docstring: Implements len() function. Returns the length of the deque.
Time complexity: O(1)
>>> our_deque = Deque([1, 2, 3])
>>> len(our_deque)
3
>>> our_empty_deque = Deque()
>>> len(our_empty_deque)
0
>>> from collections import deque
>>> deque_collections = deque([1, 2, 3])
>>> len(deque_collections)
3
>>> empty_deque_collections = deque()
>>> len(empty_deque_collections)
0
>>> len(our_empty_deque) == len(empty_deque_collections)
True
 - Function '__eq__' takes 2 arguments: self, other.  Docstring: Implements "==" operator. Returns if *self* is equal to *other*.
Time complexity: O(n)
>>> our_deque_1 = Deque([1, 2, 3])
>>> our_deque_2 = Deque([1, 2, 3])
>>> our_deque_1 == our_deque_2
True
>>> our_deque_3 = Deque([1, 2])
>>> our_deque_1 == our_deque_3
False
>>> from collections import deque
>>> deque_collections_1 = deque([1, 2, 3])
>>> deque_collections_2 = deque([1, 2, 3])
>>> deque_collections_1 == deque_collections_2
True
>>> deque_collections_3 = deque([1, 2])
>>> deque_collections_1 == deque_collections_3
False
>>> (our_deque_1 == our_deque_2) == (deque_collections_1 == deque_collections_2)
True
>>> (our_deque_1 == our_deque_3) == (deque_collections_1 == deque_collections_3)
True
 - Function '__iter__' takes 1 arguments: self.  Docstring: Implements iteration.
Time complexity: O(1)
>>> our_deque = Deque([1, 2, 3])
>>> for v in our_deque:
...     print(v)
1
2
3
>>> from collections import deque
>>> deque_collections = deque([1, 2, 3])
>>> for v in deque_collections:
...     print(v)
1
2
3
 - Function '__repr__' takes 1 arguments: self.  Docstring: Implements representation of the deque.
Represents it as a list, with its values between '[' and ']'.
Time complexity: O(n)
>>> our_deque = Deque([1, 2, 3])
>>> our_deque
[1, 2, 3]

File: linked_queue.py
 - Function '__init__' takes 2 arguments: self, data.  No docstring available.
 - Function '__str__' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__iter__' takes 1 arguments: self.  No docstring available.
 - Function '__len__' takes 1 arguments: self.  Docstring: >>> queue = LinkedQueue()
>>> for i in range(1, 6):
...     queue.put(i)
>>> len(queue)
5
>>> for i in range(1, 6):
...     assert len(queue) == 6 - i
...     _ = queue.get()
>>> len(queue)
0
 - Function '__str__' takes 1 arguments: self.  Docstring: >>> queue = LinkedQueue()
>>> for i in range(1, 4):
...     queue.put(i)
>>> queue.put("Python")
>>> queue.put(3.14)
>>> queue.put(True)
>>> str(queue)
'1 <- 2 <- 3 <- Python <- 3.14 <- True'
 - Function 'is_empty' takes 1 arguments: self.  Docstring: >>> queue = LinkedQueue()
>>> queue.is_empty()
True
>>> for i in range(1, 6):
...     queue.put(i)
>>> queue.is_empty()
False
 - Function 'put' takes 2 arguments: self, item.  Docstring: >>> queue = LinkedQueue()
>>> queue.get()
Traceback (most recent call last):
    ...
IndexError: dequeue from empty queue
>>> for i in range(1, 6):
...     queue.put(i)
>>> str(queue)
'1 <- 2 <- 3 <- 4 <- 5'
 - Function 'get' takes 1 arguments: self.  Docstring: >>> queue = LinkedQueue()
>>> queue.get()
Traceback (most recent call last):
    ...
IndexError: dequeue from empty queue
>>> queue = LinkedQueue()
>>> for i in range(1, 6):
...     queue.put(i)
>>> for i in range(1, 6):
...     assert queue.get() == i
>>> len(queue)
0
 - Function 'clear' takes 1 arguments: self.  Docstring: >>> queue = LinkedQueue()
>>> for i in range(1, 6):
...     queue.put(i)
>>> queue.clear()
>>> len(queue)
0
>>> str(queue)
''

File: priority_queue_using_list.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'enqueue' takes 3 arguments: self, priority, data.  Docstring: Add an element to a queue based on its priority.
If the priority is invalid ValueError is raised.
If the queue is full an OverFlowError is raised.
 - Function 'dequeue' takes 1 arguments: self.  Docstring: Return the highest priority element in FIFO order.
If the queue is empty then an under flow exception is raised.
 - Function '__str__' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'enqueue' takes 2 arguments: self, data.  Docstring: This function enters the element into the queue
If the queue is full an Exception is raised saying Over Flow!
 - Function 'dequeue' takes 1 arguments: self.  Docstring: Return the highest priority element in FIFO order.
If the queue is empty then an under flow exception is raised.
 - Function '__str__' takes 1 arguments: self.  Docstring: Prints all the elements within the Element Priority Queue
 - Function 'fixed_priority_queue' takes 0 arguments: .  No docstring available.
 - Function 'element_priority_queue' takes 0 arguments: .  No docstring available.

File: queue_by_list.py
 - Function '__init__' takes 2 arguments: self, iterable.  Docstring: >>> QueueByList()
Queue(())
>>> QueueByList([10, 20, 30])
Queue((10, 20, 30))
>>> QueueByList((i**2 for i in range(1, 4)))
Queue((1, 4, 9))
 - Function '__len__' takes 1 arguments: self.  Docstring: >>> len(QueueByList())
0
>>> from string import ascii_lowercase
>>> len(QueueByList(ascii_lowercase))
26
>>> queue = QueueByList()
>>> for i in range(1, 11):
...     queue.put(i)
>>> len(queue)
10
>>> for i in range(2):
...   queue.get()
1
2
>>> len(queue)
8
 - Function '__repr__' takes 1 arguments: self.  Docstring: >>> queue = QueueByList()
>>> queue
Queue(())
>>> str(queue)
'Queue(())'
>>> queue.put(10)
>>> queue
Queue((10,))
>>> queue.put(20)
>>> queue.put(30)
>>> queue
Queue((10, 20, 30))
 - Function 'put' takes 2 arguments: self, item.  Docstring: Put `item` to the Queue

>>> queue = QueueByList()
>>> queue.put(10)
>>> queue.put(20)
>>> len(queue)
2
>>> queue
Queue((10, 20))
 - Function 'get' takes 1 arguments: self.  Docstring: Get `item` from the Queue

>>> queue = QueueByList((10, 20, 30))
>>> queue.get()
10
>>> queue.put(40)
>>> queue.get()
20
>>> queue.get()
30
>>> len(queue)
1
>>> queue.get()
40
>>> queue.get()
Traceback (most recent call last):
    ...
IndexError: Queue is empty
 - Function 'rotate' takes 2 arguments: self, rotation.  Docstring: Rotate the items of the Queue `rotation` times

>>> queue = QueueByList([10, 20, 30, 40])
>>> queue
Queue((10, 20, 30, 40))
>>> queue.rotate(1)
>>> queue
Queue((20, 30, 40, 10))
>>> queue.rotate(2)
>>> queue
Queue((40, 10, 20, 30))
 - Function 'get_front' takes 1 arguments: self.  Docstring: Get the front item from the Queue

>>> queue = QueueByList((10, 20, 30))
>>> queue.get_front()
10
>>> queue
Queue((10, 20, 30))
>>> queue.get()
10
>>> queue.get_front()
20

File: queue_by_two_stacks.py
 - Function '__init__' takes 2 arguments: self, iterable.  Docstring: >>> QueueByTwoStacks()
Queue(())
>>> QueueByTwoStacks([10, 20, 30])
Queue((10, 20, 30))
>>> QueueByTwoStacks((i**2 for i in range(1, 4)))
Queue((1, 4, 9))
 - Function '__len__' takes 1 arguments: self.  Docstring: >>> len(QueueByTwoStacks())
0
>>> from string import ascii_lowercase
>>> len(QueueByTwoStacks(ascii_lowercase))
26
>>> queue = QueueByTwoStacks()
>>> for i in range(1, 11):
...     queue.put(i)
...
>>> len(queue)
10
>>> for i in range(2):
...   queue.get()
1
2
>>> len(queue)
8
 - Function '__repr__' takes 1 arguments: self.  Docstring: >>> queue = QueueByTwoStacks()
>>> queue
Queue(())
>>> str(queue)
'Queue(())'
>>> queue.put(10)
>>> queue
Queue((10,))
>>> queue.put(20)
>>> queue.put(30)
>>> queue
Queue((10, 20, 30))
 - Function 'put' takes 2 arguments: self, item.  Docstring: Put `item` into the Queue

>>> queue = QueueByTwoStacks()
>>> queue.put(10)
>>> queue.put(20)
>>> len(queue)
2
>>> queue
Queue((10, 20))
 - Function 'get' takes 1 arguments: self.  Docstring: Get `item` from the Queue

>>> queue = QueueByTwoStacks((10, 20, 30))
>>> queue.get()
10
>>> queue.put(40)
>>> queue.get()
20
>>> queue.get()
30
>>> len(queue)
1
>>> queue.get()
40
>>> queue.get()
Traceback (most recent call last):
    ...
IndexError: Queue is empty

File: queue_on_pseudo_stack.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__str__' takes 1 arguments: self.  No docstring available.
 - Function 'put' takes 2 arguments: self, item.  No docstring available.
 - Function 'get' takes 1 arguments: self.  No docstring available.
 - Function 'rotate' takes 2 arguments: self, rotation.  No docstring available.
 - Function 'front' takes 1 arguments: self.  No docstring available.
 - Function 'size' takes 1 arguments: self.  No docstring available.

File: balanced_parentheses.py
 - Function 'balanced_parentheses' takes 1 arguments: parentheses.  Docstring: Use a stack to check if a string of parentheses is balanced.
>>> balanced_parentheses("([]{})")
True
>>> balanced_parentheses("[()]{}{[()()]()}")
True
>>> balanced_parentheses("[(])")
False
>>> balanced_parentheses("1+2*3-4")
True
>>> balanced_parentheses("")
True

File: dijkstras_two_stack_algorithm.py
 - Function 'dijkstras_two_stack_algorithm' takes 1 arguments: equation.  Docstring: DocTests
>>> dijkstras_two_stack_algorithm("(5 + 3)")
8
>>> dijkstras_two_stack_algorithm("((9 - (2 + 9)) + (8 - 1))")
5
>>> dijkstras_two_stack_algorithm("((((3 - 2) - (2 + 3)) + (2 - 4)) + 3)")
-3

:param equation: a string
:return: result: an integer

File: infix_to_postfix_conversion.py
 - Function 'precedence' takes 1 arguments: char.  Docstring: Return integer value representing an operator's precedence, or
order of operation.
https://en.wikipedia.org/wiki/Order_of_operations
 - Function 'associativity' takes 1 arguments: char.  Docstring: Return the associativity of the operator `char`.
https://en.wikipedia.org/wiki/Operator_associativity
 - Function 'infix_to_postfix' takes 1 arguments: expression_str.  Docstring: >>> infix_to_postfix("(1*(2+3)+4))")
Traceback (most recent call last):
    ...
ValueError: Mismatched parentheses
>>> infix_to_postfix("")
''
>>> infix_to_postfix("3+2")
'3 2 +'
>>> infix_to_postfix("(3+4)*5-6")
'3 4 + 5 * 6 -'
>>> infix_to_postfix("(1+2)*3/4-5")
'1 2 + 3 * 4 / 5 -'
>>> infix_to_postfix("a+b*c+(d*e+f)*g")
'a b c * + d e * f + g * +'
>>> infix_to_postfix("x^y/(5*z)+2")
'x y ^ 5 z * / 2 +'
>>> infix_to_postfix("2^3^2")
'2 3 2 ^ ^'

File: infix_to_prefix_conversion.py
 - Function 'infix_2_postfix' takes 1 arguments: infix.  Docstring: >>> infix_2_postfix("a+b^c")  # doctest: +NORMALIZE_WHITESPACE
 Symbol  |  Stack  | Postfix
----------------------------
   a     |         | a
   +     | +       | a
   b     | +       | ab
   ^     | +^      | ab
   c     | +^      | abc
         | +       | abc^
         |         | abc^+
'abc^+'

>>> infix_2_postfix("1*((-a)*2+b)")   # doctest: +NORMALIZE_WHITESPACE
  Symbol  |    Stack     |   Postfix
-------------------------------------------
   1     |              | 1
   *     | *            | 1
   (     | *(           | 1
   (     | *((          | 1
   -     | *((-         | 1
   a     | *((-         | 1a
   )     | *(           | 1a-
   *     | *(*          | 1a-
   2     | *(*          | 1a-2
   +     | *(+          | 1a-2*
   b     | *(+          | 1a-2*b
   )     | *            | 1a-2*b+
         |              | 1a-2*b+*
'1a-2*b+*'

>>> infix_2_postfix("")
 Symbol  |  Stack  | Postfix
----------------------------
''

>>> infix_2_postfix("(()")
Traceback (most recent call last):
    ...
ValueError: invalid expression

>>> infix_2_postfix("())")
Traceback (most recent call last):
    ...
IndexError: list index out of range
 - Function 'infix_2_prefix' takes 1 arguments: infix.  Docstring: >>> infix_2_prefix("a+b^c")  # doctest: +NORMALIZE_WHITESPACE
 Symbol  |  Stack  | Postfix
----------------------------
   c     |         | c
   ^     | ^       | c
   b     | ^       | cb
   +     | +       | cb^
   a     | +       | cb^a
         |         | cb^a+
'+a^bc'

>>> infix_2_prefix("1*((-a)*2+b)") # doctest: +NORMALIZE_WHITESPACE
 Symbol  |    Stack     |   Postfix
-------------------------------------------
   (     | (            |
   b     | (            | b
   +     | (+           | b
   2     | (+           | b2
   *     | (+*          | b2
   (     | (+*(         | b2
   a     | (+*(         | b2a
   -     | (+*(-        | b2a
   )     | (+*          | b2a-
   )     |              | b2a-*+
   *     | *            | b2a-*+
   1     | *            | b2a-*+1
         |              | b2a-*+1*
'*1+*-a2b'

>>> infix_2_prefix('')
 Symbol  |  Stack  | Postfix
----------------------------
''

>>> infix_2_prefix('(()')
Traceback (most recent call last):
    ...
IndexError: list index out of range

>>> infix_2_prefix('())')
Traceback (most recent call last):
    ...
ValueError: invalid expression

File: next_greater_element.py
 - Function 'next_greatest_element_slow' takes 1 arguments: arr.  Docstring: Get the Next Greatest Element (NGE) for all elements in a list.
Maximum element present after the current one which is also greater than the
current one.
>>> next_greatest_element_slow(arr) == expect
True
 - Function 'next_greatest_element_fast' takes 1 arguments: arr.  Docstring: Like next_greatest_element_slow() but changes the loops to use
enumerate() instead of range(len()) for the outer loop and
for in a slice of arr for the inner loop.
>>> next_greatest_element_fast(arr) == expect
True
 - Function 'next_greatest_element' takes 1 arguments: arr.  Docstring: Get the Next Greatest Element (NGE) for all elements in a list.
Maximum element present after the current one which is also greater than the
current one.

A naive way to solve this is to take two loops and check for the next bigger
number but that will make the time complexity as O(n^2). The better way to solve
this would be to use a stack to keep track of maximum number giving a linear time
solution.
>>> next_greatest_element(arr) == expect
True

File: postfix_evaluation.py
 - Function 'parse_token' takes 1 arguments: token.  Docstring: Converts the given data to the appropriate number if it is indeed a number, else
returns the data as it is with a False flag. This function also serves as a check
of whether the input is a number or not.

Parameters
----------
token: The data that needs to be converted to the appropriate operator or number.

Returns
-------
float or str
    Returns a float if `token` is a number or a str if `token` is an operator
 - Function 'evaluate' takes 2 arguments: post_fix, verbose.  Docstring: Evaluate postfix expression using a stack.
>>> evaluate(["0"])
0.0
>>> evaluate(["-0"])
-0.0
>>> evaluate(["1"])
1.0
>>> evaluate(["-1"])
-1.0
>>> evaluate(["-1.1"])
-1.1
>>> evaluate(["2", "1", "+", "3", "*"])
9.0
>>> evaluate(["2", "1.9", "+", "3", "*"])
11.7
>>> evaluate(["2", "-1.9", "+", "3", "*"])
0.30000000000000027
>>> evaluate(["4", "13", "5", "/", "+"])
6.6
>>> evaluate(["2", "-", "3", "+"])
1.0
>>> evaluate(["-4", "5", "*", "6", "-"])
-26.0
>>> evaluate([])
0
>>> evaluate(["4", "-", "6", "7", "/", "9", "8"])
Traceback (most recent call last):
...
ArithmeticError: Input is not a valid postfix expression

Parameters
----------
post_fix:
    The postfix expression is tokenized into operators and operands and stored
    as a Python list

verbose:
    Display stack contents while evaluating the expression if verbose is True

Returns
-------
float
    The evaluated value

File: prefix_evaluation.py
 - Function 'is_operand' takes 1 arguments: c.  Docstring: Return True if the given char c is an operand, e.g. it is a number

>>> is_operand("1")
True
>>> is_operand("+")
False
 - Function 'evaluate' takes 1 arguments: expression.  Docstring: Evaluate a given expression in prefix notation.
Asserts that the given expression is valid.

>>> evaluate("+ 9 * 2 6")
21
>>> evaluate("/ * 10 2 + 4 1 ")
4.0

File: stack.py
 - Function '__init__' takes 2 arguments: self, limit.  No docstring available.
 - Function '__bool__' takes 1 arguments: self.  No docstring available.
 - Function '__str__' takes 1 arguments: self.  No docstring available.
 - Function 'push' takes 2 arguments: self, data.  Docstring: Push an element to the top of the stack.

>>> S = Stack(2) # stack size = 2
>>> S.push(10)
>>> S.push(20)
>>> print(S)
[10, 20]

>>> S = Stack(1) # stack size = 1
>>> S.push(10)
>>> S.push(20)
Traceback (most recent call last):
...
data_structures.stacks.stack.StackOverflowError
 - Function 'pop' takes 1 arguments: self.  Docstring: Pop an element off of the top of the stack.

>>> S = Stack()
>>> S.push(-5)
>>> S.push(10)
>>> S.pop()
10

>>> Stack().pop()
Traceback (most recent call last):
    ...
data_structures.stacks.stack.StackUnderflowError
 - Function 'peek' takes 1 arguments: self.  Docstring: Peek at the top-most element of the stack.

>>> S = Stack()
>>> S.push(-5)
>>> S.push(10)
>>> S.peek()
10

>>> Stack().peek()
Traceback (most recent call last):
    ...
data_structures.stacks.stack.StackUnderflowError
 - Function 'is_empty' takes 1 arguments: self.  Docstring: Check if a stack is empty.

>>> S = Stack()
>>> S.is_empty()
True

>>> S = Stack()
>>> S.push(10)
>>> S.is_empty()
False
 - Function 'is_full' takes 1 arguments: self.  Docstring: >>> S = Stack()
>>> S.is_full()
False

>>> S = Stack(1)
>>> S.push(10)
>>> S.is_full()
True
 - Function 'size' takes 1 arguments: self.  Docstring: Return the size of the stack.

>>> S = Stack(3)
>>> S.size()
0

>>> S = Stack(3)
>>> S.push(10)
>>> S.size()
1

>>> S = Stack(3)
>>> S.push(10)
>>> S.push(20)
>>> S.size()
2
 - Function '__contains__' takes 2 arguments: self, item.  Docstring: Check if item is in stack

>>> S = Stack(3)
>>> S.push(10)
>>> 10 in S
True

>>> S = Stack(3)
>>> S.push(10)
>>> 20 in S
False
 - Function 'test_stack' takes 0 arguments: .  Docstring: >>> test_stack()

File: stack_using_two_queues.py
 - Function 'push' takes 2 arguments: self, item.  No docstring available.
 - Function 'pop' takes 1 arguments: self.  No docstring available.
 - Function 'peek' takes 1 arguments: self.  No docstring available.

File: stack_with_doubly_linked_list.py
 - Function '__init__' takes 2 arguments: self, data.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'push' takes 2 arguments: self, data.  Docstring: add a Node to the stack
 - Function 'pop' takes 1 arguments: self.  Docstring: pop the top element off the stack
 - Function 'top' takes 1 arguments: self.  Docstring: return the top element of the stack
 - Function '__len__' takes 1 arguments: self.  No docstring available.
 - Function 'is_empty' takes 1 arguments: self.  No docstring available.
 - Function 'print_stack' takes 1 arguments: self.  No docstring available.

File: stack_with_singly_linked_list.py
 - Function '__init__' takes 2 arguments: self, data.  No docstring available.
 - Function '__str__' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__iter__' takes 1 arguments: self.  No docstring available.
 - Function '__str__' takes 1 arguments: self.  Docstring: >>> stack = LinkedStack()
>>> stack.push("c")
>>> stack.push("b")
>>> stack.push("a")
>>> str(stack)
'a->b->c'
 - Function '__len__' takes 1 arguments: self.  Docstring: >>> stack = LinkedStack()
>>> len(stack) == 0
True
>>> stack.push("c")
>>> stack.push("b")
>>> stack.push("a")
>>> len(stack) == 3
True
 - Function 'is_empty' takes 1 arguments: self.  Docstring: >>> stack = LinkedStack()
>>> stack.is_empty()
True
>>> stack.push(1)
>>> stack.is_empty()
False
 - Function 'push' takes 2 arguments: self, item.  Docstring: >>> stack = LinkedStack()
>>> stack.push("Python")
>>> stack.push("Java")
>>> stack.push("C")
>>> str(stack)
'C->Java->Python'
 - Function 'pop' takes 1 arguments: self.  Docstring: >>> stack = LinkedStack()
>>> stack.pop()
Traceback (most recent call last):
    ...
IndexError: pop from empty stack
>>> stack.push("c")
>>> stack.push("b")
>>> stack.push("a")
>>> stack.pop() == 'a'
True
>>> stack.pop() == 'b'
True
>>> stack.pop() == 'c'
True
 - Function 'peek' takes 1 arguments: self.  Docstring: >>> stack = LinkedStack()
>>> stack.push("Java")
>>> stack.push("C")
>>> stack.push("Python")
>>> stack.peek()
'Python'
 - Function 'clear' takes 1 arguments: self.  Docstring: >>> stack = LinkedStack()
>>> stack.push("Java")
>>> stack.push("C")
>>> stack.push("Python")
>>> str(stack)
'Python->C->Java'
>>> stack.clear()
>>> len(stack) == 0
True

File: stock_span_problem.py
 - Function 'calculation_span' takes 2 arguments: price, s.  No docstring available.
 - Function 'print_array' takes 2 arguments: arr, n.  No docstring available.

File: radix_tree.py
 - Function '__init__' takes 3 arguments: self, prefix, is_leaf.  No docstring available.
 - Function 'match' takes 2 arguments: self, word.  Docstring: Compute the common substring of the prefix of the node and a word

Args:
    word (str): word to compare

Returns:
    (str, str, str): common substring, remaining prefix, remaining word

>>> RadixNode("myprefix").match("mystring")
('my', 'prefix', 'string')
 - Function 'insert_many' takes 2 arguments: self, words.  Docstring: Insert many words in the tree

Args:
    words (list[str]): list of words

>>> RadixNode("myprefix").insert_many(["mystring", "hello"])
 - Function 'insert' takes 2 arguments: self, word.  Docstring: Insert a word into the tree

Args:
    word (str): word to insert

>>> RadixNode("myprefix").insert("mystring")

>>> root = RadixNode()
>>> root.insert_many(['myprefix', 'myprefixA', 'myprefixAA'])
>>> root.print_tree()
- myprefix   (leaf)
-- A   (leaf)
--- A   (leaf)
 - Function 'find' takes 2 arguments: self, word.  Docstring: Returns if the word is on the tree

Args:
    word (str): word to check

Returns:
    bool: True if the word appears on the tree

>>> RadixNode("myprefix").find("mystring")
False
 - Function 'delete' takes 2 arguments: self, word.  Docstring: Deletes a word from the tree if it exists

Args:
    word (str): word to be deleted

Returns:
    bool: True if the word was found and deleted. False if word is not found

>>> RadixNode("myprefix").delete("mystring")
False
 - Function 'print_tree' takes 2 arguments: self, height.  Docstring: Print the tree

Args:
    height (int, optional): Height of the printed node
 - Function 'test_trie' takes 0 arguments: .  No docstring available.
 - Function 'pytests' takes 0 arguments: .  No docstring available.
 - Function 'main' takes 0 arguments: .  Docstring: >>> pytests()

File: trie.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'insert_many' takes 2 arguments: self, words.  Docstring: Inserts a list of words into the Trie
:param words: list of string words
:return: None
 - Function 'insert' takes 2 arguments: self, word.  Docstring: Inserts a word into the Trie
:param word: word to be inserted
:return: None
 - Function 'find' takes 2 arguments: self, word.  Docstring: Tries to find word in a Trie
:param word: word to look for
:return: Returns True if word is found, False otherwise
 - Function 'delete' takes 2 arguments: self, word.  Docstring: Deletes a word in a Trie
:param word: word to delete
:return: None
 - Function '_delete' takes 3 arguments: curr, word, index.  No docstring available.
 - Function 'print_words' takes 2 arguments: node, word.  Docstring: Prints all the words in a Trie
:param node: root node of Trie
:param word: Word variable should be empty at start
:return: None
 - Function 'test_trie' takes 0 arguments: .  No docstring available.
 - Function 'print_results' takes 2 arguments: msg, passes.  No docstring available.
 - Function 'pytests' takes 0 arguments: .  No docstring available.
 - Function 'main' takes 0 arguments: .  Docstring: >>> pytests()

File: change_brightness.py
 - Function 'change_brightness' takes 2 arguments: img, level.  Docstring: Change the brightness of a PIL Image to a given level.
 - Function 'brightness' takes 1 arguments: c.  Docstring: Fundamental Transformation/Operation that'll be performed on
every bit.

File: change_contrast.py
 - Function 'change_contrast' takes 2 arguments: img, level.  Docstring: Function to change contrast
 - Function 'contrast' takes 1 arguments: c.  Docstring: Fundamental Transformation/Operation that'll be performed on
every bit.

File: convert_to_negative.py
 - Function 'convert_to_negative' takes 1 arguments: img.  No docstring available.

File: index_calculation.py
 - Function '__init__' takes 6 arguments: self, red, green, blue, red_edge, nir.  No docstring available.
 - Function 'set_matricies' takes 6 arguments: self, red, green, blue, red_edge, nir.  No docstring available.
 - Function 'calculation' takes 7 arguments: self, index, red, green, blue, red_edge, nir.  Docstring: performs the calculation of the index with the values instantiated in the class
:str index: abbreviation of index name to perform
 - Function 'arv12' takes 1 arguments: self.  Docstring: Atmospherically Resistant Vegetation Index 2
https://www.indexdatabase.de/db/i-single.php?id=396
:return: index
    -0.18+1.17*(self.nir-self.red)/(self.nir+self.red)
 - Function 'ccci' takes 1 arguments: self.  Docstring: Canopy Chlorophyll Content Index
https://www.indexdatabase.de/db/i-single.php?id=224
:return: index
 - Function 'cvi' takes 1 arguments: self.  Docstring: Chlorophyll vegetation index
https://www.indexdatabase.de/db/i-single.php?id=391
:return: index
 - Function 'gli' takes 1 arguments: self.  Docstring: self.green leaf index
https://www.indexdatabase.de/db/i-single.php?id=375
:return: index
 - Function 'ndvi' takes 1 arguments: self.  Docstring: Normalized Difference self.nir/self.red Normalized Difference Vegetation
Index, Calibrated NDVI - CDVI
https://www.indexdatabase.de/db/i-single.php?id=58
:return: index
 - Function 'bndvi' takes 1 arguments: self.  Docstring:     Normalized Difference self.nir/self.blue self.blue-normalized difference
vegetation index
https://www.indexdatabase.de/db/i-single.php?id=135
:return: index
 - Function 'red_edge_ndvi' takes 1 arguments: self.  Docstring: Normalized Difference self.rededge/self.red
https://www.indexdatabase.de/db/i-single.php?id=235
:return: index
 - Function 'gndvi' takes 1 arguments: self.  Docstring: Normalized Difference self.nir/self.green self.green NDVI
https://www.indexdatabase.de/db/i-single.php?id=401
:return: index
 - Function 'gbndvi' takes 1 arguments: self.  Docstring: self.green-self.blue NDVI
https://www.indexdatabase.de/db/i-single.php?id=186
:return: index
 - Function 'grndvi' takes 1 arguments: self.  Docstring: self.green-self.red NDVI
https://www.indexdatabase.de/db/i-single.php?id=185
:return: index
 - Function 'rbndvi' takes 1 arguments: self.  Docstring: self.red-self.blue NDVI
https://www.indexdatabase.de/db/i-single.php?id=187
:return: index
 - Function 'pndvi' takes 1 arguments: self.  Docstring: Pan NDVI
https://www.indexdatabase.de/db/i-single.php?id=188
:return: index
 - Function 'atsavi' takes 4 arguments: self, x, a, b.  Docstring: Adjusted transformed soil-adjusted VI
https://www.indexdatabase.de/db/i-single.php?id=209
:return: index
 - Function 'bwdrvi' takes 1 arguments: self.  Docstring: self.blue-wide dynamic range vegetation index
https://www.indexdatabase.de/db/i-single.php?id=136
:return: index
 - Function 'ci_green' takes 1 arguments: self.  Docstring: Chlorophyll Index self.green
https://www.indexdatabase.de/db/i-single.php?id=128
:return: index
 - Function 'ci_rededge' takes 1 arguments: self.  Docstring: Chlorophyll Index self.redEdge
https://www.indexdatabase.de/db/i-single.php?id=131
:return: index
 - Function 'ci' takes 1 arguments: self.  Docstring: Coloration Index
https://www.indexdatabase.de/db/i-single.php?id=11
:return: index
 - Function 'ctvi' takes 1 arguments: self.  Docstring: Corrected Transformed Vegetation Index
https://www.indexdatabase.de/db/i-single.php?id=244
:return: index
 - Function 'gdvi' takes 1 arguments: self.  Docstring: Difference self.nir/self.green self.green Difference Vegetation Index
https://www.indexdatabase.de/db/i-single.php?id=27
:return: index
 - Function 'evi' takes 1 arguments: self.  Docstring: Enhanced Vegetation Index
https://www.indexdatabase.de/db/i-single.php?id=16
:return: index
 - Function 'gemi' takes 1 arguments: self.  Docstring: Global Environment Monitoring Index
https://www.indexdatabase.de/db/i-single.php?id=25
:return: index
 - Function 'gosavi' takes 2 arguments: self, y.  Docstring: self.green Optimized Soil Adjusted Vegetation Index
https://www.indexdatabase.de/db/i-single.php?id=29
mit Y = 0,16
:return: index
 - Function 'gsavi' takes 2 arguments: self, n.  Docstring: self.green Soil Adjusted Vegetation Index
https://www.indexdatabase.de/db/i-single.php?id=31
mit N = 0,5
:return: index
 - Function 'hue' takes 1 arguments: self.  Docstring: Hue
https://www.indexdatabase.de/db/i-single.php?id=34
:return: index
 - Function 'ivi' takes 3 arguments: self, a, b.  Docstring: Ideal vegetation index
https://www.indexdatabase.de/db/i-single.php?id=276
b=intercept of vegetation line
a=soil line slope
:return: index
 - Function 'ipvi' takes 1 arguments: self.  Docstring: Infraself.red percentage vegetation index
https://www.indexdatabase.de/db/i-single.php?id=35
:return: index
 - Function 'i' takes 1 arguments: self.  Docstring: Intensity
https://www.indexdatabase.de/db/i-single.php?id=36
:return: index
 - Function 'rvi' takes 1 arguments: self.  Docstring: Ratio-Vegetation-Index
http://www.seos-project.eu/modules/remotesensing/remotesensing-c03-s01-p01.html
:return: index
 - Function 'mrvi' takes 1 arguments: self.  Docstring: Modified Normalized Difference Vegetation Index RVI
https://www.indexdatabase.de/db/i-single.php?id=275
:return: index
 - Function 'm_savi' takes 1 arguments: self.  Docstring: Modified Soil Adjusted Vegetation Index
https://www.indexdatabase.de/db/i-single.php?id=44
:return: index
 - Function 'norm_g' takes 1 arguments: self.  Docstring: Norm G
https://www.indexdatabase.de/db/i-single.php?id=50
:return: index
 - Function 'norm_nir' takes 1 arguments: self.  Docstring: Norm self.nir
https://www.indexdatabase.de/db/i-single.php?id=51
:return: index
 - Function 'norm_r' takes 1 arguments: self.  Docstring: Norm R
https://www.indexdatabase.de/db/i-single.php?id=52
:return: index
 - Function 'ngrdi' takes 1 arguments: self.  Docstring:     Normalized Difference self.green/self.red Normalized self.green self.red
difference index, Visible Atmospherically Resistant Indices self.green
(VIself.green)
https://www.indexdatabase.de/db/i-single.php?id=390
:return: index
 - Function 'ri' takes 1 arguments: self.  Docstring: Normalized Difference self.red/self.green self.redness Index
https://www.indexdatabase.de/db/i-single.php?id=74
:return: index
 - Function 's' takes 1 arguments: self.  Docstring: Saturation
https://www.indexdatabase.de/db/i-single.php?id=77
:return: index
 - Function '_if' takes 1 arguments: self.  Docstring: Shape Index
https://www.indexdatabase.de/db/i-single.php?id=79
:return: index
 - Function 'dvi' takes 1 arguments: self.  Docstring: Simple Ratio self.nir/self.red Difference Vegetation Index, Vegetation Index
Number (VIN)
https://www.indexdatabase.de/db/i-single.php?id=12
:return: index
 - Function 'tvi' takes 1 arguments: self.  Docstring: Transformed Vegetation Index
https://www.indexdatabase.de/db/i-single.php?id=98
:return: index
 - Function 'ndre' takes 1 arguments: self.  No docstring available.

File: sepia.py
 - Function 'make_sepia' takes 2 arguments: img, factor.  Docstring: Function create sepia tone.
Source: https://en.wikipedia.org/wiki/Sepia_(color)
 - Function 'to_grayscale' takes 3 arguments: blue, green, red.  Docstring: Helper function to create pixel's greyscale representation
Src: https://pl.wikipedia.org/wiki/YUV
 - Function 'normalize' takes 1 arguments: value.  Docstring: Helper function to normalize R/G/B value -> return 255 if value > 255

File: test_digital_image_processing.py
 - Function 'test_convert_to_negative' takes 0 arguments: .  No docstring available.
 - Function 'test_change_contrast' takes 0 arguments: .  No docstring available.
 - Function 'test_gen_gaussian_kernel' takes 0 arguments: .  No docstring available.
 - Function 'test_canny' takes 0 arguments: .  No docstring available.
 - Function 'test_gen_gaussian_kernel_filter' takes 0 arguments: .  No docstring available.
 - Function 'test_convolve_filter' takes 0 arguments: .  No docstring available.
 - Function 'test_median_filter' takes 0 arguments: .  No docstring available.
 - Function 'test_sobel_filter' takes 0 arguments: .  No docstring available.
 - Function 'test_sepia' takes 0 arguments: .  No docstring available.
 - Function 'test_burkes' takes 1 arguments: file_path.  No docstring available.
 - Function 'test_nearest_neighbour' takes 1 arguments: file_path.  No docstring available.
 - Function 'test_local_binary_pattern' takes 0 arguments: .  No docstring available.

File: burkes.py
 - Function '__init__' takes 3 arguments: self, input_img, threshold.  No docstring available.
 - Function 'get_greyscale' takes 4 arguments: cls, blue, green, red.  Docstring: >>> Burkes.get_greyscale(3, 4, 5)
4.185
>>> Burkes.get_greyscale(0, 0, 0)
0.0
>>> Burkes.get_greyscale(255, 255, 255)
255.0
 - Function 'process' takes 1 arguments: self.  No docstring available.

File: canny.py
 - Function 'gen_gaussian_kernel' takes 2 arguments: k_size, sigma.  No docstring available.
 - Function 'suppress_non_maximum' takes 3 arguments: image_shape, gradient_direction, sobel_grad.  Docstring: Non-maximum suppression. If the edge strength of the current pixel is the largest
compared to the other pixels in the mask with the same direction, the value will be
preserved. Otherwise, the value will be suppressed.
 - Function 'detect_high_low_threshold' takes 6 arguments: image_shape, destination, threshold_low, threshold_high, weak, strong.  Docstring: High-Low threshold detection. If an edge pixel's gradient value is higher
than the high threshold value, it is marked as a strong edge pixel. If an
edge pixel's gradient value is smaller than the high threshold value and
larger than the low threshold value, it is marked as a weak edge pixel. If
an edge pixel's value is smaller than the low threshold value, it will be
suppressed.
 - Function 'track_edge' takes 4 arguments: image_shape, destination, weak, strong.  Docstring: Edge tracking. Usually a weak edge pixel caused from true edges will be connected
to a strong edge pixel while noise responses are unconnected. As long as there is
one strong edge pixel that is involved in its 8-connected neighborhood, that weak
edge point can be identified as one that should be preserved.
 - Function 'canny' takes 5 arguments: image, threshold_low, threshold_high, weak, strong.  No docstring available.

File: bilateral_filter.py
 - Function 'vec_gaussian' takes 2 arguments: img, variance.  No docstring available.
 - Function 'get_slice' takes 4 arguments: img, x, y, kernel_size.  No docstring available.
 - Function 'get_gauss_kernel' takes 2 arguments: kernel_size, spatial_variance.  No docstring available.
 - Function 'bilateral_filter' takes 4 arguments: img, spatial_variance, intensity_variance, kernel_size.  No docstring available.
 - Function 'parse_args' takes 1 arguments: args.  No docstring available.

File: convolve.py
 - Function 'im2col' takes 2 arguments: image, block_size.  No docstring available.
 - Function 'img_convolve' takes 2 arguments: image, filter_kernel.  No docstring available.

File: gabor_filter.py
 - Function 'gabor_filter_kernel' takes 6 arguments: ksize, sigma, theta, lambd, gamma, psi.  Docstring: :param ksize:   The kernelsize of the convolutional filter (ksize x ksize)
:param sigma:   standard deviation of the gaussian bell curve
:param theta:   The orientation of the normal to the parallel stripes
                of Gabor function.
:param lambd:   Wavelength of the sinusoidal component.
:param gamma:   The spatial aspect ratio and specifies the ellipticity
                of the support of Gabor function.
:param psi:     The phase offset of the sinusoidal function.

>>> gabor_filter_kernel(3, 8, 0, 10, 0, 0).tolist()
[[0.8027212023735046, 1.0, 0.8027212023735046], [0.8027212023735046, 1.0, 0.8027212023735046], [0.8027212023735046, 1.0, 0.8027212023735046]]

File: gaussian_filter.py
 - Function 'gen_gaussian_kernel' takes 2 arguments: k_size, sigma.  No docstring available.
 - Function 'gaussian_filter' takes 3 arguments: image, k_size, sigma.  No docstring available.

File: laplacian_filter.py
 - Function 'my_laplacian' takes 2 arguments: src, ksize.  Docstring: :param src: the source image, which should be a grayscale or color image.
:param ksize: the size of the kernel used to compute the Laplacian filter,
              which can be 1, 3, 5, or 7.

>>> my_laplacian(src=np.array([]), ksize=0)
Traceback (most recent call last):
    ...
ValueError: ksize must be in (1, 3, 5, 7)

File: local_binary_pattern.py
 - Function 'get_neighbors_pixel' takes 4 arguments: image, x_coordinate, y_coordinate, center.  Docstring: Comparing local neighborhood pixel value with threshold value of centre pixel.
Exception is required when neighborhood value of a center pixel value is null.
i.e. values present at boundaries.

:param image: The image we're working with
:param x_coordinate: x-coordinate of the  pixel
:param y_coordinate: The y coordinate of the pixel
:param center: center pixel value
:return: The value of the pixel is being returned.
 - Function 'local_binary_value' takes 3 arguments: image, x_coordinate, y_coordinate.  Docstring: It takes an image, an x and y coordinate, and returns the
decimal value of the local binary patternof the pixel
at that coordinate

:param image: the image to be processed
:param x_coordinate: x coordinate of the pixel
:param y_coordinate: the y coordinate of the pixel
:return: The decimal value of the binary value of the pixels
around the center pixel.

File: median_filter.py
 - Function 'median_filter' takes 2 arguments: gray_img, mask.  Docstring: :param gray_img: gray image
:param mask: mask size
:return: image with median filter

File: sobel_filter.py
 - Function 'sobel_filter' takes 1 arguments: image.  No docstring available.

File: histogram_stretch.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'stretch' takes 2 arguments: self, input_image.  No docstring available.
 - Function 'plot_histogram' takes 1 arguments: self.  No docstring available.
 - Function 'show_image' takes 1 arguments: self.  No docstring available.

File: dilation_operation.py
 - Function 'rgb_to_gray' takes 1 arguments: rgb.  Docstring: Return gray image from rgb image
>>> rgb_to_gray(np.array([[[127, 255, 0]]]))
array([[187.6453]])
>>> rgb_to_gray(np.array([[[0, 0, 0]]]))
array([[0.]])
>>> rgb_to_gray(np.array([[[2, 4, 1]]]))
array([[3.0598]])
>>> rgb_to_gray(np.array([[[26, 255, 14], [5, 147, 20], [1, 200, 0]]]))
array([[159.0524,  90.0635, 117.6989]])
 - Function 'gray_to_binary' takes 1 arguments: gray.  Docstring: Return binary image from gray image
>>> gray_to_binary(np.array([[127, 255, 0]]))
array([[False,  True, False]])
>>> gray_to_binary(np.array([[0]]))
array([[False]])
>>> gray_to_binary(np.array([[26.2409, 4.9315, 1.4729]]))
array([[False, False, False]])
>>> gray_to_binary(np.array([[26, 255, 14], [5, 147, 20], [1, 200, 0]]))
array([[False,  True, False],
       [False,  True, False],
       [False,  True, False]])
 - Function 'dilation' takes 2 arguments: image, kernel.  Docstring: Return dilated image
>>> dilation(np.array([[True, False, True]]), np.array([[0, 1, 0]]))
array([[False, False, False]])
>>> dilation(np.array([[False, False, True]]), np.array([[1, 0, 1]]))
array([[False, False, False]])

File: erosion_operation.py
 - Function 'rgb_to_gray' takes 1 arguments: rgb.  Docstring: Return gray image from rgb image

>>> rgb_to_gray(np.array([[[127, 255, 0]]]))
array([[187.6453]])
>>> rgb_to_gray(np.array([[[0, 0, 0]]]))
array([[0.]])
>>> rgb_to_gray(np.array([[[2, 4, 1]]]))
array([[3.0598]])
>>> rgb_to_gray(np.array([[[26, 255, 14], [5, 147, 20], [1, 200, 0]]]))
array([[159.0524,  90.0635, 117.6989]])
 - Function 'gray_to_binary' takes 1 arguments: gray.  Docstring: Return binary image from gray image

>>> gray_to_binary(np.array([[127, 255, 0]]))
array([[False,  True, False]])
>>> gray_to_binary(np.array([[0]]))
array([[False]])
>>> gray_to_binary(np.array([[26.2409, 4.9315, 1.4729]]))
array([[False, False, False]])
>>> gray_to_binary(np.array([[26, 255, 14], [5, 147, 20], [1, 200, 0]]))
array([[False,  True, False],
       [False,  True, False],
       [False,  True, False]])
 - Function 'erosion' takes 2 arguments: image, kernel.  Docstring: Return eroded image

>>> erosion(np.array([[True, True, False]]), np.array([[0, 1, 0]]))
array([[False, False, False]])
>>> erosion(np.array([[True, False, False]]), np.array([[1, 1, 0]]))
array([[False, False, False]])

File: resize.py
 - Function '__init__' takes 4 arguments: self, img, dst_width, dst_height.  No docstring available.
 - Function 'process' takes 1 arguments: self.  No docstring available.
 - Function 'get_x' takes 2 arguments: self, x.  Docstring: Get parent X coordinate for destination X
:param x: Destination X coordinate
:return: Parent X coordinate based on `x ratio`
>>> nn = NearestNeighbour(imread("digital_image_processing/image_data/lena.jpg",
...                              1), 100, 100)
>>> nn.ratio_x = 0.5
>>> nn.get_x(4)
2
 - Function 'get_y' takes 2 arguments: self, y.  Docstring: Get parent Y coordinate for destination Y
:param y: Destination X coordinate
:return: Parent X coordinate based on `y ratio`
>>> nn = NearestNeighbour(imread("digital_image_processing/image_data/lena.jpg",
...                              1), 100, 100)
>>> nn.ratio_y = 0.5
>>> nn.get_y(4)
2

File: rotation.py
 - Function 'get_rotation' takes 5 arguments: img, pt1, pt2, rows, cols.  Docstring: Get image rotation
:param img: np.ndarray
:param pt1: 3x2 list
:param pt2: 3x2 list
:param rows: columns image shape
:param cols: rows image shape
:return: np.ndarray

File: closest_pair_of_points.py
 - Function 'euclidean_distance_sqr' takes 2 arguments: point1, point2.  Docstring: >>> euclidean_distance_sqr([1,2],[2,4])
5
 - Function 'column_based_sort' takes 2 arguments: array, column.  Docstring: >>> column_based_sort([(5, 1), (4, 2), (3, 0)], 1)
[(3, 0), (5, 1), (4, 2)]
 - Function 'dis_between_closest_pair' takes 3 arguments: points, points_counts, min_dis.  Docstring: brute force approach to find distance between closest pair points

Parameters :
points, points_count, min_dis (list(tuple(int, int)), int, int)

Returns :
min_dis (float):  distance between closest pair of points

>>> dis_between_closest_pair([[1,2],[2,4],[5,7],[8,9],[11,0]],5)
5
 - Function 'dis_between_closest_in_strip' takes 3 arguments: points, points_counts, min_dis.  Docstring: closest pair of points in strip

Parameters :
points, points_count, min_dis (list(tuple(int, int)), int, int)

Returns :
min_dis (float):  distance btw closest pair of points in the strip (< min_dis)

>>> dis_between_closest_in_strip([[1,2],[2,4],[5,7],[8,9],[11,0]],5)
85
 - Function 'closest_pair_of_points_sqr' takes 3 arguments: points_sorted_on_x, points_sorted_on_y, points_counts.  Docstring: divide and conquer approach

Parameters :
points, points_count (list(tuple(int, int)), int)

Returns :
(float):  distance btw closest pair of points

>>> closest_pair_of_points_sqr([(1, 2), (3, 4)], [(5, 6), (7, 8)], 2)
8
 - Function 'closest_pair_of_points' takes 2 arguments: points, points_counts.  Docstring: >>> closest_pair_of_points([(2, 3), (12, 30)], len([(2, 3), (12, 30)]))
28.792360097775937

File: convex_hull.py
 - Function '__init__' takes 3 arguments: self, x, y.  No docstring available.
 - Function '__eq__' takes 2 arguments: self, other.  No docstring available.
 - Function '__ne__' takes 2 arguments: self, other.  No docstring available.
 - Function '__gt__' takes 2 arguments: self, other.  No docstring available.
 - Function '__lt__' takes 2 arguments: self, other.  No docstring available.
 - Function '__ge__' takes 2 arguments: self, other.  No docstring available.
 - Function '__le__' takes 2 arguments: self, other.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function '__hash__' takes 1 arguments: self.  No docstring available.
 - Function '_construct_points' takes 1 arguments: list_of_tuples.  Docstring: constructs a list of points from an array-like object of numbers

Arguments
---------

list_of_tuples: array-like object of type numbers. Acceptable types so far
are lists, tuples and sets.

Returns
--------
points: a list where each item is of type Point. This contains only objects
which can be converted into a Point.

Examples
-------
>>> _construct_points([[1, 1], [2, -1], [0.3, 4]])
[(1.0, 1.0), (2.0, -1.0), (0.3, 4.0)]
>>> _construct_points([1, 2])
Ignoring deformed point 1. All points must have at least 2 coordinates.
Ignoring deformed point 2. All points must have at least 2 coordinates.
[]
>>> _construct_points([])
[]
>>> _construct_points(None)
[]
 - Function '_validate_input' takes 1 arguments: points.  Docstring: validates an input instance before a convex-hull algorithms uses it

Parameters
---------
points: array-like, the 2d points to validate before using with
a convex-hull algorithm. The elements of points must be either lists, tuples or
Points.

Returns
-------
points: array_like, an iterable of all well-defined Points constructed passed in.


Exception
---------
ValueError: if points is empty or None, or if a wrong data structure like a scalar
             is passed

TypeError: if an iterable but non-indexable object (eg. dictionary) is passed.
            The exception to this a set which we'll convert to a list before using


Examples
-------
>>> _validate_input([[1, 2]])
[(1.0, 2.0)]
>>> _validate_input([(1, 2)])
[(1.0, 2.0)]
>>> _validate_input([Point(2, 1), Point(-1, 2)])
[(2.0, 1.0), (-1.0, 2.0)]
>>> _validate_input([])
Traceback (most recent call last):
    ...
ValueError: Expecting a list of points but got []
>>> _validate_input(1)
Traceback (most recent call last):
    ...
ValueError: Expecting an iterable object but got an non-iterable type 1
 - Function '_det' takes 3 arguments: a, b, c.  Docstring: Computes the sign perpendicular distance of a 2d point c from a line segment
ab. The sign indicates the direction of c relative to ab.
A Positive value means c is above ab (to the left), while a negative value
means c is below ab (to the right). 0 means all three points are on a straight line.

As a side note, 0.5 * abs|det| is the area of triangle abc

Parameters
----------
a: point, the point on the left end of line segment ab
b: point, the point on the right end of line segment ab
c: point, the point for which the direction and location is desired.

Returns
--------
det: float, abs(det) is the distance of c from ab. The sign
indicates which side of line segment ab c is. det is computed as
(a_xb_y + c_xa_y + b_xc_y) - (a_yb_x + c_ya_x + b_yc_x)

Examples
----------
>>> _det(Point(1, 1), Point(1, 2), Point(1, 5))
0.0
>>> _det(Point(0, 0), Point(10, 0), Point(0, 10))
100.0
>>> _det(Point(0, 0), Point(10, 0), Point(0, -10))
-100.0
 - Function 'convex_hull_bf' takes 1 arguments: points.  Docstring: Constructs the convex hull of a set of 2D points using a brute force algorithm.
The algorithm basically considers all combinations of points (i, j) and uses the
definition of convexity to determine whether (i, j) is part of the convex hull or
not.  (i, j) is part of the convex hull if and only iff there are no points on both
sides of the line segment connecting the ij, and there is no point k such that k is
on either end of the ij.

Runtime: O(n^3) - definitely horrible

Parameters
---------
points: array-like of object of Points, lists or tuples.
The set of  2d points for which the convex-hull is needed

Returns
------
convex_set: list, the convex-hull of points sorted in non-decreasing order.

See Also
--------
convex_hull_recursive,

 Examples
 ---------
 >>> convex_hull_bf([[0, 0], [1, 0], [10, 1]])
 [(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]
 >>> convex_hull_bf([[0, 0], [1, 0], [10, 0]])
 [(0.0, 0.0), (10.0, 0.0)]
 >>> convex_hull_bf([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],
 ...                 [-0.75, 1]])
 [(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]
 >>> convex_hull_bf([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),
 ...                 (2, -1), (2, -4), (1, -3)])
 [(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]
 - Function 'convex_hull_recursive' takes 1 arguments: points.  Docstring: Constructs the convex hull of a set of 2D points using a divide-and-conquer strategy
The algorithm exploits the geometric properties of the problem by repeatedly
partitioning the set of points into smaller hulls, and finding the convex hull of
these smaller hulls.  The union of the convex hull from smaller hulls is the
solution to the convex hull of the larger problem.

Parameter
---------
points: array-like of object of Points, lists or tuples.
The set of  2d points for which the convex-hull is needed

Runtime: O(n log n)

Returns
-------
convex_set: list, the convex-hull of points sorted in non-decreasing order.

Examples
---------
>>> convex_hull_recursive([[0, 0], [1, 0], [10, 1]])
[(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]
>>> convex_hull_recursive([[0, 0], [1, 0], [10, 0]])
[(0.0, 0.0), (10.0, 0.0)]
>>> convex_hull_recursive([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],
...                        [-0.75, 1]])
[(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]
>>> convex_hull_recursive([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),
...                        (2, -1), (2, -4), (1, -3)])
[(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]
 - Function '_construct_hull' takes 4 arguments: points, left, right, convex_set.  Docstring: Parameters
---------
points: list or None, the hull of points from which to choose the next convex-hull
    point
left: Point, the point to the left  of line segment joining left and right
right: The point to the right of the line segment joining left and right
convex_set: set, the current convex-hull. The state of convex-set gets updated by
    this function

Note
----
For the line segment 'ab', 'a' is on the left and 'b' on the right.
but the reverse is true for the line segment 'ba'.

Returns
-------
Nothing, only updates the state of convex-set
 - Function 'convex_hull_melkman' takes 1 arguments: points.  Docstring: Constructs the convex hull of a set of 2D points using the melkman algorithm.
The algorithm works by iteratively inserting points of a simple polygonal chain
(meaning that no line segments between two consecutive points cross each other).
Sorting the points yields such a polygonal chain.

For a detailed description, see http://cgm.cs.mcgill.ca/~athens/cs601/Melkman.html

Runtime: O(n log n) - O(n) if points are already sorted in the input

Parameters
---------
points: array-like of object of Points, lists or tuples.
The set of 2d points for which the convex-hull is needed

Returns
------
convex_set: list, the convex-hull of points sorted in non-decreasing order.

See Also
--------

Examples
---------
>>> convex_hull_melkman([[0, 0], [1, 0], [10, 1]])
[(0.0, 0.0), (1.0, 0.0), (10.0, 1.0)]
>>> convex_hull_melkman([[0, 0], [1, 0], [10, 0]])
[(0.0, 0.0), (10.0, 0.0)]
>>> convex_hull_melkman([[-1, 1],[-1, -1], [0, 0], [0.5, 0.5], [1, -1], [1, 1],
...                 [-0.75, 1]])
[(-1.0, -1.0), (-1.0, 1.0), (1.0, -1.0), (1.0, 1.0)]
>>> convex_hull_melkman([(0, 3), (2, 2), (1, 1), (2, 1), (3, 0), (0, 0), (3, 3),
...                 (2, -1), (2, -4), (1, -3)])
[(0.0, 0.0), (0.0, 3.0), (1.0, -3.0), (2.0, -4.0), (3.0, 0.0), (3.0, 3.0)]
 - Function 'main' takes 0 arguments: .  No docstring available.

File: heaps_algorithm.py
 - Function 'heaps' takes 1 arguments: arr.  Docstring: Pure python implementation of the Heap's algorithm (recursive version),
returning all permutations of a list.
>>> heaps([])
[()]
>>> heaps([0])
[(0,)]
>>> heaps([-1, 1])
[(-1, 1), (1, -1)]
>>> heaps([1, 2, 3])
[(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)]
>>> from itertools import permutations
>>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3]))
True
>>> all(sorted(heaps(x)) == sorted(permutations(x))
...     for x in ([], [0], [-1, 1], [1, 2, 3]))
True
 - Function 'generate' takes 2 arguments: k, arr.  No docstring available.

File: heaps_algorithm_iterative.py
 - Function 'heaps' takes 1 arguments: arr.  Docstring: Pure python implementation of the iterative Heap's algorithm,
returning all permutations of a list.
>>> heaps([])
[()]
>>> heaps([0])
[(0,)]
>>> heaps([-1, 1])
[(-1, 1), (1, -1)]
>>> heaps([1, 2, 3])
[(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)]
>>> from itertools import permutations
>>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3]))
True
>>> all(sorted(heaps(x)) == sorted(permutations(x))
...     for x in ([], [0], [-1, 1], [1, 2, 3]))
True
 - Function 'generate' takes 2 arguments: n, arr.  No docstring available.

File: inversions.py
 - Function 'count_inversions_bf' takes 1 arguments: arr.  Docstring: Counts the number of inversions using a naive brute-force algorithm
Parameters
----------
arr: arr: array-like, the list containing the items for which the number
of inversions is desired. The elements of `arr` must be comparable.
Returns
-------
num_inversions: The total number of inversions in `arr`
Examples
---------
 >>> count_inversions_bf([1, 4, 2, 4, 1])
 4
 >>> count_inversions_bf([1, 1, 2, 4, 4])
 0
 >>> count_inversions_bf([])
 0
 - Function 'count_inversions_recursive' takes 1 arguments: arr.  Docstring: Counts the number of inversions using a divide-and-conquer algorithm
Parameters
-----------
arr: array-like, the list containing the items for which the number
of inversions is desired. The elements of `arr` must be comparable.
Returns
-------
C: a sorted copy of `arr`.
num_inversions: int, the total number of inversions in 'arr'
Examples
--------
>>> count_inversions_recursive([1, 4, 2, 4, 1])
([1, 1, 2, 4, 4], 4)
>>> count_inversions_recursive([1, 1, 2, 4, 4])
([1, 1, 2, 4, 4], 0)
>>> count_inversions_recursive([])
([], 0)
 - Function '_count_cross_inversions' takes 2 arguments: p, q.  Docstring: Counts the inversions across two sorted arrays.
And combine the two arrays into one sorted array
For all 1<= i<=len(P) and for all 1 <= j <= len(Q),
if P[i] > Q[j], then (i, j) is a cross inversion
Parameters
----------
P: array-like, sorted in non-decreasing order
Q: array-like, sorted in non-decreasing order
Returns
------
R: array-like, a sorted array of the elements of `P` and `Q`
num_inversion: int, the number of inversions across `P` and `Q`
Examples
--------
>>> _count_cross_inversions([1, 2, 3], [0, 2, 5])
([0, 1, 2, 2, 3, 5], 4)
>>> _count_cross_inversions([1, 2, 3], [3, 4, 5])
([1, 2, 3, 3, 4, 5], 0)
 - Function 'main' takes 0 arguments: .  No docstring available.

File: kth_order_statistic.py
 - Function 'random_pivot' takes 1 arguments: lst.  Docstring: Choose a random pivot for the list.
We can use a more sophisticated algorithm here, such as the median-of-medians
algorithm.
 - Function 'kth_number' takes 2 arguments: lst, k.  Docstring: Return the kth smallest number in lst.
>>> kth_number([2, 1, 3, 4, 5], 3)
3
>>> kth_number([2, 1, 3, 4, 5], 1)
1
>>> kth_number([2, 1, 3, 4, 5], 5)
5
>>> kth_number([3, 2, 5, 6, 7, 8], 2)
3
>>> kth_number([25, 21, 98, 100, 76, 22, 43, 60, 89, 87], 4)
43

File: max_difference_pair.py
 - Function 'max_difference' takes 1 arguments: a.  Docstring: We are given an array A[1..n] of integers, n >= 1. We want to
find a pair of indices (i, j) such that
1 <= i <= j <= n and A[j] - A[i] is as large as possible.

Explanation:
https://www.geeksforgeeks.org/maximum-difference-between-two-elements/

>>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])
(1, 9)

File: max_subarray.py
 - Function 'max_subarray' takes 3 arguments: arr, low, high.  Docstring: Solves the maximum subarray problem using divide and conquer.
:param arr:     the given array of numbers
:param low:     the start index
:param high:    the end index
:return:        the start index of the maximum subarray, the end index of the
                maximum subarray, and the maximum subarray sum

>>> nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
>>> max_subarray(nums, 0, len(nums) - 1)
(3, 6, 6)
>>> nums = [2, 8, 9]
>>> max_subarray(nums, 0, len(nums) - 1)
(0, 2, 19)
>>> nums = [0, 0]
>>> max_subarray(nums, 0, len(nums) - 1)
(0, 0, 0)
>>> nums = [-1.0, 0.0, 1.0]
>>> max_subarray(nums, 0, len(nums) - 1)
(2, 2, 1.0)
>>> nums = [-2, -3, -1, -4, -6]
>>> max_subarray(nums, 0, len(nums) - 1)
(2, 2, -1)
>>> max_subarray([], 0, 0)
(None, None, 0)
 - Function 'max_cross_sum' takes 4 arguments: arr, low, mid, high.  No docstring available.
 - Function 'time_max_subarray' takes 1 arguments: input_size.  No docstring available.
 - Function 'plot_runtimes' takes 0 arguments: .  No docstring available.

File: mergesort.py
 - Function 'merge' takes 2 arguments: left_half, right_half.  Docstring: Helper function for mergesort.

>>> left_half = [-2]
>>> right_half = [-1]
>>> merge(left_half, right_half)
[-2, -1]

>>> left_half = [1,2,3]
>>> right_half = [4,5,6]
>>> merge(left_half, right_half)
[1, 2, 3, 4, 5, 6]

>>> left_half = [-2]
>>> right_half = [-1]
>>> merge(left_half, right_half)
[-2, -1]

>>> left_half = [12, 15]
>>> right_half = [13, 14]
>>> merge(left_half, right_half)
[12, 13, 14, 15]

>>> left_half = []
>>> right_half = []
>>> merge(left_half, right_half)
[]
 - Function 'merge_sort' takes 1 arguments: array.  Docstring: Returns a list of sorted array elements using merge sort.

>>> from random import shuffle
>>> array = [-2, 3, -10, 11, 99, 100000, 100, -200]
>>> shuffle(array)
>>> merge_sort(array)
[-200, -10, -2, 3, 11, 99, 100, 100000]

>>> shuffle(array)
>>> merge_sort(array)
[-200, -10, -2, 3, 11, 99, 100, 100000]

>>> array = [-200]
>>> merge_sort(array)
[-200]

>>> array = [-2, 3, -10, 11, 99, 100000, 100, -200]
>>> shuffle(array)
>>> sorted(array) == merge_sort(array)
True

>>> array = [-2]
>>> merge_sort(array)
[-2]

>>> array = []
>>> merge_sort(array)
[]

>>> array = [10000000, 1, -1111111111, 101111111112, 9000002]
>>> sorted(array) == merge_sort(array)
True

File: peak.py
 - Function 'peak' takes 1 arguments: lst.  Docstring: Return the peak value of `lst`.
>>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])
5
>>> peak([1, 10, 9, 8, 7, 6, 5, 4])
10
>>> peak([1, 9, 8, 7])
9
>>> peak([1, 2, 3, 4, 5, 6, 7, 0])
7
>>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])
4

File: power.py
 - Function 'actual_power' takes 2 arguments: a, b.  Docstring: Function using divide and conquer to calculate a^b.
It only works for integer a,b.

:param a: The base of the power operation, an integer.
:param b: The exponent of the power operation, a non-negative integer.
:return: The result of a^b.

Examples:
>>> actual_power(3, 2)
9
>>> actual_power(5, 3)
125
>>> actual_power(2, 5)
32
>>> actual_power(7, 0)
1
 - Function 'power' takes 2 arguments: a, b.  Docstring: :param a: The base (integer).
:param b: The exponent (integer).
:return: The result of a^b, as a float for negative exponents.

>>> power(4,6)
4096
>>> power(2,3)
8
>>> power(-2,3)
-8
>>> power(2,-3)
0.125
>>> power(-2,-3)
-0.125

File: strassen_matrix_multiplication.py
 - Function 'default_matrix_multiplication' takes 2 arguments: a, b.  Docstring: Multiplication only for 2x2 matrices
 - Function 'matrix_addition' takes 2 arguments: matrix_a, matrix_b.  No docstring available.
 - Function 'matrix_subtraction' takes 2 arguments: matrix_a, matrix_b.  No docstring available.
 - Function 'split_matrix' takes 1 arguments: a.  Docstring: Given an even length matrix, returns the top_left, top_right, bot_left, bot_right
quadrant.

>>> split_matrix([[4,3,2,4],[2,3,1,1],[6,5,4,3],[8,4,1,6]])
([[4, 3], [2, 3]], [[2, 4], [1, 1]], [[6, 5], [8, 4]], [[4, 3], [1, 6]])
>>> split_matrix([
...     [4,3,2,4,4,3,2,4],[2,3,1,1,2,3,1,1],[6,5,4,3,6,5,4,3],[8,4,1,6,8,4,1,6],
...     [4,3,2,4,4,3,2,4],[2,3,1,1,2,3,1,1],[6,5,4,3,6,5,4,3],[8,4,1,6,8,4,1,6]
... ])  # doctest: +NORMALIZE_WHITESPACE
([[4, 3, 2, 4], [2, 3, 1, 1], [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4],
  [2, 3, 1, 1], [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4], [2, 3, 1, 1],
  [6, 5, 4, 3], [8, 4, 1, 6]], [[4, 3, 2, 4], [2, 3, 1, 1], [6, 5, 4, 3],
  [8, 4, 1, 6]])
 - Function 'matrix_dimensions' takes 1 arguments: matrix.  No docstring available.
 - Function 'print_matrix' takes 1 arguments: matrix.  No docstring available.
 - Function 'actual_strassen' takes 2 arguments: matrix_a, matrix_b.  Docstring: Recursive function to calculate the product of two matrices, using the Strassen
Algorithm. It only supports square matrices of any size that is a power of 2.
 - Function 'strassen' takes 2 arguments: matrix1, matrix2.  Docstring: >>> strassen([[2,1,3],[3,4,6],[1,4,2],[7,6,7]], [[4,2,3,4],[2,1,1,1],[8,6,4,2]])
[[34, 23, 19, 15], [68, 46, 37, 28], [28, 18, 15, 12], [96, 62, 55, 48]]
>>> strassen([[3,7,5,6,9],[1,5,3,7,8],[1,4,4,5,7]], [[2,4],[5,2],[1,7],[5,5],[7,8]])
[[139, 163], [121, 134], [100, 121]]

File: abbreviation.py
 - Function 'abbr' takes 2 arguments: a, b.  Docstring: >>> abbr("daBcd", "ABC")
True
>>> abbr("dBcd", "ABC")
False

File: all_construct.py
 - Function 'all_construct' takes 2 arguments: target, word_bank.  Docstring:     returns the list containing all the possible
    combinations a string(target) can be constructed from
    the given list of substrings(word_bank)
>>> all_construct("hello", ["he", "l", "o"])
[['he', 'l', 'l', 'o']]
>>> all_construct("purple",["purp","p","ur","le","purpl"])
[['purp', 'le'], ['p', 'ur', 'p', 'le']]

File: bitmask.py
 - Function '__init__' takes 3 arguments: self, task_performed, total.  No docstring available.
 - Function 'count_ways_until' takes 3 arguments: self, mask, task_no.  No docstring available.
 - Function 'count_no_of_ways' takes 2 arguments: self, task_performed.  No docstring available.

File: catalan_numbers.py
 - Function 'catalan_numbers' takes 1 arguments: upper_limit.  Docstring: Return a list of the Catalan number sequence from 0 through `upper_limit`.

>>> catalan_numbers(5)
[1, 1, 2, 5, 14, 42]
>>> catalan_numbers(2)
[1, 1, 2]
>>> catalan_numbers(-1)
Traceback (most recent call last):
ValueError: Limit for the Catalan sequence must be  0

File: climbing_stairs.py
 - Function 'climb_stairs' takes 1 arguments: number_of_steps.  Docstring: LeetCdoe No.70: Climbing Stairs
Distinct ways to climb a number_of_steps staircase where each time you can either
climb 1 or 2 steps.

Args:
    number_of_steps: number of steps on the staircase

Returns:
    Distinct ways to climb a number_of_steps staircase

Raises:
    AssertionError: number_of_steps not positive integer

>>> climb_stairs(3)
3
>>> climb_stairs(1)
1
>>> climb_stairs(-7)  # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
AssertionError: number_of_steps needs to be positive integer, your input -7

File: combination_sum_iv.py
 - Function 'combination_sum_iv' takes 2 arguments: array, target.  Docstring: Function checks the all possible combinations, and returns the count
of possible combination in exponential Time Complexity.

>>> combination_sum_iv([1,2,5], 5)
9
 - Function 'count_of_possible_combinations' takes 1 arguments: target.  No docstring available.
 - Function 'combination_sum_iv_dp_array' takes 2 arguments: array, target.  Docstring: Function checks the all possible combinations, and returns the count
of possible combination in O(N^2) Time Complexity as we are using Dynamic
programming array here.

>>> combination_sum_iv_dp_array([1,2,5], 5)
9
 - Function 'count_of_possible_combinations_with_dp_array' takes 2 arguments: target, dp_array.  No docstring available.
 - Function 'combination_sum_iv_bottom_up' takes 3 arguments: n, array, target.  Docstring: Function checks the all possible combinations with using bottom up approach,
and returns the count of possible combination in O(N^2) Time Complexity
as we are using Dynamic programming array here.

>>> combination_sum_iv_bottom_up(3, [1,2,5], 5)
9

File: edit_distance.py
 - Function 'edit_distance' takes 2 arguments: source, target.  Docstring: Edit distance algorithm is a string metric, i.e., it is a way of quantifying how
dissimilar two strings are to one another. It is measured by counting the minimum
number of operations required to transform one string into another.

This implementation assumes that the cost of operations (insertion, deletion and
substitution) is always 1

Args:
source: the initial string with respect to which we are calculating the edit
    distance for the target
target: the target string, formed after performing n operations on the source string

>>> edit_distance("GATTIC", "GALTIC")
1

File: factorial.py
 - Function 'factorial' takes 1 arguments: number.  Docstring: Calculate the factorial of specified number (n!).

>>> import math
>>> all(factorial(i) == math.factorial(i) for i in range(20))
True
>>> factorial(0.1)
Traceback (most recent call last):
    ...
ValueError: factorial() only accepts integral values
>>> factorial(-1)
Traceback (most recent call last):
    ...
ValueError: factorial() not defined for negative values
>>> factorial(1)
1
>>> factorial(6)
720
>>> factorial(0)
1
 - Function 'factorial_recursive' takes 1 arguments: n.  Docstring: Calculate the factorial of a positive integer
https://en.wikipedia.org/wiki/Factorial

>>> import math
>>> all(factorial(i) == math.factorial(i) for i in range(20))
True
>>> factorial(0.1)
Traceback (most recent call last):
    ...
ValueError: factorial() only accepts integral values
>>> factorial(-1)
Traceback (most recent call last):
    ...
ValueError: factorial() not defined for negative values

File: fast_fibonacci.py
 - Function 'fibonacci' takes 1 arguments: n.  Docstring: return F(n)
>>> [fibonacci(i) for i in range(13)]
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
 - Function '_fib' takes 1 arguments: n.  No docstring available.

File: fibonacci.py
 - Function 'time_func' takes 1 arguments: func.  Docstring: Times the execution of a function with parameters
 - Function 'fib_iterative_yield' takes 1 arguments: n.  Docstring: Calculates the first n (1-indexed) Fibonacci numbers using iteration with yield
>>> list(fib_iterative_yield(0))
[0]
>>> tuple(fib_iterative_yield(1))
(0, 1)
>>> tuple(fib_iterative_yield(5))
(0, 1, 1, 2, 3, 5)
>>> tuple(fib_iterative_yield(10))
(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55)
>>> tuple(fib_iterative_yield(-1))
Traceback (most recent call last):
    ...
ValueError: n is negative
 - Function 'fib_iterative' takes 1 arguments: n.  Docstring: Calculates the first n (0-indexed) Fibonacci numbers using iteration
>>> fib_iterative(0)
[0]
>>> fib_iterative(1)
[0, 1]
>>> fib_iterative(5)
[0, 1, 1, 2, 3, 5]
>>> fib_iterative(10)
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
>>> fib_iterative(-1)
Traceback (most recent call last):
    ...
ValueError: n is negative
 - Function 'fib_recursive' takes 1 arguments: n.  Docstring: Calculates the first n (0-indexed) Fibonacci numbers using recursion
>>> fib_iterative(0)
[0]
>>> fib_iterative(1)
[0, 1]
>>> fib_iterative(5)
[0, 1, 1, 2, 3, 5]
>>> fib_iterative(10)
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
>>> fib_iterative(-1)
Traceback (most recent call last):
    ...
ValueError: n is negative
 - Function 'fib_recursive_term' takes 1 arguments: i.  Docstring: Calculates the i-th (0-indexed) Fibonacci number using recursion
>>> fib_recursive_term(0)
0
>>> fib_recursive_term(1)
1
>>> fib_recursive_term(5)
5
>>> fib_recursive_term(10)
55
>>> fib_recursive_term(-1)
Traceback (most recent call last):
    ...
Exception: n is negative
 - Function 'fib_recursive_cached' takes 1 arguments: n.  Docstring: Calculates the first n (0-indexed) Fibonacci numbers using recursion
>>> fib_iterative(0)
[0]
>>> fib_iterative(1)
[0, 1]
>>> fib_iterative(5)
[0, 1, 1, 2, 3, 5]
>>> fib_iterative(10)
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
>>> fib_iterative(-1)
Traceback (most recent call last):
    ...
ValueError: n is negative
 - Function 'fib_recursive_term' takes 1 arguments: i.  Docstring: Calculates the i-th (0-indexed) Fibonacci number using recursion
 - Function 'fib_memoization' takes 1 arguments: n.  Docstring: Calculates the first n (0-indexed) Fibonacci numbers using memoization
>>> fib_memoization(0)
[0]
>>> fib_memoization(1)
[0, 1]
>>> fib_memoization(5)
[0, 1, 1, 2, 3, 5]
>>> fib_memoization(10)
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
>>> fib_iterative(-1)
Traceback (most recent call last):
    ...
ValueError: n is negative
 - Function 'rec_fn_memoized' takes 1 arguments: num.  No docstring available.
 - Function 'fib_binet' takes 1 arguments: n.  Docstring: Calculates the first n (0-indexed) Fibonacci numbers using a simplified form
of Binet's formula:
https://en.m.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding

NOTE 1: this function diverges from fib_iterative at around n = 71, likely
due to compounding floating-point arithmetic errors

NOTE 2: this function doesn't accept n >= 1475 because it overflows
thereafter due to the size limitations of Python floats
>>> fib_binet(0)
[0]
>>> fib_binet(1)
[0, 1]
>>> fib_binet(5)
[0, 1, 1, 2, 3, 5]
>>> fib_binet(10)
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
>>> fib_binet(-1)
Traceback (most recent call last):
    ...
ValueError: n is negative
>>> fib_binet(1475)
Traceback (most recent call last):
    ...
ValueError: n is too large

File: fizz_buzz.py
 - Function 'fizz_buzz' takes 2 arguments: number, iterations.  Docstring: Plays FizzBuzz.
Prints Fizz if number is a multiple of 3.
Prints Buzz if its a multiple of 5.
Prints FizzBuzz if its a multiple of both 3 and 5 or 15.
Else Prints The Number Itself.
>>> fizz_buzz(1,7)
'1 2 Fizz 4 Buzz Fizz 7 '
>>> fizz_buzz(1,0)
Traceback (most recent call last):
  ...
ValueError: Iterations must be done more than 0 times to play FizzBuzz
>>> fizz_buzz(-5,5)
Traceback (most recent call last):
    ...
ValueError: starting number must be
                         and integer and be more than 0
>>> fizz_buzz(10,-5)
Traceback (most recent call last):
    ...
ValueError: Iterations must be done more than 0 times to play FizzBuzz
>>> fizz_buzz(1.5,5)
Traceback (most recent call last):
    ...
ValueError: starting number must be
                         and integer and be more than 0
>>> fizz_buzz(1,5.5)
Traceback (most recent call last):
    ...
ValueError: iterations must be defined as integers

File: floyd_warshall.py
 - Function '__init__' takes 2 arguments: self, n.  No docstring available.
 - Function 'add_edge' takes 4 arguments: self, u, v, w.  No docstring available.
 - Function 'floyd_warshall' takes 1 arguments: self.  No docstring available.
 - Function 'show_min' takes 3 arguments: self, u, v.  No docstring available.

File: integer_partition.py
 - Function 'partition' takes 1 arguments: m.  Docstring: >>> partition(5)
7
>>> partition(7)
15
>>> partition(100)
190569292
>>> partition(1_000)
24061467864032622473692149727991
>>> partition(-7)
Traceback (most recent call last):
    ...
IndexError: list index out of range
>>> partition(0)
Traceback (most recent call last):
    ...
IndexError: list assignment index out of range
>>> partition(7.8)
Traceback (most recent call last):
    ...
TypeError: 'float' object cannot be interpreted as an integer

File: iterating_through_submasks.py
 - Function 'list_of_submasks' takes 1 arguments: mask.  Docstring: Args:
    mask : number which shows mask ( always integer > 0, zero does not have any
        submasks )

Returns:
    all_submasks : the list of submasks of mask (mask s is called submask of mask
    m if only bits that were included in original mask are set

Raises:
    AssertionError: mask not positive integer

>>> list_of_submasks(15)
[15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
>>> list_of_submasks(13)
[13, 12, 9, 8, 5, 4, 1]
>>> list_of_submasks(-7)  # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
AssertionError: mask needs to be positive integer, your input -7
>>> list_of_submasks(0)  # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
AssertionError: mask needs to be positive integer, your input 0

File: knapsack.py
 - Function 'knapsack' takes 4 arguments: capacity, weights, values, counter.  Docstring: Returns the maximum value that can be put in a knapsack of a capacity cap,
whereby each weight w has a specific value val.

>>> cap = 50
>>> val = [60, 100, 120]
>>> w = [10, 20, 30]
>>> c = len(val)
>>> knapsack(cap, w, val, c)
220

The result is 220 cause the values of 100 and 120 got the weight of 50
which is the limit of the capacity.

File: k_means_clustering_tensorflow.py
 - Function 'tf_k_means_cluster' takes 2 arguments: vectors, noofclusters.  Docstring: K-Means Clustering using TensorFlow.
'vectors' should be a n*k 2-D NumPy array, where n is the number
of vectors of dimensionality k.
'noofclusters' should be an integer.

File: largest_divisible_subset.py
 - Function 'largest_divisible_subset' takes 1 arguments: items.  Docstring: Algorithm to find the biggest subset in the given array such that for any 2 elements
x and y in the subset, either x divides y or y divides x.
>>> largest_divisible_subset([1, 16, 7, 8, 4])
[16, 8, 4, 1]
>>> largest_divisible_subset([1, 2, 3])
[2, 1]
>>> largest_divisible_subset([-1, -2, -3])
[-3]
>>> largest_divisible_subset([1, 2, 4, 8])
[8, 4, 2, 1]
>>> largest_divisible_subset((1, 2, 4, 8))
[8, 4, 2, 1]
>>> largest_divisible_subset([1, 1, 1])
[1, 1, 1]
>>> largest_divisible_subset([0, 0, 0])
[0, 0, 0]
>>> largest_divisible_subset([-1, -1, -1])
[-1, -1, -1]
>>> largest_divisible_subset([])
[]

File: longest_common_subsequence.py
 - Function 'longest_common_subsequence' takes 2 arguments: x, y.  Docstring: Finds the longest common subsequence between two strings. Also returns the
The subsequence found

Parameters
----------

x: str, one of the strings
y: str, the other string

Returns
-------
L[m][n]: int, the length of the longest subsequence. Also equal to len(seq)
Seq: str, the subsequence found

>>> longest_common_subsequence("programming", "gaming")
(6, 'gaming')
>>> longest_common_subsequence("physics", "smartphone")
(2, 'ph')
>>> longest_common_subsequence("computer", "food")
(1, 'o')

File: longest_common_substring.py
 - Function 'longest_common_substring' takes 2 arguments: text1, text2.  Docstring: Finds the longest common substring between two strings.
>>> longest_common_substring("", "")
''
>>> longest_common_substring("a","")
''
>>> longest_common_substring("", "a")
''
>>> longest_common_substring("a", "a")
'a'
>>> longest_common_substring("abcdef", "bcd")
'bcd'
>>> longest_common_substring("abcdef", "xabded")
'ab'
>>> longest_common_substring("GeeksforGeeks", "GeeksQuiz")
'Geeks'
>>> longest_common_substring("abcdxyz", "xyzabcd")
'abcd'
>>> longest_common_substring("zxabcdezy", "yzabcdezx")
'abcdez'
>>> longest_common_substring("OldSite:GeeksforGeeks.org", "NewSite:GeeksQuiz.com")
'Site:Geeks'
>>> longest_common_substring(1, 1)
Traceback (most recent call last):
    ...
ValueError: longest_common_substring() takes two strings for inputs

File: longest_increasing_subsequence.py
 - Function 'longest_subsequence' takes 1 arguments: array.  Docstring: Some examples
>>> longest_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80])
[10, 22, 33, 41, 60, 80]
>>> longest_subsequence([4, 8, 7, 5, 1, 12, 2, 3, 9])
[1, 2, 3, 9]
>>> longest_subsequence([9, 8, 7, 6, 5, 7])
[8]
>>> longest_subsequence([1, 1, 1])
[1, 1, 1]
>>> longest_subsequence([])
[]

File: longest_increasing_subsequence_o_nlogn.py
 - Function 'ceil_index' takes 4 arguments: v, left, right, key.  No docstring available.
 - Function 'longest_increasing_subsequence_length' takes 1 arguments: v.  Docstring: >>> longest_increasing_subsequence_length([2, 5, 3, 7, 11, 8, 10, 13, 6])
6
>>> longest_increasing_subsequence_length([])
0
>>> longest_increasing_subsequence_length([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13,
...                                     3, 11, 7, 15])
6
>>> longest_increasing_subsequence_length([5, 4, 3, 2, 1])
1

File: longest_palindromic_subsequence.py
 - Function 'longest_palindromic_subsequence' takes 1 arguments: input_string.  Docstring: This function returns the longest palindromic subsequence in a string
>>> longest_palindromic_subsequence("bbbab")
4
>>> longest_palindromic_subsequence("bbabcbcab")
7

File: matrix_chain_multiplication.py
 - Function 'matrix_chain_multiply' takes 1 arguments: arr.  Docstring: Find the minimum number of multiplcations required to multiply the chain of matrices

Args:
    arr: The input array of integers.

Returns:
    Minimum number of multiplications needed to multiply the chain

Examples:
    >>> matrix_chain_multiply([1, 2, 3, 4, 3])
    30
    >>> matrix_chain_multiply([10])
    0
    >>> matrix_chain_multiply([10, 20])
    0
    >>> matrix_chain_multiply([19, 2, 19])
    722
    >>> matrix_chain_multiply(list(range(1, 100)))
    323398

    # >>> matrix_chain_multiply(list(range(1, 251)))
    # 2626798
 - Function 'matrix_chain_order' takes 1 arguments: dims.  Docstring: Source: https://en.wikipedia.org/wiki/Matrix_chain_multiplication
The dynamic programming solution is faster than cached the recursive solution and
can handle larger inputs.
>>> matrix_chain_order([1, 2, 3, 4, 3])
30
>>> matrix_chain_order([10])
0
>>> matrix_chain_order([10, 20])
0
>>> matrix_chain_order([19, 2, 19])
722
>>> matrix_chain_order(list(range(1, 100)))
323398

# >>> matrix_chain_order(list(range(1, 251)))  # Max before RecursionError is raised
# 2626798
 - Function 'a' takes 2 arguments: i, j.  No docstring available.
 - Function 'elapsed_time' takes 1 arguments: msg.  No docstring available.

File: matrix_chain_order.py
 - Function 'matrix_chain_order' takes 1 arguments: array.  No docstring available.
 - Function 'print_optiomal_solution' takes 3 arguments: optimal_solution, i, j.  No docstring available.
 - Function 'main' takes 0 arguments: .  No docstring available.

File: max_non_adjacent_sum.py
 - Function 'maximum_non_adjacent_sum' takes 1 arguments: nums.  Docstring: Find the maximum non-adjacent sum of the integers in the nums input list

>>> maximum_non_adjacent_sum([1, 2, 3])
4
>>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])
18
>>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])
0
>>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])
500

File: max_product_subarray.py
 - Function 'max_product_subarray' takes 1 arguments: numbers.  Docstring: Returns the maximum product that can be obtained by multiplying a
contiguous subarray of the given integer list `nums`.

Example:
>>> max_product_subarray([2, 3, -2, 4])
6
>>> max_product_subarray((-2, 0, -1))
0
>>> max_product_subarray([2, 3, -2, 4, -1])
48
>>> max_product_subarray([-1])
-1
>>> max_product_subarray([0])
0
>>> max_product_subarray([])
0
>>> max_product_subarray("")
0
>>> max_product_subarray(None)
0
>>> max_product_subarray([2, 3, -2, 4.5, -1])
Traceback (most recent call last):
    ...
ValueError: numbers must be an iterable of integers
>>> max_product_subarray("ABC")
Traceback (most recent call last):
    ...
ValueError: numbers must be an iterable of integers

File: max_subarray_sum.py
 - Function 'max_subarray_sum' takes 2 arguments: arr, allow_empty_subarrays.  Docstring: Solves the maximum subarray sum problem using Kadane's algorithm.
:param arr: the given array of numbers
:param allow_empty_subarrays: if True, then the algorithm considers empty subarrays

>>> max_subarray_sum([2, 8, 9])
19
>>> max_subarray_sum([0, 0])
0
>>> max_subarray_sum([-1.0, 0.0, 1.0])
1.0
>>> max_subarray_sum([1, 2, 3, 4, -2])
10
>>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])
6
>>> max_subarray_sum([2, 3, -9, 8, -2])
8
>>> max_subarray_sum([-2, -3, -1, -4, -6])
-1
>>> max_subarray_sum([-2, -3, -1, -4, -6], allow_empty_subarrays=True)
0
>>> max_subarray_sum([])
0

File: minimum_coin_change.py
 - Function 'find_minimum_change' takes 2 arguments: denominations, value.  Docstring: Find the minimum change from the given denominations and value
>>> find_minimum_change([1, 5, 10, 20, 50, 100, 200, 500, 1000,2000], 18745)
[2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 500, 200, 20, 20, 5]
>>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 987)
[500, 100, 100, 100, 100, 50, 20, 10, 5, 2]
>>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], 0)
[]
>>> find_minimum_change([1, 2, 5, 10, 20, 50, 100, 500, 2000], -98)
[]
>>> find_minimum_change([1, 5, 100, 500, 1000], 456)
[100, 100, 100, 100, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1]

File: minimum_cost_path.py
 - Function 'minimum_cost_path' takes 1 arguments: matrix.  Docstring: Find the minimum cost traced by all possible paths from top left to bottom right in
a given matrix

>>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])
6

>>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])
7

File: minimum_partition.py
 - Function 'find_min' takes 1 arguments: numbers.  Docstring: >>> find_min([1, 2, 3, 4, 5])
1
>>> find_min([5, 5, 5, 5, 5])
5
>>> find_min([5, 5, 5, 5])
0
>>> find_min([3])
3
>>> find_min([])
0
>>> find_min([1, 2, 3, 4])
0
>>> find_min([0, 0, 0, 0])
0
>>> find_min([-1, -5, 5, 1])
0
>>> find_min([-1, -5, 5, 1])
0
>>> find_min([9, 9, 9, 9, 9])
9
>>> find_min([1, 5, 10, 3])
1
>>> find_min([-1, 0, 1])
0
>>> find_min(range(10, 0, -1))
1
>>> find_min([-1])
Traceback (most recent call last):
    --
IndexError: list assignment index out of range
>>> find_min([0, 0, 0, 1, 2, -4])
Traceback (most recent call last):
    ...
IndexError: list assignment index out of range
>>> find_min([-1, -5, -10, -3])
Traceback (most recent call last):
    ...
IndexError: list assignment index out of range

File: minimum_size_subarray_sum.py
 - Function 'minimum_subarray_sum' takes 2 arguments: target, numbers.  Docstring: Return the length of the shortest contiguous subarray in a list of numbers whose sum
is at least target.  Reference: https://stackoverflow.com/questions/8269916

>>> minimum_subarray_sum(7, [2, 3, 1, 2, 4, 3])
2
>>> minimum_subarray_sum(7, [2, 3, -1, 2, 4, -3])
4
>>> minimum_subarray_sum(11, [1, 1, 1, 1, 1, 1, 1, 1])
0
>>> minimum_subarray_sum(10, [1, 2, 3, 4, 5, 6, 7])
2
>>> minimum_subarray_sum(5, [1, 1, 1, 1, 1, 5])
1
>>> minimum_subarray_sum(0, [])
0
>>> minimum_subarray_sum(0, [1, 2, 3])
1
>>> minimum_subarray_sum(10, [10, 20, 30])
1
>>> minimum_subarray_sum(7, [1, 1, 1, 1, 1, 1, 10])
1
>>> minimum_subarray_sum(6, [])
0
>>> minimum_subarray_sum(2, [1, 2, 3])
1
>>> minimum_subarray_sum(-6, [])
0
>>> minimum_subarray_sum(-6, [3, 4, 5])
1
>>> minimum_subarray_sum(8, None)
0
>>> minimum_subarray_sum(2, "ABC")
Traceback (most recent call last):
    ...
ValueError: numbers must be an iterable of integers

File: minimum_squares_to_represent_a_number.py
 - Function 'minimum_squares_to_represent_a_number' takes 1 arguments: number.  Docstring: Count the number of minimum squares to represent a number
>>> minimum_squares_to_represent_a_number(25)
1
>>> minimum_squares_to_represent_a_number(37)
2
>>> minimum_squares_to_represent_a_number(21)
3
>>> minimum_squares_to_represent_a_number(58)
2
>>> minimum_squares_to_represent_a_number(-1)
Traceback (most recent call last):
    ...
ValueError: the value of input must not be a negative number
>>> minimum_squares_to_represent_a_number(0)
1
>>> minimum_squares_to_represent_a_number(12.34)
Traceback (most recent call last):
    ...
ValueError: the value of input must be a natural number

File: minimum_steps_to_one.py
 - Function 'min_steps_to_one' takes 1 arguments: number.  Docstring: Minimum steps to 1 implemented using tabulation.
>>> min_steps_to_one(10)
3
>>> min_steps_to_one(15)
4
>>> min_steps_to_one(6)
2

:param number:
:return int:

File: minimum_tickets_cost.py
 - Function 'mincost_tickets' takes 2 arguments: days, costs.  Docstring: >>> mincost_tickets([1, 4, 6, 7, 8, 20], [2, 7, 15])
11

>>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31],  [2, 7, 15])
17

>>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])
24

>>> mincost_tickets([2], [2, 90, 150])
2

>>> mincost_tickets([], [2, 90, 150])
0

>>> mincost_tickets('hello', [2, 90, 150])
Traceback (most recent call last):
 ...
ValueError: The parameter days should be a list of integers

>>> mincost_tickets([], 'world')
Traceback (most recent call last):
 ...
ValueError: The parameter costs should be a list of three integers

>>> mincost_tickets([0.25, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])
Traceback (most recent call last):
 ...
ValueError: The parameter days should be a list of integers

>>> mincost_tickets([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 0.9, 150])
Traceback (most recent call last):
 ...
ValueError: The parameter costs should be a list of three integers

>>> mincost_tickets([-1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [2, 90, 150])
Traceback (most recent call last):
 ...
ValueError: All days elements should be greater than 0

>>> mincost_tickets([2, 367], [2, 90, 150])
Traceback (most recent call last):
 ...
ValueError: All days elements should be less than 366

>>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [])
Traceback (most recent call last):
 ...
ValueError: The parameter costs should be a list of three integers

>>> mincost_tickets([], [])
Traceback (most recent call last):
 ...
ValueError: The parameter costs should be a list of three integers

>>> mincost_tickets([2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], [1, 2, 3, 4])
Traceback (most recent call last):
 ...
ValueError: The parameter costs should be a list of three integers
 - Function 'dynamic_programming' takes 1 arguments: index.  No docstring available.

File: min_distance_up_bottom.py
 - Function 'min_distance_up_bottom' takes 2 arguments: word1, word2.  Docstring: >>> min_distance_up_bottom("intention", "execution")
5
>>> min_distance_up_bottom("intention", "")
9
>>> min_distance_up_bottom("", "")
0
>>> min_distance_up_bottom("zooicoarchaeologist", "zoologist")
10
 - Function 'min_distance' takes 2 arguments: index1, index2.  No docstring available.

File: optimal_binary_search_tree.py
 - Function '__init__' takes 3 arguments: self, key, freq.  No docstring available.
 - Function '__str__' takes 1 arguments: self.  Docstring: >>> str(Node(1, 2))
'Node(key=1, freq=2)'
 - Function 'print_binary_search_tree' takes 6 arguments: root, key, i, j, parent, is_left.  Docstring: Recursive function to print a BST from a root table.

>>> key = [3, 8, 9, 10, 17, 21]
>>> root = [[0, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 3], [0, 0, 2, 3, 3, 3],                 [0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 4, 5], [0, 0, 0, 0, 0, 5]]
>>> print_binary_search_tree(root, key, 0, 5, -1, False)
8 is the root of the binary search tree.
3 is the left child of key 8.
10 is the right child of key 8.
9 is the left child of key 10.
21 is the right child of key 10.
17 is the left child of key 21.
 - Function 'find_optimal_binary_search_tree' takes 1 arguments: nodes.  Docstring: This function calculates and prints the optimal binary search tree.
The dynamic programming algorithm below runs in O(n^2) time.
Implemented from CLRS (Introduction to Algorithms) book.
https://en.wikipedia.org/wiki/Introduction_to_Algorithms

>>> find_optimal_binary_search_tree([Node(12, 8), Node(10, 34), Node(20, 50),                                          Node(42, 3), Node(25, 40), Node(37, 30)])
Binary search tree nodes:
Node(key=10, freq=34)
Node(key=12, freq=8)
Node(key=20, freq=50)
Node(key=25, freq=40)
Node(key=37, freq=30)
Node(key=42, freq=3)
<BLANKLINE>
The cost of optimal BST for given tree nodes is 324.
20 is the root of the binary search tree.
10 is the left child of key 20.
12 is the right child of key 10.
25 is the right child of key 20.
37 is the right child of key 25.
42 is the right child of key 37.
 - Function 'main' takes 0 arguments: .  No docstring available.

File: palindrome_partitioning.py
 - Function 'find_minimum_partitions' takes 1 arguments: string.  Docstring: Returns the minimum cuts needed for a palindrome partitioning of string

>>> find_minimum_partitions("aab")
1
>>> find_minimum_partitions("aaa")
0
>>> find_minimum_partitions("ababbbabbababa")
3

File: regex_match.py
 - Function 'recursive_match' takes 2 arguments: text, pattern.  Docstring: Recursive matching algorithm.

Time complexity: O(2 ^ (|text| + |pattern|))
Space complexity: Recursion depth is O(|text| + |pattern|).

:param text: Text to match.
:param pattern: Pattern to match.
:return: True if text matches pattern, False otherwise.

>>> recursive_match('abc', 'a.c')
True
>>> recursive_match('abc', 'af*.c')
True
>>> recursive_match('abc', 'a.c*')
True
>>> recursive_match('abc', 'a.c*d')
False
>>> recursive_match('aa', '.*')
True
 - Function 'dp_match' takes 2 arguments: text, pattern.  Docstring: Dynamic programming matching algorithm.

Time complexity: O(|text| * |pattern|)
Space complexity: O(|text| * |pattern|)

:param text: Text to match.
:param pattern: Pattern to match.
:return: True if text matches pattern, False otherwise.

>>> dp_match('abc', 'a.c')
True
>>> dp_match('abc', 'af*.c')
True
>>> dp_match('abc', 'a.c*')
True
>>> dp_match('abc', 'a.c*d')
False
>>> dp_match('aa', '.*')
True

File: rod_cutting.py
 - Function 'naive_cut_rod_recursive' takes 2 arguments: n, prices.  Docstring: Solves the rod-cutting problem via naively without using the benefit of dynamic
programming. The results is the same sub-problems are solved several times
leading to an exponential runtime

Runtime: O(2^n)

Arguments
-------
n: int, the length of the rod
prices: list, the prices for each piece of rod. ``p[i-i]`` is the
price for a rod of length ``i``

Returns
-------
The maximum revenue obtainable for a rod of length n given the list of prices
for each piece.

Examples
--------
>>> naive_cut_rod_recursive(4, [1, 5, 8, 9])
10
>>> naive_cut_rod_recursive(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])
30
 - Function 'top_down_cut_rod' takes 2 arguments: n, prices.  Docstring: Constructs a top-down dynamic programming solution for the rod-cutting
problem via memoization. This function serves as a wrapper for
_top_down_cut_rod_recursive

Runtime: O(n^2)

Arguments
--------
n: int, the length of the rod
prices: list, the prices for each piece of rod. ``p[i-i]`` is the
price for a rod of length ``i``

Note
----
For convenience and because Python's lists using 0-indexing, length(max_rev) =
n + 1, to accommodate for the revenue obtainable from a rod of length 0.

Returns
-------
The maximum revenue obtainable for a rod of length n given the list of prices
for each piece.

Examples
-------
>>> top_down_cut_rod(4, [1, 5, 8, 9])
10
>>> top_down_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])
30
 - Function '_top_down_cut_rod_recursive' takes 3 arguments: n, prices, max_rev.  Docstring: Constructs a top-down dynamic programming solution for the rod-cutting problem
via memoization.

Runtime: O(n^2)

Arguments
--------
n: int, the length of the rod
prices: list, the prices for each piece of rod. ``p[i-i]`` is the
price for a rod of length ``i``
max_rev: list, the computed maximum revenue for a piece of rod.
``max_rev[i]`` is the maximum revenue obtainable for a rod of length ``i``

Returns
-------
The maximum revenue obtainable for a rod of length n given the list of prices
for each piece.
 - Function 'bottom_up_cut_rod' takes 2 arguments: n, prices.  Docstring: Constructs a bottom-up dynamic programming solution for the rod-cutting problem

Runtime: O(n^2)

Arguments
----------
n: int, the maximum length of the rod.
prices: list, the prices for each piece of rod. ``p[i-i]`` is the
price for a rod of length ``i``

Returns
-------
The maximum revenue obtainable from cutting a rod of length n given
the prices for each piece of rod p.

Examples
-------
>>> bottom_up_cut_rod(4, [1, 5, 8, 9])
10
>>> bottom_up_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])
30
 - Function '_enforce_args' takes 2 arguments: n, prices.  Docstring: Basic checks on the arguments to the rod-cutting algorithms

n: int, the length of the rod
prices: list, the price list for each piece of rod.

Throws ValueError:

if n is negative or there are fewer items in the price list than the length of
the rod
 - Function 'main' takes 0 arguments: .  No docstring available.

File: smith_waterman.py
 - Function 'score_function' takes 5 arguments: source_char, target_char, match, mismatch, gap.  Docstring: Calculate the score for a character pair based on whether they match or mismatch.
Returns 1 if the characters match, -1 if they mismatch, and -2 if either of the
characters is a gap.
>>> score_function('A', 'A')
1
>>> score_function('A', 'C')
-1
>>> score_function('-', 'A')
-2
>>> score_function('A', '-')
-2
>>> score_function('-', '-')
-2
 - Function 'smith_waterman' takes 5 arguments: query, subject, match, mismatch, gap.  Docstring: Perform the Smith-Waterman local sequence alignment algorithm.
Returns a 2D list representing the score matrix. Each value in the matrix
corresponds to the score of the best local alignment ending at that point.
>>> smith_waterman('ACAC', 'CA')
[[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]
>>> smith_waterman('acac', 'ca')
[[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]
>>> smith_waterman('ACAC', 'ca')
[[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]
>>> smith_waterman('acac', 'CA')
[[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]
>>> smith_waterman('ACAC', '')
[[0], [0], [0], [0], [0]]
>>> smith_waterman('', 'CA')
[[0, 0, 0]]
>>> smith_waterman('ACAC', 'CA')
[[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]

>>> smith_waterman('acac', 'ca')
[[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]

>>> smith_waterman('ACAC', 'ca')
[[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]

>>> smith_waterman('acac', 'CA')
[[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]]

>>> smith_waterman('ACAC', '')
[[0], [0], [0], [0], [0]]

>>> smith_waterman('', 'CA')
[[0, 0, 0]]

>>> smith_waterman('AGT', 'AGT')
[[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]

>>> smith_waterman('AGT', 'GTA')
[[0, 0, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 2, 0]]

>>> smith_waterman('AGT', 'GTC')
[[0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0]]

>>> smith_waterman('AGT', 'G')
[[0, 0], [0, 0], [0, 1], [0, 0]]

>>> smith_waterman('G', 'AGT')
[[0, 0, 0, 0], [0, 0, 1, 0]]

>>> smith_waterman('AGT', 'AGTCT')
[[0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0], [0, 0, 0, 3, 1, 1]]

>>> smith_waterman('AGTCT', 'AGT')
[[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3], [0, 0, 0, 1], [0, 0, 0, 1]]

>>> smith_waterman('AGTCT', 'GTC')
[[0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3], [0, 0, 1, 1]]
 - Function 'traceback' takes 3 arguments: score, query, subject.  Docstring: Perform traceback to find the optimal local alignment.
Starts from the highest scoring cell in the matrix and traces back recursively
until a 0 score is found. Returns the alignment strings.
>>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'ACAC', 'CA')
'CA\nCA'
>>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'acac', 'ca')
'CA\nCA'
>>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'ACAC', 'ca')
'CA\nCA'
>>> traceback([[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 0, 2], [0, 1, 0]], 'acac', 'CA')
'CA\nCA'
>>> traceback([[0, 0, 0]], 'ACAC', '')
''

File: subset_generation.py
 - Function 'subset_combinations' takes 2 arguments: elements, n.  Docstring: Compute n-element combinations from a given list using dynamic programming.
Args:
    elements: The list of elements from which combinations will be generated.
    n: The number of elements in each combination.
Returns:
    A list of tuples, each representing a combination of n elements.
    >>> subset_combinations(elements=[10, 20, 30, 40], n=2)
    [(10, 20), (10, 30), (10, 40), (20, 30), (20, 40), (30, 40)]
    >>> subset_combinations(elements=[1, 2, 3], n=1)
    [(1,), (2,), (3,)]
    >>> subset_combinations(elements=[1, 2, 3], n=3)
    [(1, 2, 3)]
    >>> subset_combinations(elements=[42], n=1)
    [(42,)]
    >>> subset_combinations(elements=[6, 7, 8, 9], n=4)
    [(6, 7, 8, 9)]
    >>> subset_combinations(elements=[10, 20, 30, 40, 50], n=0)
    [()]
    >>> subset_combinations(elements=[1, 2, 3, 4], n=2)
    [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]
    >>> subset_combinations(elements=[1, 'apple', 3.14], n=2)
    [(1, 'apple'), (1, 3.14), ('apple', 3.14)]
    >>> subset_combinations(elements=['single'], n=0)
    [()]
    >>> subset_combinations(elements=[], n=9)
    []
    >>> from itertools import combinations
    >>> all(subset_combinations(items, n) == list(combinations(items, n))
    ...     for items, n in (
    ...         ([10, 20, 30, 40], 2), ([1, 2, 3], 1), ([1, 2, 3], 3), ([42], 1),
    ...         ([6, 7, 8, 9], 4), ([10, 20, 30, 40, 50], 1), ([1, 2, 3, 4], 2),
    ...         ([1, 'apple', 3.14], 2), (['single'], 0), ([], 9)))
    True

File: sum_of_subset.py
 - Function 'is_sum_subset' takes 2 arguments: arr, required_sum.  Docstring: >>> is_sum_subset([2, 4, 6, 8], 5)
False
>>> is_sum_subset([2, 4, 6, 8], 14)
True

File: trapped_water.py
 - Function 'trapped_rainwater' takes 1 arguments: heights.  Docstring: The trapped_rainwater function calculates the total amount of rainwater that can be
trapped given an array of bar heights.
It uses a dynamic programming approach, determining the maximum height of bars on
both sides for each bar, and then computing the trapped water above each bar.
The function returns the total trapped water.

>>> trapped_rainwater((0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1))
6
>>> trapped_rainwater((7, 1, 5, 3, 6, 4))
9
>>> trapped_rainwater((7, 1, 5, 3, 6, -1))
Traceback (most recent call last):
    ...
ValueError: No height can be negative

File: tribonacci.py
 - Function 'tribonacci' takes 1 arguments: num.  Docstring: Given a number, return first n Tribonacci Numbers.
>>> tribonacci(5)
[0, 0, 1, 1, 2]
>>> tribonacci(8)
[0, 0, 1, 1, 2, 4, 7, 13]

File: viterbi.py
 - Function 'viterbi' takes 5 arguments: observations_space, states_space, initial_probabilities, transition_probabilities, emission_probabilities.  Docstring:     Viterbi Algorithm, to find the most likely path of
    states from the start and the expected output.
    https://en.wikipedia.org/wiki/Viterbi_algorithm
sdafads
    Wikipedia example
    >>> observations = ["normal", "cold", "dizzy"]
    >>> states = ["Healthy", "Fever"]
    >>> start_p = {"Healthy": 0.6, "Fever": 0.4}
    >>> trans_p = {
    ...     "Healthy": {"Healthy": 0.7, "Fever": 0.3},
    ...     "Fever": {"Healthy": 0.4, "Fever": 0.6},
    ... }
    >>> emit_p = {
    ...     "Healthy": {"normal": 0.5, "cold": 0.4, "dizzy": 0.1},
    ...     "Fever": {"normal": 0.1, "cold": 0.3, "dizzy": 0.6},
    ... }
    >>> viterbi(observations, states, start_p, trans_p, emit_p)
    ['Healthy', 'Healthy', 'Fever']

    >>> viterbi((), states, start_p, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: There's an empty parameter

    >>> viterbi(observations, (), start_p, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: There's an empty parameter

    >>> viterbi(observations, states, {}, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: There's an empty parameter

    >>> viterbi(observations, states, start_p, {}, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: There's an empty parameter

    >>> viterbi(observations, states, start_p, trans_p, {})
    Traceback (most recent call last):
        ...
    ValueError: There's an empty parameter

    >>> viterbi("invalid", states, start_p, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: observations_space must be a list

    >>> viterbi(["valid", 123], states, start_p, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: observations_space must be a list of strings

    >>> viterbi(observations, "invalid", start_p, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: states_space must be a list

    >>> viterbi(observations, ["valid", 123], start_p, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: states_space must be a list of strings

    >>> viterbi(observations, states, "invalid", trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: initial_probabilities must be a dict

    >>> viterbi(observations, states, {2:2}, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: initial_probabilities all keys must be strings

    >>> viterbi(observations, states, {"a":2}, trans_p, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: initial_probabilities all values must be float

    >>> viterbi(observations, states, start_p, "invalid", emit_p)
    Traceback (most recent call last):
        ...
    ValueError: transition_probabilities must be a dict

    >>> viterbi(observations, states, start_p, {"a":2}, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: transition_probabilities all values must be dict

    >>> viterbi(observations, states, start_p, {2:{2:2}}, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: transition_probabilities all keys must be strings

    >>> viterbi(observations, states, start_p, {"a":{2:2}}, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: transition_probabilities all keys must be strings

    >>> viterbi(observations, states, start_p, {"a":{"b":2}}, emit_p)
    Traceback (most recent call last):
        ...
    ValueError: transition_probabilities nested dictionary all values must be float

    >>> viterbi(observations, states, start_p, trans_p, "invalid")
    Traceback (most recent call last):
        ...
    ValueError: emission_probabilities must be a dict

    >>> viterbi(observations, states, start_p, trans_p, None)
    Traceback (most recent call last):
        ...
    ValueError: There's an empty parameter
 - Function '_validation' takes 5 arguments: observations_space, states_space, initial_probabilities, transition_probabilities, emission_probabilities.  Docstring: >>> observations = ["normal", "cold", "dizzy"]
>>> states = ["Healthy", "Fever"]
>>> start_p = {"Healthy": 0.6, "Fever": 0.4}
>>> trans_p = {
...     "Healthy": {"Healthy": 0.7, "Fever": 0.3},
...     "Fever": {"Healthy": 0.4, "Fever": 0.6},
... }
>>> emit_p = {
...     "Healthy": {"normal": 0.5, "cold": 0.4, "dizzy": 0.1},
...     "Fever": {"normal": 0.1, "cold": 0.3, "dizzy": 0.6},
... }
>>> _validation(observations, states, start_p, trans_p, emit_p)

>>> _validation([], states, start_p, trans_p, emit_p)
Traceback (most recent call last):
        ...
ValueError: There's an empty parameter
 - Function '_validate_not_empty' takes 5 arguments: observations_space, states_space, initial_probabilities, transition_probabilities, emission_probabilities.  Docstring: >>> _validate_not_empty(["a"], ["b"], {"c":0.5},
... {"d": {"e": 0.6}}, {"f": {"g": 0.7}})

>>> _validate_not_empty(["a"], ["b"], {"c":0.5}, {}, {"f": {"g": 0.7}})
Traceback (most recent call last):
        ...
ValueError: There's an empty parameter
>>> _validate_not_empty(["a"], ["b"], None, {"d": {"e": 0.6}}, {"f": {"g": 0.7}})
Traceback (most recent call last):
        ...
ValueError: There's an empty parameter
 - Function '_validate_lists' takes 2 arguments: observations_space, states_space.  Docstring: >>> _validate_lists(["a"], ["b"])

>>> _validate_lists(1234, ["b"])
Traceback (most recent call last):
        ...
ValueError: observations_space must be a list

>>> _validate_lists(["a"], [3])
Traceback (most recent call last):
        ...
ValueError: states_space must be a list of strings
 - Function '_validate_list' takes 2 arguments: _object, var_name.  Docstring: >>> _validate_list(["a"], "mock_name")

>>> _validate_list("a", "mock_name")
Traceback (most recent call last):
        ...
ValueError: mock_name must be a list
>>> _validate_list([0.5], "mock_name")
Traceback (most recent call last):
        ...
ValueError: mock_name must be a list of strings
 - Function '_validate_dicts' takes 3 arguments: initial_probabilities, transition_probabilities, emission_probabilities.  Docstring: >>> _validate_dicts({"c":0.5}, {"d": {"e": 0.6}}, {"f": {"g": 0.7}})

>>> _validate_dicts("invalid", {"d": {"e": 0.6}}, {"f": {"g": 0.7}})
Traceback (most recent call last):
        ...
ValueError: initial_probabilities must be a dict
>>> _validate_dicts({"c":0.5}, {2: {"e": 0.6}}, {"f": {"g": 0.7}})
Traceback (most recent call last):
        ...
ValueError: transition_probabilities all keys must be strings
>>> _validate_dicts({"c":0.5}, {"d": {"e": 0.6}}, {"f": {2: 0.7}})
Traceback (most recent call last):
        ...
ValueError: emission_probabilities all keys must be strings
>>> _validate_dicts({"c":0.5}, {"d": {"e": 0.6}}, {"f": {"g": "h"}})
Traceback (most recent call last):
        ...
ValueError: emission_probabilities nested dictionary all values must be float
 - Function '_validate_nested_dict' takes 2 arguments: _object, var_name.  Docstring: >>> _validate_nested_dict({"a":{"b": 0.5}}, "mock_name")

>>> _validate_nested_dict("invalid", "mock_name")
Traceback (most recent call last):
        ...
ValueError: mock_name must be a dict
>>> _validate_nested_dict({"a": 8}, "mock_name")
Traceback (most recent call last):
        ...
ValueError: mock_name all values must be dict
>>> _validate_nested_dict({"a":{2: 0.5}}, "mock_name")
Traceback (most recent call last):
        ...
ValueError: mock_name all keys must be strings
>>> _validate_nested_dict({"a":{"b": 4}}, "mock_name")
Traceback (most recent call last):
        ...
ValueError: mock_name nested dictionary all values must be float
 - Function '_validate_dict' takes 4 arguments: _object, var_name, value_type, nested.  Docstring: >>> _validate_dict({"b": 0.5}, "mock_name", float)

>>> _validate_dict("invalid", "mock_name", float)
Traceback (most recent call last):
        ...
ValueError: mock_name must be a dict
>>> _validate_dict({"a": 8}, "mock_name", dict)
Traceback (most recent call last):
        ...
ValueError: mock_name all values must be dict
>>> _validate_dict({2: 0.5}, "mock_name",float, True)
Traceback (most recent call last):
        ...
ValueError: mock_name all keys must be strings
>>> _validate_dict({"b": 4}, "mock_name", float,True)
Traceback (most recent call last):
        ...
ValueError: mock_name nested dictionary all values must be float

File: wildcard_matching.py
 - Function 'is_match' takes 2 arguments: string, pattern.  Docstring: >>> is_match("", "")
True
>>> is_match("aa", "a")
False
>>> is_match("abc", "abc")
True
>>> is_match("abc", "*c")
True
>>> is_match("abc", "a*")
True
>>> is_match("abc", "*a*")
True
>>> is_match("abc", "?b?")
True
>>> is_match("abc", "*?")
True
>>> is_match("abc", "a*d")
False
>>> is_match("abc", "a*c?")
False
>>> is_match('baaabab','*****ba*****ba')
False
>>> is_match('baaabab','*****ba*****ab')
True
>>> is_match('aa','*')
True

File: word_break.py
 - Function 'word_break' takes 2 arguments: string, words.  Docstring: Return True if numbers have opposite signs False otherwise.

>>> word_break("applepenapple", ["apple","pen"])
True
>>> word_break("catsandog", ["cats","dog","sand","and","cat"])
False
>>> word_break("cars", ["car","ca","rs"])
True
>>> word_break('abc', [])
False
>>> word_break(123, ['a'])
Traceback (most recent call last):
    ...
ValueError: the string should be not empty string
>>> word_break('', ['a'])
Traceback (most recent call last):
    ...
ValueError: the string should be not empty string
>>> word_break('abc', [123])
Traceback (most recent call last):
    ...
ValueError: the words should be a list of non-empty strings
>>> word_break('abc', [''])
Traceback (most recent call last):
    ...
ValueError: the words should be a list of non-empty strings
 - Function 'is_breakable' takes 1 arguments: index.  Docstring: >>> string = 'a'
>>> is_breakable(1)
True

File: apparent_power.py
 - Function 'apparent_power' takes 4 arguments: voltage, current, voltage_angle, current_angle.  Docstring: Calculate the apparent power in a single-phase AC circuit.

Reference: https://en.wikipedia.org/wiki/AC_power#Apparent_power

>>> apparent_power(100, 5, 0, 0)
(500+0j)
>>> apparent_power(100, 5, 90, 0)
(3.061616997868383e-14+500j)
>>> apparent_power(100, 5, -45, -60)
(-129.40952255126027-482.9629131445341j)
>>> apparent_power(200, 10, -30, -90)
(-999.9999999999998-1732.0508075688776j)

File: builtin_voltage.py
 - Function 'builtin_voltage' takes 3 arguments: donor_conc, acceptor_conc, intrinsic_conc.  Docstring: This function can calculate the Builtin Voltage of a pn junction diode.
This is calculated from the given three values.
Examples -
>>> builtin_voltage(donor_conc=1e17, acceptor_conc=1e17, intrinsic_conc=1e10)
0.833370010652644
>>> builtin_voltage(donor_conc=0, acceptor_conc=1600, intrinsic_conc=200)
Traceback (most recent call last):
  ...
ValueError: Donor concentration should be positive
>>> builtin_voltage(donor_conc=1000, acceptor_conc=0, intrinsic_conc=1200)
Traceback (most recent call last):
  ...
ValueError: Acceptor concentration should be positive
>>> builtin_voltage(donor_conc=1000, acceptor_conc=1000, intrinsic_conc=0)
Traceback (most recent call last):
  ...
ValueError: Intrinsic concentration should be positive
>>> builtin_voltage(donor_conc=1000, acceptor_conc=3000, intrinsic_conc=2000)
Traceback (most recent call last):
  ...
ValueError: Donor concentration should be greater than intrinsic concentration
>>> builtin_voltage(donor_conc=3000, acceptor_conc=1000, intrinsic_conc=2000)
Traceback (most recent call last):
  ...
ValueError: Acceptor concentration should be greater than intrinsic concentration

File: capacitor_equivalence.py
 - Function 'capacitor_parallel' takes 1 arguments: capacitors.  Docstring: Ceq = C1 + C2 + ... + Cn
Calculate the equivalent resistance for any number of capacitors in parallel.
>>> capacitor_parallel([5.71389, 12, 3])
20.71389
>>> capacitor_parallel([5.71389, 12, -3])
Traceback (most recent call last):
    ...
ValueError: Capacitor at index 2 has a negative value!
 - Function 'capacitor_series' takes 1 arguments: capacitors.  Docstring: Ceq = 1/ (1/C1 + 1/C2 + ... + 1/Cn)
>>> capacitor_series([5.71389, 12, 3])
1.6901062252507735
>>> capacitor_series([5.71389, 12, -3])
Traceback (most recent call last):
    ...
ValueError: Capacitor at index 2 has a negative or zero value!
>>> capacitor_series([5.71389, 12, 0.000])
Traceback (most recent call last):
    ...
ValueError: Capacitor at index 2 has a negative or zero value!

File: carrier_concentration.py
 - Function 'carrier_concentration' takes 3 arguments: electron_conc, hole_conc, intrinsic_conc.  Docstring: This function can calculate any one of the three -
1. Electron Concentration
2, Hole Concentration
3. Intrinsic Concentration
given the other two.
Examples -
>>> carrier_concentration(electron_conc=25, hole_conc=100, intrinsic_conc=0)
('intrinsic_conc', 50.0)
>>> carrier_concentration(electron_conc=0, hole_conc=1600, intrinsic_conc=200)
('electron_conc', 25.0)
>>> carrier_concentration(electron_conc=1000, hole_conc=0, intrinsic_conc=1200)
('hole_conc', 1440.0)
>>> carrier_concentration(electron_conc=1000, hole_conc=400, intrinsic_conc=1200)
Traceback (most recent call last):
    ...
ValueError: You cannot supply more or less than 2 values
>>> carrier_concentration(electron_conc=-1000, hole_conc=0, intrinsic_conc=1200)
Traceback (most recent call last):
    ...
ValueError: Electron concentration cannot be negative in a semiconductor
>>> carrier_concentration(electron_conc=0, hole_conc=-400, intrinsic_conc=1200)
Traceback (most recent call last):
    ...
ValueError: Hole concentration cannot be negative in a semiconductor
>>> carrier_concentration(electron_conc=0, hole_conc=400, intrinsic_conc=-1200)
Traceback (most recent call last):
    ...
ValueError: Intrinsic concentration cannot be negative in a semiconductor

File: charging_capacitor.py
 - Function 'charging_capacitor' takes 4 arguments: source_voltage, resistance, capacitance, time_sec.  Docstring: Find capacitor voltage at any nth second after initiating its charging.

Examples
--------
>>> charging_capacitor(source_voltage=.2,resistance=.9,capacitance=8.4,time_sec=.5)
0.013

>>> charging_capacitor(source_voltage=2.2,resistance=3.5,capacitance=2.4,time_sec=9)
1.446

>>> charging_capacitor(source_voltage=15,resistance=200,capacitance=20,time_sec=2)
0.007

>>> charging_capacitor(20, 2000, 30*pow(10,-5), 4)
19.975

>>> charging_capacitor(source_voltage=0,resistance=10.0,capacitance=.30,time_sec=3)
Traceback (most recent call last):
    ...
ValueError: Source voltage must be positive.

>>> charging_capacitor(source_voltage=20,resistance=-2000,capacitance=30,time_sec=4)
Traceback (most recent call last):
    ...
ValueError: Resistance must be positive.

>>> charging_capacitor(source_voltage=30,resistance=1500,capacitance=0,time_sec=4)
Traceback (most recent call last):
    ...
ValueError: Capacitance must be positive.

File: charging_inductor.py
 - Function 'charging_inductor' takes 4 arguments: source_voltage, resistance, inductance, time.  Docstring: Find inductor current at any nth second after initiating its charging.

Examples
--------
>>> charging_inductor(source_voltage=5.8,resistance=1.5,inductance=2.3,time=2)
2.817

>>> charging_inductor(source_voltage=8,resistance=5,inductance=3,time=2)
1.543

>>> charging_inductor(source_voltage=8,resistance=5*pow(10,2),inductance=3,time=2)
0.016

>>> charging_inductor(source_voltage=-8,resistance=100,inductance=15,time=12)
Traceback (most recent call last):
    ...
ValueError: Source voltage must be positive.

>>> charging_inductor(source_voltage=80,resistance=-15,inductance=100,time=5)
Traceback (most recent call last):
    ...
ValueError: Resistance must be positive.

>>> charging_inductor(source_voltage=12,resistance=200,inductance=-20,time=5)
Traceback (most recent call last):
    ...
ValueError: Inductance must be positive.

>>> charging_inductor(source_voltage=0,resistance=200,inductance=20,time=5)
Traceback (most recent call last):
    ...
ValueError: Source voltage must be positive.

>>> charging_inductor(source_voltage=10,resistance=0,inductance=20,time=5)
Traceback (most recent call last):
    ...
ValueError: Resistance must be positive.

>>> charging_inductor(source_voltage=15, resistance=25, inductance=0, time=5)
Traceback (most recent call last):
    ...
ValueError: Inductance must be positive.

File: circular_convolution.py
 - Function '__init__' takes 1 arguments: self.  Docstring: First signal and second signal are stored as 1-D array
 - Function 'circular_convolution' takes 1 arguments: self.  Docstring: This function performs the circular convolution of the first and second signal
using matrix method

Usage:
>>> convolution = CircularConvolution()
>>> convolution.circular_convolution()
[10, 10, 6, 14]

>>> convolution.first_signal = [0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6]
>>> convolution.second_signal = [0.1, 0.3, 0.5, 0.7, 0.9, 1.1, 1.3, 1.5]
>>> convolution.circular_convolution()
[5.2, 6.0, 6.48, 6.64, 6.48, 6.0, 5.2, 4.08]

>>> convolution.first_signal = [-1, 1, 2, -2]
>>> convolution.second_signal = [0.5, 1, -1, 2, 0.75]
>>> convolution.circular_convolution()
[6.25, -3.0, 1.5, -2.0, -2.75]

>>> convolution.first_signal = [1, -1, 2, 3, -1]
>>> convolution.second_signal = [1, 2, 3]
>>> convolution.circular_convolution()
[8, -2, 3, 4, 11]

File: coulombs_law.py
 - Function 'coulombs_law' takes 3 arguments: q1, q2, radius.  Docstring: Calculate the electrostatic force of attraction or repulsion
between two point charges

>>> coulombs_law(15.5, 20, 15)
12382849136.06
>>> coulombs_law(1, 15, 5)
5392531075.38
>>> coulombs_law(20, -50, 15)
-39944674632.44
>>> coulombs_law(-5, -8, 10)
3595020716.92
>>> coulombs_law(50, 100, 50)
17975103584.6

File: electrical_impedance.py
 - Function 'electrical_impedance' takes 3 arguments: resistance, reactance, impedance.  Docstring: Apply Electrical Impedance formula, on any two given electrical values,
which can be resistance, reactance, and impedance, and then in a Python dict
return name/value pair of the zero value.

>>> electrical_impedance(3,4,0)
{'impedance': 5.0}
>>> electrical_impedance(0,4,5)
{'resistance': 3.0}
>>> electrical_impedance(3,0,5)
{'reactance': 4.0}
>>> electrical_impedance(3,4,5)
Traceback (most recent call last):
  ...
ValueError: One and only one argument must be 0

File: electric_conductivity.py
 - Function 'electric_conductivity' takes 3 arguments: conductivity, electron_conc, mobility.  Docstring: This function can calculate any one of the three -
1. Conductivity
2. Electron Concentration
3. Electron Mobility
This is calculated from the other two provided values
Examples -
>>> electric_conductivity(conductivity=25, electron_conc=100, mobility=0)
('mobility', 1.5604519068722301e+18)
>>> electric_conductivity(conductivity=0, electron_conc=1600, mobility=200)
('conductivity', 5.12672e-14)
>>> electric_conductivity(conductivity=1000, electron_conc=0, mobility=1200)
('electron_conc', 5.201506356240767e+18)

File: electric_power.py
 - Function 'electric_power' takes 3 arguments: voltage, current, power.  Docstring: This function can calculate any one of the three (voltage, current, power),
fundamental value of electrical system.
examples are below:
>>> electric_power(voltage=0, current=2, power=5)
Result(name='voltage', value=2.5)
>>> electric_power(voltage=2, current=2, power=0)
Result(name='power', value=4.0)
>>> electric_power(voltage=-2, current=3, power=0)
Result(name='power', value=6.0)
>>> electric_power(voltage=2, current=4, power=2)
Traceback (most recent call last):
    ...
ValueError: Only one argument must be 0
>>> electric_power(voltage=0, current=0, power=2)
Traceback (most recent call last):
    ...
ValueError: Only one argument must be 0
>>> electric_power(voltage=0, current=2, power=-4)
Traceback (most recent call last):
    ...
ValueError: Power cannot be negative in any electrical/electronics system
>>> electric_power(voltage=2.2, current=2.2, power=0)
Result(name='power', value=4.84)

File: ic_555_timer.py
 - Function 'astable_frequency' takes 3 arguments: resistance_1, resistance_2, capacitance.  Docstring: Usage examples:
>>> astable_frequency(resistance_1=45, resistance_2=45, capacitance=7)
1523.8095238095239
>>> astable_frequency(resistance_1=356, resistance_2=234, capacitance=976)
1.7905459175553078
>>> astable_frequency(resistance_1=2, resistance_2=-1, capacitance=2)
Traceback (most recent call last):
    ...
ValueError: All values must be positive
>>> astable_frequency(resistance_1=45, resistance_2=45, capacitance=0)
Traceback (most recent call last):
    ...
ValueError: All values must be positive
 - Function 'astable_duty_cycle' takes 2 arguments: resistance_1, resistance_2.  Docstring: Usage examples:
>>> astable_duty_cycle(resistance_1=45, resistance_2=45)
66.66666666666666
>>> astable_duty_cycle(resistance_1=356, resistance_2=234)
71.60194174757282
>>> astable_duty_cycle(resistance_1=2, resistance_2=-1)
Traceback (most recent call last):
    ...
ValueError: All values must be positive
>>> astable_duty_cycle(resistance_1=0, resistance_2=0)
Traceback (most recent call last):
    ...
ValueError: All values must be positive

File: ind_reactance.py
 - Function 'ind_reactance' takes 3 arguments: inductance, frequency, reactance.  Docstring: Calculate inductive reactance, frequency or inductance from two given electrical
properties then return name/value pair of the zero value in a Python dict.

Parameters
----------
inductance : float with units in Henries

frequency : float with units in Hertz

reactance : float with units in Ohms

>>> ind_reactance(-35e-6, 1e3, 0)
Traceback (most recent call last):
    ...
ValueError: Inductance cannot be negative

>>> ind_reactance(35e-6, -1e3, 0)
Traceback (most recent call last):
    ...
ValueError: Frequency cannot be negative

>>> ind_reactance(35e-6, 0, -1)
Traceback (most recent call last):
    ...
ValueError: Inductive reactance cannot be negative

>>> ind_reactance(0, 10e3, 50)
{'inductance': 0.0007957747154594767}

>>> ind_reactance(35e-3, 0, 50)
{'frequency': 227.36420441699332}

>>> ind_reactance(35e-6, 1e3, 0)
{'reactance': 0.2199114857512855}

File: ohms_law.py
 - Function 'ohms_law' takes 3 arguments: voltage, current, resistance.  Docstring: Apply Ohm's Law, on any two given electrical values, which can be voltage, current,
and resistance, and then in a Python dict return name/value pair of the zero value.

>>> ohms_law(voltage=10, resistance=5, current=0)
{'current': 2.0}
>>> ohms_law(voltage=0, current=0, resistance=10)
Traceback (most recent call last):
  ...
ValueError: One and only one argument must be 0
>>> ohms_law(voltage=0, current=1, resistance=-2)
Traceback (most recent call last):
  ...
ValueError: Resistance cannot be negative
>>> ohms_law(resistance=0, voltage=-10, current=1)
{'resistance': -10.0}
>>> ohms_law(voltage=0, current=-1.5, resistance=2)
{'voltage': -3.0}

File: real_and_reactive_power.py
 - Function 'real_power' takes 2 arguments: apparent_power, power_factor.  Docstring: Calculate real power from apparent power and power factor.

Examples:
>>> real_power(100, 0.9)
90.0
>>> real_power(0, 0.8)
0.0
>>> real_power(100, -0.9)
-90.0
 - Function 'reactive_power' takes 2 arguments: apparent_power, power_factor.  Docstring: Calculate reactive power from apparent power and power factor.

Examples:
>>> reactive_power(100, 0.9)
43.58898943540673
>>> reactive_power(0, 0.8)
0.0
>>> reactive_power(100, -0.9)
43.58898943540673

File: resistor_color_code.py
 - Function 'get_significant_digits' takes 1 arguments: colors.  Docstring: Function returns the digit associated with the color. Function takes a
list containing colors as input and returns digits as string

>>> get_significant_digits(['Black','Blue'])
'06'

>>> get_significant_digits(['Aqua','Blue'])
Traceback (most recent call last):
  ...
ValueError: Aqua is not a valid color for significant figure bands
 - Function 'get_multiplier' takes 1 arguments: color.  Docstring: Function returns the multiplier value associated with the color.
Function takes color as input and returns multiplier value

>>> get_multiplier('Gold')
0.1

>>> get_multiplier('Ivory')
Traceback (most recent call last):
  ...
ValueError: Ivory is not a valid color for multiplier band
 - Function 'get_tolerance' takes 1 arguments: color.  Docstring: Function returns the tolerance value associated with the color.
Function takes color as input and returns tolerance value.

>>> get_tolerance('Green')
0.5

>>> get_tolerance('Indigo')
Traceback (most recent call last):
  ...
ValueError: Indigo is not a valid color for tolerance band
 - Function 'get_temperature_coeffecient' takes 1 arguments: color.  Docstring: Function returns the temperature coeffecient value associated with the color.
Function takes color as input and returns temperature coeffecient value.

>>> get_temperature_coeffecient('Yellow')
25

>>> get_temperature_coeffecient('Cyan')
Traceback (most recent call last):
  ...
ValueError: Cyan is not a valid color for temperature coeffecient band
 - Function 'get_band_type_count' takes 2 arguments: total_number_of_bands, type_of_band.  Docstring: Function returns the number of bands of a given type in a resistor with n bands
Function takes total_number_of_bands and type_of_band as input and returns
number of bands belonging to that type in the given resistor

>>> get_band_type_count(3,'significant')
2

>>> get_band_type_count(2,'significant')
Traceback (most recent call last):
  ...
ValueError: 2 is not a valid number of bands

>>> get_band_type_count(3,'sign')
Traceback (most recent call last):
  ...
ValueError: sign is not valid for a 3 band resistor

>>> get_band_type_count(3,'tolerance')
Traceback (most recent call last):
  ...
ValueError: tolerance is not valid for a 3 band resistor

>>> get_band_type_count(5,'temp_coeffecient')
Traceback (most recent call last):
  ...
ValueError: temp_coeffecient is not valid for a 5 band resistor
 - Function 'check_validity' takes 2 arguments: number_of_bands, colors.  Docstring: Function checks if the input provided is valid or not.
Function takes number_of_bands and colors as input and returns
True if it is valid

>>> check_validity(3, ["Black","Blue","Orange"])
True

>>> check_validity(4, ["Black","Blue","Orange"])
Traceback (most recent call last):
  ...
ValueError: Expecting 4 colors, provided 3 colors

>>> check_validity(3, ["Cyan","Red","Yellow"])
Traceback (most recent call last):
  ...
ValueError: Cyan is not a valid color
 - Function 'calculate_resistance' takes 2 arguments: number_of_bands, color_code_list.  Docstring: Function calculates the total resistance of the resistor using the color codes.
Function takes number_of_bands, color_code_list as input and returns
resistance

>>> calculate_resistance(3, ["Black","Blue","Orange"])
{'resistance': '6000 20% '}

>>> calculate_resistance(4, ["Orange","Green","Blue","Gold"])
{'resistance': '35000000 5% '}

>>> calculate_resistance(5, ["Violet","Brown","Grey","Silver","Green"])
{'resistance': '7.18 0.5% '}

>>> calculate_resistance(6, ["Red","Green","Blue","Yellow","Orange","Grey"])
{'resistance': '2560000 0.05% 1 ppm/K'}

>>> calculate_resistance(0, ["Violet","Brown","Grey","Silver","Green"])
Traceback (most recent call last):
  ...
ValueError: Invalid number of bands. Resistor bands must be 3 to 6

>>> calculate_resistance(4, ["Violet","Brown","Grey","Silver","Green"])
Traceback (most recent call last):
  ...
ValueError: Expecting 4 colors, provided 5 colors

>>> calculate_resistance(4, ["Violet","Silver","Brown","Grey"])
Traceback (most recent call last):
  ...
ValueError: Silver is not a valid color for significant figure bands

>>> calculate_resistance(4, ["Violet","Blue","Lime","Grey"])
Traceback (most recent call last):
  ...
ValueError: Lime is not a valid color

File: resistor_equivalence.py
 - Function 'resistor_parallel' takes 1 arguments: resistors.  Docstring: Req = 1/ (1/R1 + 1/R2 + ... + 1/Rn)

>>> resistor_parallel([3.21389, 2, 3])
0.8737571620498019
>>> resistor_parallel([3.21389, 2, -3])
Traceback (most recent call last):
    ...
ValueError: Resistor at index 2 has a negative or zero value!
>>> resistor_parallel([3.21389, 2, 0.000])
Traceback (most recent call last):
    ...
ValueError: Resistor at index 2 has a negative or zero value!
 - Function 'resistor_series' takes 1 arguments: resistors.  Docstring: Req = R1 + R2 + ... + Rn

Calculate the equivalent resistance for any number of resistors in parallel.

>>> resistor_series([3.21389, 2, 3])
8.21389
>>> resistor_series([3.21389, 2, -3])
Traceback (most recent call last):
    ...
ValueError: Resistor at index 2 has a negative value!

File: resonant_frequency.py
 - Function 'resonant_frequency' takes 2 arguments: inductance, capacitance.  Docstring: This function can calculate the resonant frequency of LC circuit,
for the given value of inductance and capacitnace.

Examples are given below:
>>> resonant_frequency(inductance=10, capacitance=5)
('Resonant frequency', 0.022507907903927652)
>>> resonant_frequency(inductance=0, capacitance=5)
Traceback (most recent call last):
  ...
ValueError: Inductance cannot be 0 or negative
>>> resonant_frequency(inductance=10, capacitance=0)
Traceback (most recent call last):
  ...
ValueError: Capacitance cannot be 0 or negative

File: wheatstone_bridge.py
 - Function 'wheatstone_solver' takes 3 arguments: resistance_1, resistance_2, resistance_3.  Docstring: This function can calculate the unknown resistance in an wheatstone network,
given that the three other resistances in the network are known.
The formula to calculate the same is:

---------------
|Rx=(R2/R1)*R3|
---------------

Usage examples:
>>> wheatstone_solver(resistance_1=2, resistance_2=4, resistance_3=5)
10.0
>>> wheatstone_solver(resistance_1=356, resistance_2=234, resistance_3=976)
641.5280898876405
>>> wheatstone_solver(resistance_1=2, resistance_2=-1, resistance_3=2)
Traceback (most recent call last):
    ...
ValueError: All resistance values must be positive
>>> wheatstone_solver(resistance_1=0, resistance_2=0, resistance_3=2)
Traceback (most recent call last):
    ...
ValueError: All resistance values must be positive

File: receive_file.py
 - Function 'main' takes 0 arguments: .  No docstring available.

File: send_file.py
 - Function 'send_file' takes 2 arguments: filename, testing.  No docstring available.

File: test_send_file.py
 - Function 'test_send_file_running_as_expected' takes 2 arguments: file, sock.  No docstring available.

File: equated_monthly_installments.py
 - Function 'equated_monthly_installments' takes 3 arguments: principal, rate_per_annum, years_to_repay.  Docstring: Formula for amortization amount per month:
A = p * r * (1 + r)^n / ((1 + r)^n - 1)
where p is the principal, r is the rate of interest per month
and n is the number of payments

>>> equated_monthly_installments(25000, 0.12, 3)
830.3577453212793
>>> equated_monthly_installments(25000, 0.12, 10)
358.67737100646826
>>> equated_monthly_installments(0, 0.12, 3)
Traceback (most recent call last):
    ...
Exception: Principal borrowed must be > 0
>>> equated_monthly_installments(25000, -1, 3)
Traceback (most recent call last):
    ...
Exception: Rate of interest must be >= 0
>>> equated_monthly_installments(25000, 0.12, 0)
Traceback (most recent call last):
    ...
Exception: Years to repay must be an integer > 0

File: exponential_moving_average.py
 - Function 'exponential_moving_average' takes 2 arguments: stock_prices, window_size.  Docstring: Yields exponential moving averages of the given stock prices.
>>> tuple(exponential_moving_average(iter([2, 5, 3, 8.2, 6, 9, 10]), 3))
(2, 3.5, 3.25, 5.725, 5.8625, 7.43125, 8.715625)

:param stock_prices: A stream of stock prices
:param window_size: The number of stock prices that will trigger a new calculation
                    of the exponential average (window_size > 0)
:return: Yields a sequence of exponential moving averages

Formula:

st = alpha * xt + (1 - alpha) * st_prev

Where,
st : Exponential moving average at timestamp t
xt : stock price in from the stock prices at timestamp t
st_prev : Exponential moving average at timestamp t-1
alpha : 2/(1 + window_size) - smoothing factor

Exponential moving average (EMA) is a rule of thumb technique for
smoothing time series data using an exponential window function.

File: interest.py
 - Function 'simple_interest' takes 3 arguments: principal, daily_interest_rate, days_between_payments.  Docstring: >>> simple_interest(18000.0, 0.06, 3)
3240.0
>>> simple_interest(0.5, 0.06, 3)
0.09
>>> simple_interest(18000.0, 0.01, 10)
1800.0
>>> simple_interest(18000.0, 0.0, 3)
0.0
>>> simple_interest(5500.0, 0.01, 100)
5500.0
>>> simple_interest(10000.0, -0.06, 3)
Traceback (most recent call last):
    ...
ValueError: daily_interest_rate must be >= 0
>>> simple_interest(-10000.0, 0.06, 3)
Traceback (most recent call last):
    ...
ValueError: principal must be > 0
>>> simple_interest(5500.0, 0.01, -5)
Traceback (most recent call last):
    ...
ValueError: days_between_payments must be > 0
 - Function 'compound_interest' takes 3 arguments: principal, nominal_annual_interest_rate_percentage, number_of_compounding_periods.  Docstring: >>> compound_interest(10000.0, 0.05, 3)
1576.2500000000014
>>> compound_interest(10000.0, 0.05, 1)
500.00000000000045
>>> compound_interest(0.5, 0.05, 3)
0.07881250000000006
>>> compound_interest(10000.0, 0.06, -4)
Traceback (most recent call last):
    ...
ValueError: number_of_compounding_periods must be > 0
>>> compound_interest(10000.0, -3.5, 3.0)
Traceback (most recent call last):
    ...
ValueError: nominal_annual_interest_rate_percentage must be >= 0
>>> compound_interest(-5500.0, 0.01, 5)
Traceback (most recent call last):
    ...
ValueError: principal must be > 0
 - Function 'apr_interest' takes 3 arguments: principal, nominal_annual_percentage_rate, number_of_years.  Docstring: >>> apr_interest(10000.0, 0.05, 3)
1618.223072263547
>>> apr_interest(10000.0, 0.05, 1)
512.6749646744732
>>> apr_interest(0.5, 0.05, 3)
0.08091115361317736
>>> apr_interest(10000.0, 0.06, -4)
Traceback (most recent call last):
    ...
ValueError: number_of_years must be > 0
>>> apr_interest(10000.0, -3.5, 3.0)
Traceback (most recent call last):
    ...
ValueError: nominal_annual_percentage_rate must be >= 0
>>> apr_interest(-5500.0, 0.01, 5)
Traceback (most recent call last):
    ...
ValueError: principal must be > 0

File: present_value.py
 - Function 'present_value' takes 2 arguments: discount_rate, cash_flows.  Docstring: >>> present_value(0.13, [10, 20.70, -293, 297])
4.69
>>> present_value(0.07, [-109129.39, 30923.23, 15098.93, 29734,39])
-42739.63
>>> present_value(0.07, [109129.39, 30923.23, 15098.93, 29734,39])
175519.15
>>> present_value(-1, [109129.39, 30923.23, 15098.93, 29734,39])
Traceback (most recent call last):
    ...
ValueError: Discount rate cannot be negative
>>> present_value(0.03, [])
Traceback (most recent call last):
    ...
ValueError: Cash flows list cannot be empty

File: price_plus_tax.py
 - Function 'price_plus_tax' takes 2 arguments: price, tax_rate.  Docstring: >>> price_plus_tax(100, 0.25)
125.0
>>> price_plus_tax(125.50, 0.05)
131.775

File: simple_moving_average.py
 - Function 'simple_moving_average' takes 2 arguments: data, window_size.  Docstring: Calculate the simple moving average (SMA) for some given time series data.

:param data: A list of numerical data points.
:param window_size: An integer representing the size of the SMA window.
:return: A list of SMA values with the same length as the input data.

Examples:
>>> sma = simple_moving_average([10, 12, 15, 13, 14, 16, 18, 17, 19, 21], 3)
>>> [round(value, 2) if value is not None else None for value in sma]
[None, None, 12.33, 13.33, 14.0, 14.33, 16.0, 17.0, 18.0, 19.0]
>>> simple_moving_average([10, 12, 15], 5)
[None, None, None]
>>> simple_moving_average([10, 12, 15, 13, 14, 16, 18, 17, 19, 21], 0)
Traceback (most recent call last):
...
ValueError: Window size must be a positive integer

File: julia_sets.py
 - Function 'eval_exponential' takes 2 arguments: c_parameter, z_values.  Docstring: Evaluate $e^z + c$.
>>> eval_exponential(0, 0)
1.0
>>> abs(eval_exponential(1, np.pi*1.j)) < 1e-15
True
>>> abs(eval_exponential(1.j, 0)-1-1.j) < 1e-15
True
 - Function 'eval_quadratic_polynomial' takes 2 arguments: c_parameter, z_values.  Docstring: >>> eval_quadratic_polynomial(0, 2)
4
>>> eval_quadratic_polynomial(-1, 1)
0
>>> round(eval_quadratic_polynomial(1.j, 0).imag)
1
>>> round(eval_quadratic_polynomial(1.j, 0).real)
0
 - Function 'prepare_grid' takes 2 arguments: window_size, nb_pixels.  Docstring: Create a grid of complex values of size nb_pixels*nb_pixels with real and
 imaginary parts ranging from -window_size to window_size (inclusive).
Returns a numpy array.

>>> prepare_grid(1,3)
array([[-1.-1.j, -1.+0.j, -1.+1.j],
       [ 0.-1.j,  0.+0.j,  0.+1.j],
       [ 1.-1.j,  1.+0.j,  1.+1.j]])
 - Function 'iterate_function' takes 5 arguments: eval_function, function_params, nb_iterations, z_0, infinity.  Docstring: Iterate the function "eval_function" exactly nb_iterations times.
The first argument of the function is a parameter which is contained in
function_params. The variable z_0 is an array that contains the initial
values to iterate from.
This function returns the final iterates.

>>> iterate_function(eval_quadratic_polynomial, 0, 3, np.array([0,1,2])).shape
(3,)
>>> np.round(iterate_function(eval_quadratic_polynomial,
... 0,
... 3,
... np.array([0,1,2]))[0])
0j
>>> np.round(iterate_function(eval_quadratic_polynomial,
... 0,
... 3,
... np.array([0,1,2]))[1])
(1+0j)
>>> np.round(iterate_function(eval_quadratic_polynomial,
... 0,
... 3,
... np.array([0,1,2]))[2])
(256+0j)
 - Function 'show_results' takes 4 arguments: function_label, function_params, escape_radius, z_final.  Docstring: Plots of whether the absolute value of z_final is greater than
the value of escape_radius. Adds the function_label and function_params to
the title.

>>> show_results('80', 0, 1, np.array([[0,1,.5],[.4,2,1.1],[.2,1,1.3]]))
 - Function 'ignore_overflow_warnings' takes 0 arguments: .  Docstring: Ignore some overflow and invalid value warnings.

>>> ignore_overflow_warnings()

File: koch_snowflake.py
 - Function 'iterate' takes 2 arguments: initial_vectors, steps.  Docstring: Go through the number of iterations determined by the argument "steps".
Be careful with high values (above 5) since the time to calculate increases
exponentially.
>>> iterate([np.array([0, 0]), np.array([1, 0])], 1)
[array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , 0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]
 - Function 'iteration_step' takes 1 arguments: vectors.  Docstring: Loops through each pair of adjacent vectors. Each line between two adjacent
vectors is divided into 4 segments by adding 3 additional vectors in-between
the original two vectors. The vector in the middle is constructed through a
60 degree rotation so it is bent outwards.
>>> iteration_step([np.array([0, 0]), np.array([1, 0])])
[array([0, 0]), array([0.33333333, 0.        ]), array([0.5       , 0.28867513]), array([0.66666667, 0.        ]), array([1, 0])]
 - Function 'rotate' takes 2 arguments: vector, angle_in_degrees.  Docstring: Standard rotation of a 2D vector with a rotation matrix
(see https://en.wikipedia.org/wiki/Rotation_matrix )
>>> rotate(np.array([1, 0]), 60)
array([0.5      , 0.8660254])
>>> rotate(np.array([1, 0]), 90)
array([6.123234e-17, 1.000000e+00])
 - Function 'plot' takes 1 arguments: vectors.  Docstring: Utility function to plot the vectors using matplotlib.pyplot
No doctest was implemented since this function does not have a return value

File: mandelbrot.py
 - Function 'get_distance' takes 3 arguments: x, y, max_step.  Docstring: Return the relative distance (= step/max_step) after which the complex number
constituted by this x-y-pair diverges. Members of the Mandelbrot set do not
diverge so their distance is 1.

>>> get_distance(0, 0, 50)
1.0
>>> get_distance(0.5, 0.5, 50)
0.061224489795918366
>>> get_distance(2, 0, 50)
0.0
 - Function 'get_black_and_white_rgb' takes 1 arguments: distance.  Docstring: Black&white color-coding that ignores the relative distance. The Mandelbrot
set is black, everything else is white.

>>> get_black_and_white_rgb(0)
(255, 255, 255)
>>> get_black_and_white_rgb(0.5)
(255, 255, 255)
>>> get_black_and_white_rgb(1)
(0, 0, 0)
 - Function 'get_color_coded_rgb' takes 1 arguments: distance.  Docstring: Color-coding taking the relative distance into account. The Mandelbrot set
is black.

>>> get_color_coded_rgb(0)
(255, 0, 0)
>>> get_color_coded_rgb(0.5)
(0, 255, 255)
>>> get_color_coded_rgb(1)
(0, 0, 0)
 - Function 'get_image' takes 7 arguments: image_width, image_height, figure_center_x, figure_center_y, figure_width, max_step, use_distance_color_coding.  Docstring: Function to generate the image of the Mandelbrot set. Two types of coordinates
are used: image-coordinates that refer to the pixels and figure-coordinates
that refer to the complex numbers inside and outside the Mandelbrot set. The
figure-coordinates in the arguments of this function determine which section
of the Mandelbrot set is viewed. The main area of the Mandelbrot set is
roughly between "-1.5 < x < 0.5" and "-1 < y < 1" in the figure-coordinates.

Commenting out tests that slow down pytest...
# 13.35s call     fractals/mandelbrot.py::mandelbrot.get_image
# >>> get_image().load()[0,0]
(255, 0, 0)
# >>> get_image(use_distance_color_coding = False).load()[0,0]
(255, 255, 255)

File: sierpinski_triangle.py
 - Function 'get_mid' takes 2 arguments: p1, p2.  Docstring: Find the midpoint of two points

>>> get_mid((0, 0), (2, 2))
(1.0, 1.0)
>>> get_mid((-3, -3), (3, 3))
(0.0, 0.0)
>>> get_mid((1, 0), (3, 2))
(2.0, 1.0)
>>> get_mid((0, 0), (1, 1))
(0.5, 0.5)
>>> get_mid((0, 0), (0, 0))
(0.0, 0.0)
 - Function 'triangle' takes 4 arguments: vertex1, vertex2, vertex3, depth.  Docstring: Recursively draw the Sierpinski triangle given the vertices of the triangle
and the recursion depth

File: vicsek.py
 - Function 'draw_cross' takes 3 arguments: x, y, length.  Docstring: Draw a cross at the specified position and with the specified length.
 - Function 'draw_fractal_recursive' takes 4 arguments: x, y, length, depth.  Docstring: Recursively draw the Vicsek fractal at the specified position, with the
specified length and depth.
 - Function 'set_color' takes 1 arguments: rgb.  No docstring available.
 - Function 'draw_vicsek_fractal' takes 5 arguments: x, y, length, depth, color.  Docstring: Draw the Vicsek fractal at the specified position, with the specified
length and depth.
 - Function 'main' takes 0 arguments: .  No docstring available.

File: fuzzy_operations.py
 - Function '__str__' takes 1 arguments: self.  Docstring: >>> FuzzySet("fuzzy_set", 0.1, 0.2, 0.3)
FuzzySet(name='fuzzy_set', left_boundary=0.1, peak=0.2, right_boundary=0.3)
 - Function 'complement' takes 1 arguments: self.  Docstring: Calculate the complement (negation) of this fuzzy set.
Returns:
    FuzzySet: A new fuzzy set representing the complement.

>>> FuzzySet("fuzzy_set", 0.1, 0.2, 0.3).complement()
FuzzySet(name='fuzzy_set', left_boundary=0.7, peak=0.9, right_boundary=0.8)
 - Function 'intersection' takes 2 arguments: self, other.  Docstring: Calculate the intersection of this fuzzy set
with another fuzzy set.
Args:
    other: Another fuzzy set to intersect with.
Returns:
    A new fuzzy set representing the intersection.

>>> FuzzySet("a", 0.1, 0.2, 0.3).intersection(FuzzySet("b", 0.4, 0.5, 0.6))
FuzzySet(name='a  b', left_boundary=0.4, peak=0.3, right_boundary=0.35)
 - Function 'membership' takes 2 arguments: self, x.  Docstring: Calculate the membership value of an input 'x' in the fuzzy set.
Returns:
    The membership value of 'x' in the fuzzy set.

>>> a = FuzzySet("a", 0.1, 0.2, 0.3)
>>> a.membership(0.09)
0.0
>>> a.membership(0.1)
0.0
>>> a.membership(0.11)
0.09999999999999995
>>> a.membership(0.4)
0.0
>>> FuzzySet("A", 0, 0.5, 1).membership(0.1)
0.2
>>> FuzzySet("B", 0.2, 0.7, 1).membership(0.6)
0.8
 - Function 'union' takes 2 arguments: self, other.  Docstring: Calculate the union of this fuzzy set with another fuzzy set.
Args:
    other (FuzzySet): Another fuzzy set to union with.
Returns:
    FuzzySet: A new fuzzy set representing the union.

>>> FuzzySet("a", 0.1, 0.2, 0.3).union(FuzzySet("b", 0.4, 0.5, 0.6))
FuzzySet(name='a U b', left_boundary=0.1, peak=0.6, right_boundary=0.35)
 - Function 'plot' takes 1 arguments: self.  Docstring: Plot the membership function of the fuzzy set.

File: basic_string.py
 - Function 'evaluate' takes 2 arguments: item, main_target.  Docstring: Evaluate how similar the item is with the target by just
counting each char in the right position
>>> evaluate("Helxo Worlx", "Hello World")
('Helxo Worlx', 9.0)
 - Function 'crossover' takes 2 arguments: parent_1, parent_2.  Docstring: Slice and combine two strings at a random point.
>>> random.seed(42)
>>> crossover("123456", "abcdef")
('12345f', 'abcde6')
 - Function 'mutate' takes 2 arguments: child, genes.  Docstring: Mutate a random gene of a child with another one from the list.
>>> random.seed(123)
>>> mutate("123456", list("ABCDEF"))
'12345A'
 - Function 'select' takes 3 arguments: parent_1, population_score, genes.  Docstring: Select the second parent and generate new population

>>> random.seed(42)
>>> parent_1 = ("123456", 8.0)
>>> population_score = [("abcdef", 4.0), ("ghijkl", 5.0), ("mnopqr", 7.0)]
>>> genes = list("ABCDEF")
>>> child_n = int(min(parent_1[1] + 1, 10))
>>> population = []
>>> for _ in range(child_n):
...     parent_2 = population_score[random.randrange(len(population_score))][0]
...     child_1, child_2 = crossover(parent_1[0], parent_2)
...     population.extend((mutate(child_1, genes), mutate(child_2, genes)))
>>> len(population) == (int(parent_1[1]) + 1) * 2
True
 - Function 'basic' takes 3 arguments: target, genes, debug.  Docstring: Verify that the target contains no genes besides the ones inside genes variable.

>>> from string import ascii_lowercase
>>> basic("doctest", ascii_lowercase, debug=False)[2]
'doctest'
>>> genes = list(ascii_lowercase)
>>> genes.remove("e")
>>> basic("test", genes)
Traceback (most recent call last):
    ...
ValueError: ['e'] is not in genes list, evolution cannot converge
>>> genes.remove("s")
>>> basic("test", genes)
Traceback (most recent call last):
    ...
ValueError: ['e', 's'] is not in genes list, evolution cannot converge
>>> genes.remove("t")
>>> basic("test", genes)
Traceback (most recent call last):
    ...
ValueError: ['e', 's', 't'] is not in genes list, evolution cannot converge

File: haversine_distance.py
 - Function 'haversine_distance' takes 4 arguments: lat1, lon1, lat2, lon2.  Docstring: Calculate great circle distance between two points in a sphere,
given longitudes and latitudes https://en.wikipedia.org/wiki/Haversine_formula

We know that the globe is "sort of" spherical, so a path between two points
isn't exactly a straight line. We need to account for the Earth's curvature
when calculating distance from point A to B. This effect is negligible for
small distances but adds up as distance increases. The Haversine method treats
the earth as a sphere which allows us to "project" the two points A and B
onto the surface of that sphere and approximate the spherical distance between
them. Since the Earth is not a perfect sphere, other methods which model the
Earth's ellipsoidal nature are more accurate but a quick and modifiable
computation like Haversine can be handy for shorter range distances.

Args:
    lat1, lon1: latitude and longitude of coordinate 1
    lat2, lon2: latitude and longitude of coordinate 2
Returns:
    geographical distance between two points in metres
>>> from collections import namedtuple
>>> point_2d = namedtuple("point_2d", "lat lon")
>>> SAN_FRANCISCO = point_2d(37.774856, -122.424227)
>>> YOSEMITE = point_2d(37.864742, -119.537521)
>>> f"{haversine_distance(*SAN_FRANCISCO, *YOSEMITE):0,.0f} meters"
'254,352 meters'

File: lamberts_ellipsoidal_distance.py
 - Function 'lamberts_ellipsoidal_distance' takes 4 arguments: lat1, lon1, lat2, lon2.  Docstring: Calculate the shortest distance along the surface of an ellipsoid between
two points on the surface of earth given longitudes and latitudes
https://en.wikipedia.org/wiki/Geographical_distance#Lambert's_formula_for_long_lines

NOTE: This algorithm uses geodesy/haversine_distance.py to compute central angle,
    sigma

Representing the earth as an ellipsoid allows us to approximate distances between
points on the surface much better than a sphere. Ellipsoidal formulas treat the
Earth as an oblate ellipsoid which means accounting for the flattening that happens
at the North and South poles. Lambert's formulae provide accuracy on the order of
10 meteres over thousands of kilometeres. Other methods can provide
millimeter-level accuracy but this is a simpler method to calculate long range
distances without increasing computational intensity.

Args:
    lat1, lon1: latitude and longitude of coordinate 1
    lat2, lon2: latitude and longitude of coordinate 2
Returns:
    geographical distance between two points in metres

>>> from collections import namedtuple
>>> point_2d = namedtuple("point_2d", "lat lon")
>>> SAN_FRANCISCO = point_2d(37.774856, -122.424227)
>>> YOSEMITE = point_2d(37.864742, -119.537521)
>>> NEW_YORK = point_2d(40.713019, -74.012647)
>>> VENICE = point_2d(45.443012, 12.313071)
>>> f"{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *YOSEMITE):0,.0f} meters"
'254,351 meters'
>>> f"{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *NEW_YORK):0,.0f} meters"
'4,138,992 meters'
>>> f"{lamberts_ellipsoidal_distance(*SAN_FRANCISCO, *VENICE):0,.0f} meters"
'9,737,326 meters'

File: geometry.py
 - Function '__post_init__' takes 1 arguments: self.  No docstring available.
 - Function '__post_init__' takes 1 arguments: self.  No docstring available.
 - Function 'area' takes 1 arguments: self.  Docstring: >>> Ellipse(5, 10).area
157.07963267948966
 - Function 'perimeter' takes 1 arguments: self.  Docstring: >>> Ellipse(5, 10).perimeter
47.12388980384689
 - Function '__init__' takes 2 arguments: self, radius.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function 'diameter' takes 1 arguments: self.  Docstring: >>> Circle(5).diameter
10
 - Function 'max_parts' takes 2 arguments: self, num_cuts.  Docstring: Return the maximum number of parts that circle can be divided into if cut
'num_cuts' times.

>>> circle = Circle(5)
>>> circle.max_parts(0)
1.0
>>> circle.max_parts(7)
29.0
>>> circle.max_parts(54)
1486.0
>>> circle.max_parts(22.5)
265.375
>>> circle.max_parts(-222)
Traceback (most recent call last):
    ...
TypeError: num_cuts must be a positive numeric value.
>>> circle.max_parts("-222")
Traceback (most recent call last):
    ...
TypeError: num_cuts must be a positive numeric value.
 - Function 'add_side' takes 2 arguments: self, side.  Docstring: >>> Polygon().add_side(Side(5))
Polygon(sides=[Side(length=5, angle=Angle(degrees=90), next_side=None)])
 - Function 'get_side' takes 2 arguments: self, index.  Docstring: >>> Polygon().get_side(0)
Traceback (most recent call last):
    ...
IndexError: list index out of range
>>> Polygon().add_side(Side(5)).get_side(-1)
Side(length=5, angle=Angle(degrees=90), next_side=None)
 - Function 'set_side' takes 3 arguments: self, index, side.  Docstring: >>> Polygon().set_side(0, Side(5))
Traceback (most recent call last):
    ...
IndexError: list assignment index out of range
>>> Polygon().add_side(Side(5)).set_side(0, Side(10))
Polygon(sides=[Side(length=10, angle=Angle(degrees=90), next_side=None)])
 - Function '__init__' takes 3 arguments: self, short_side_length, long_side_length.  No docstring available.
 - Function 'post_init' takes 1 arguments: self.  Docstring: >>> Rectangle(5, 10)  # doctest: +NORMALIZE_WHITESPACE
Rectangle(sides=[Side(length=5, angle=Angle(degrees=90), next_side=None),
Side(length=10, angle=Angle(degrees=90), next_side=None)])
 - Function 'perimeter' takes 1 arguments: self.  No docstring available.
 - Function 'area' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 2 arguments: self, side_length.  No docstring available.
 - Function 'perimeter' takes 1 arguments: self.  No docstring available.
 - Function 'area' takes 1 arguments: self.  No docstring available.

File: bezier_curve.py
 - Function '__init__' takes 2 arguments: self, list_of_points.  Docstring: list_of_points: Control points in the xy plane on which to interpolate. These
    points control the behavior (shape) of the Bezier curve.
 - Function 'basis_function' takes 2 arguments: self, t.  Docstring: The basis function determines the weight of each control point at time t.
    t: time value between 0 and 1 inclusive at which to evaluate the basis of
       the curve.
returns the x, y values of basis function at time t

>>> curve = BezierCurve([(1,1), (1,2)])
>>> curve.basis_function(0)
[1.0, 0.0]
>>> curve.basis_function(1)
[0.0, 1.0]
 - Function 'bezier_curve_function' takes 2 arguments: self, t.  Docstring: The function to produce the values of the Bezier curve at time t.
    t: the value of time t at which to evaluate the Bezier function
Returns the x, y coordinates of the Bezier curve at time t.
    The first point in the curve is when t = 0.
    The last point in the curve is when t = 1.

>>> curve = BezierCurve([(1,1), (1,2)])
>>> curve.bezier_curve_function(0)
(1.0, 1.0)
>>> curve.bezier_curve_function(1)
(1.0, 2.0)
 - Function 'plot_curve' takes 2 arguments: self, step_size.  Docstring: Plots the Bezier curve using matplotlib plotting capabilities.
    step_size: defines the step(s) at which to evaluate the Bezier curve.
    The smaller the step size, the finer the curve produced.

File: vector3_for_2d_rendering.py
 - Function 'convert_to_2d' takes 5 arguments: x, y, z, scale, distance.  Docstring: Converts 3d point to a 2d drawable point

>>> convert_to_2d(1.0, 2.0, 3.0, 10.0, 10.0)
(7.6923076923076925, 15.384615384615385)

>>> convert_to_2d(1, 2, 3, 10, 10)
(7.6923076923076925, 15.384615384615385)

>>> convert_to_2d("1", 2, 3, 10, 10)  # '1' is str
Traceback (most recent call last):
    ...
TypeError: Input values must either be float or int: ['1', 2, 3, 10, 10]
 - Function 'rotate' takes 5 arguments: x, y, z, axis, angle.  Docstring: rotate a point around a certain axis with a certain angle
angle can be any integer between 1, 360 and axis can be any one of
'x', 'y', 'z'

>>> rotate(1.0, 2.0, 3.0, 'y', 90.0)
(3.130524675073759, 2.0, 0.4470070007889556)

>>> rotate(1, 2, 3, "z", 180)
(0.999736015495891, -2.0001319704760485, 3)

>>> rotate('1', 2, 3, "z", 90.0)  # '1' is str
Traceback (most recent call last):
    ...
TypeError: Input values except axis must either be float or int: ['1', 2, 3, 90.0]

>>> rotate(1, 2, 3, "n", 90)  # 'n' is not a valid axis
Traceback (most recent call last):
    ...
ValueError: not a valid axis, choose one of 'x', 'y', 'z'

>>> rotate(1, 2, 3, "x", -90)
(1, -2.5049096187183877, -2.5933429780983657)

>>> rotate(1, 2, 3, "x", 450)  # 450 wrap around to 90
(1, 3.5776792428178217, -0.44744970165427644)

File: ant_colony_optimization_algorithms.py
 - Function 'main' takes 7 arguments: cities, ants_num, iterations_num, pheromone_evaporation, alpha, beta, q.  Docstring: Ant colony algorithm main function
>>> main(cities=cities, ants_num=10, iterations_num=20,
...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)
([0, 1, 2, 3, 4, 5, 6, 7, 0], 37.909778143828696)
>>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5,
...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)
([0, 1, 0], 5.656854249492381)
>>> main(cities={0: [0, 0], 1: [2, 2], 4: [4, 4]}, ants_num=5, iterations_num=5,
...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)
Traceback (most recent call last):
  ...
IndexError: list index out of range
>>> main(cities={}, ants_num=5, iterations_num=5,
...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)
Traceback (most recent call last):
  ...
StopIteration
>>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=0, iterations_num=5,
...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)
([], inf)
>>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=0,
...      pheromone_evaporation=0.7, alpha=1.0, beta=5.0, q=10)
([], inf)
>>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5,
...      pheromone_evaporation=1, alpha=1.0, beta=5.0, q=10)
([0, 1, 0], 5.656854249492381)
>>> main(cities={0: [0, 0], 1: [2, 2]}, ants_num=5, iterations_num=5,
...      pheromone_evaporation=0, alpha=1.0, beta=5.0, q=10)
([0, 1, 0], 5.656854249492381)
 - Function 'distance' takes 2 arguments: city1, city2.  Docstring: Calculate the distance between two coordinate points
>>> distance([0, 0], [3, 4] )
5.0
>>> distance([0, 0], [-3, 4] )
5.0
>>> distance([0, 0], [-3, -4] )
5.0
 - Function 'pheromone_update' takes 7 arguments: pheromone, cities, pheromone_evaporation, ants_route, q, best_path, best_distance.  Docstring: Update pheromones on the route and update the best route
>>>
>>> pheromone_update(pheromone=[[1.0, 1.0], [1.0, 1.0]],
...                  cities={0: [0,0], 1: [2,2]}, pheromone_evaporation=0.7,
...                  ants_route=[[0, 1, 0]], q=10, best_path=[],
...                  best_distance=float("inf"))
([[0.7, 4.235533905932737], [4.235533905932737, 0.7]], [0, 1, 0], 5.656854249492381)
>>> pheromone_update(pheromone=[],
...                  cities={0: [0,0], 1: [2,2]}, pheromone_evaporation=0.7,
...                  ants_route=[[0, 1, 0]], q=10, best_path=[],
...                  best_distance=float("inf"))
Traceback (most recent call last):
  ...
IndexError: list index out of range
>>> pheromone_update(pheromone=[[1.0, 1.0], [1.0, 1.0]],
...                  cities={}, pheromone_evaporation=0.7,
...                  ants_route=[[0, 1, 0]], q=10, best_path=[],
...                  best_distance=float("inf"))
Traceback (most recent call last):
  ...
KeyError: 0
 - Function 'city_select' takes 5 arguments: pheromone, current_city, unvisited_cities, alpha, beta.  Docstring: Choose the next city for ants
>>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={0: [0, 0]},
...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0)
({1: [2, 2]}, {})
>>> city_select(pheromone=[], current_city={0: [0,0]},
...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0)
Traceback (most recent call last):
  ...
IndexError: list index out of range
>>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={},
...             unvisited_cities={1: [2, 2]}, alpha=1.0, beta=5.0)
Traceback (most recent call last):
  ...
StopIteration
>>> city_select(pheromone=[[1.0, 1.0], [1.0, 1.0]], current_city={0: [0, 0]},
...             unvisited_cities={}, alpha=1.0, beta=5.0)
Traceback (most recent call last):
  ...
IndexError: list index out of range

File: articulation_points.py
 - Function 'compute_ap' takes 1 arguments: graph.  No docstring available.
 - Function 'dfs' takes 4 arguments: root, at, parent, out_edge_count.  No docstring available.

File: a_star.py
 - Function 'search' takes 5 arguments: grid, init, goal, cost, heuristic.  Docstring: Search for a path on a grid avoiding obstacles.
>>> grid = [[0, 1, 0, 0, 0, 0],
...         [0, 1, 0, 0, 0, 0],
...         [0, 1, 0, 0, 0, 0],
...         [0, 1, 0, 0, 1, 0],
...         [0, 0, 0, 0, 1, 0]]
>>> init = [0, 0]
>>> goal = [len(grid) - 1, len(grid[0]) - 1]
>>> cost = 1
>>> heuristic = [[0] * len(grid[0]) for _ in range(len(grid))]
>>> heuristic = [[0 for row in range(len(grid[0]))] for col in range(len(grid))]
>>> for i in range(len(grid)):
...     for j in range(len(grid[0])):
...         heuristic[i][j] = abs(i - goal[0]) + abs(j - goal[1])
...         if grid[i][j] == 1:
...             heuristic[i][j] = 99
>>> path, action = search(grid, init, goal, cost, heuristic)
>>> path  # doctest: +NORMALIZE_WHITESPACE
[[0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [4, 1], [4, 2], [4, 3], [3, 3],
[2, 3], [2, 4], [2, 5], [3, 5], [4, 5]]
>>> action  # doctest: +NORMALIZE_WHITESPACE
[[0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0], [2, 0, 0, 0, 3, 3],
[2, 0, 0, 0, 0, 2], [2, 3, 3, 3, 0, 2]]

File: basic_graphs.py
 - Function '_input' takes 1 arguments: message.  No docstring available.
 - Function 'initialize_unweighted_directed_graph' takes 2 arguments: node_count, edge_count.  No docstring available.
 - Function 'initialize_unweighted_undirected_graph' takes 2 arguments: node_count, edge_count.  No docstring available.
 - Function 'initialize_weighted_undirected_graph' takes 2 arguments: node_count, edge_count.  No docstring available.
 - Function 'dfs' takes 2 arguments: g, s.  No docstring available.
 - Function 'bfs' takes 2 arguments: g, s.  No docstring available.
 - Function 'dijk' takes 2 arguments: g, s.  No docstring available.
 - Function 'topo' takes 3 arguments: g, ind, q.  No docstring available.
 - Function 'adjm' takes 0 arguments: .  Docstring: Reading an Adjacency matrix

Parameters:
    None

Returns:
    tuple: A tuple containing a list of edges and number of edges

Example:
>>> # Simulate user input for 3 nodes
>>> input_data = "4\n0 1 0 1\n1 0 1 0\n0 1 0 1\n1 0 1 0\n"
>>> import sys,io
>>> original_input = sys.stdin
>>> sys.stdin = io.StringIO(input_data)  # Redirect stdin for testing
>>> adjm()
([(0, 1, 0, 1), (1, 0, 1, 0), (0, 1, 0, 1), (1, 0, 1, 0)], 4)
>>> sys.stdin = original_input  # Restore original stdin
 - Function 'floy' takes 1 arguments: a_and_n.  No docstring available.
 - Function 'prim' takes 2 arguments: g, s.  No docstring available.
 - Function 'edglist' takes 0 arguments: .  Docstring: Get the edges and number of edges from the user

Parameters:
    None

Returns:
    tuple: A tuple containing a list of edges and number of edges

Example:
>>> # Simulate user input for 3 edges and 4 vertices: (1, 2), (2, 3), (3, 4)
>>> input_data = "4 3\n1 2\n2 3\n3 4\n"
>>> import sys,io
>>> original_input = sys.stdin
>>> sys.stdin = io.StringIO(input_data)  # Redirect stdin for testing
>>> edglist()
([(1, 2), (2, 3), (3, 4)], 4)
>>> sys.stdin = original_input  # Restore original stdin
 - Function 'krusk' takes 1 arguments: e_and_n.  Docstring: Sort edges on the basis of distance
 - Function 'find_isolated_nodes' takes 1 arguments: graph.  Docstring: Find the isolated node in the graph

Parameters:
graph (dict): A dictionary representing a graph.

Returns:
list: A list of isolated nodes.

Examples:
>>> graph1 = {1: [2, 3], 2: [1, 3], 3: [1, 2], 4: []}
>>> find_isolated_nodes(graph1)
[4]

>>> graph2 = {'A': ['B', 'C'], 'B': ['A'], 'C': ['A'], 'D': []}
>>> find_isolated_nodes(graph2)
['D']

>>> graph3 = {'X': [], 'Y': [], 'Z': []}
>>> find_isolated_nodes(graph3)
['X', 'Y', 'Z']

>>> graph4 = {1: [2, 3], 2: [1, 3], 3: [1, 2]}
>>> find_isolated_nodes(graph4)
[]

>>> graph5 = {}
>>> find_isolated_nodes(graph5)
[]

File: bellman_ford.py
 - Function 'print_distance' takes 2 arguments: distance, src.  No docstring available.
 - Function 'check_negative_cycle' takes 3 arguments: graph, distance, edge_count.  No docstring available.
 - Function 'bellman_ford' takes 4 arguments: graph, vertex_count, edge_count, src.  Docstring: Returns shortest paths from a vertex src to all
other vertices.
>>> edges = [(2, 1, -10), (3, 2, 3), (0, 3, 5), (0, 1, 4)]
>>> g = [{"src": s, "dst": d, "weight": w} for s, d, w in edges]
>>> bellman_ford(g, 4, 4, 0)
[0.0, -2.0, 8.0, 5.0]
>>> g = [{"src": s, "dst": d, "weight": w} for s, d, w in edges + [(1, 3, 5)]]
>>> bellman_ford(g, 4, 5, 0)
Traceback (most recent call last):
 ...
Exception: Negative cycle found

File: bidirectional_a_star.py
 - Function '__init__' takes 7 arguments: self, pos_x, pos_y, goal_x, goal_y, g_cost, parent.  No docstring available.
 - Function 'calculate_heuristic' takes 1 arguments: self.  Docstring: Heuristic for the A*
 - Function '__lt__' takes 2 arguments: self, other.  No docstring available.
 - Function '__init__' takes 3 arguments: self, start, goal.  No docstring available.
 - Function 'search' takes 1 arguments: self.  No docstring available.
 - Function 'get_successors' takes 2 arguments: self, parent.  Docstring: Returns a list of successors (both in the grid and free spaces)
 - Function 'retrace_path' takes 2 arguments: self, node.  Docstring: Retrace the path from parents to parents until start node
 - Function '__init__' takes 3 arguments: self, start, goal.  No docstring available.
 - Function 'search' takes 1 arguments: self.  No docstring available.
 - Function 'retrace_bidirectional_path' takes 3 arguments: self, fwd_node, bwd_node.  No docstring available.

File: bidirectional_breadth_first_search.py
 - Function '__init__' takes 6 arguments: self, pos_x, pos_y, goal_x, goal_y, parent.  No docstring available.
 - Function '__init__' takes 3 arguments: self, start, goal.  No docstring available.
 - Function 'search' takes 1 arguments: self.  No docstring available.
 - Function 'get_successors' takes 2 arguments: self, parent.  Docstring: Returns a list of successors (both in the grid and free spaces)
 - Function 'retrace_path' takes 2 arguments: self, node.  Docstring: Retrace the path from parents to parents until start node
 - Function '__init__' takes 3 arguments: self, start, goal.  No docstring available.
 - Function 'search' takes 1 arguments: self.  No docstring available.
 - Function 'retrace_bidirectional_path' takes 3 arguments: self, fwd_node, bwd_node.  No docstring available.

File: bi_directional_dijkstra.py
 - Function 'pass_and_relaxation' takes 9 arguments: graph, v, visited_forward, visited_backward, cst_fwd, cst_bwd, queue, parent, shortest_distance.  No docstring available.
 - Function 'bidirectional_dij' takes 4 arguments: source, destination, graph_forward, graph_backward.  Docstring: Bi-directional Dijkstra's algorithm.

Returns:
    shortest_path_distance (int): length of the shortest path.

Warnings:
    If the destination is not reachable, function returns -1

>>> bidirectional_dij("E", "F", graph_fwd, graph_bwd)
3

File: boruvka.py
 - Function '__init__' takes 2 arguments: self, num_of_nodes.  Docstring: Arguments:
    num_of_nodes - the number of nodes in the graph
Attributes:
    m_num_of_nodes - the number of nodes in the graph.
    m_edges - the list of edges.
    m_component - the dictionary which stores the index of the component which
    a node belongs to.
 - Function 'add_edge' takes 4 arguments: self, u_node, v_node, weight.  Docstring: Adds an edge in the format [first, second, edge weight] to graph.
 - Function 'find_component' takes 2 arguments: self, u_node.  Docstring: Propagates a new component throughout a given component.
 - Function 'set_component' takes 2 arguments: self, u_node.  Docstring: Finds the component index of a given node
 - Function 'union' takes 4 arguments: self, component_size, u_node, v_node.  Docstring: Union finds the roots of components for two nodes, compares the components
in terms of size, and attaches the smaller one to the larger one to form
single component
 - Function 'boruvka' takes 1 arguments: self.  Docstring: Performs Borvka's algorithm to find MST.
 - Function 'test_vector' takes 0 arguments: .  Docstring: >>> g = Graph(8)
>>> for u_v_w in ((0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4),
...    (3, 4, 8), (4, 5, 10), (4, 6, 6), (4, 7, 5), (5, 7, 15), (6, 7, 4)):
...        g.add_edge(*u_v_w)
>>> g.boruvka()
Added edge [0 - 3]
Added weight: 5
<BLANKLINE>
Added edge [0 - 1]
Added weight: 10
<BLANKLINE>
Added edge [2 - 3]
Added weight: 4
<BLANKLINE>
Added edge [4 - 7]
Added weight: 5
<BLANKLINE>
Added edge [4 - 5]
Added weight: 10
<BLANKLINE>
Added edge [6 - 7]
Added weight: 4
<BLANKLINE>
Added edge [3 - 4]
Added weight: 8
<BLANKLINE>
The total weight of the minimal spanning tree is: 46

File: breadth_first_search.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'print_graph' takes 1 arguments: self.  Docstring: prints adjacency list representation of graaph
>>> g = Graph()
>>> g.print_graph()
>>> g.add_edge(0, 1)
>>> g.print_graph()
0  :  1
 - Function 'add_edge' takes 3 arguments: self, from_vertex, to_vertex.  Docstring: adding the edge between two vertices
>>> g = Graph()
>>> g.print_graph()
>>> g.add_edge(0, 1)
>>> g.print_graph()
0  :  1
 - Function 'bfs' takes 2 arguments: self, start_vertex.  Docstring: >>> g = Graph()
>>> g.add_edge(0, 1)
>>> g.add_edge(0, 1)
>>> g.add_edge(0, 2)
>>> g.add_edge(1, 2)
>>> g.add_edge(2, 0)
>>> g.add_edge(2, 3)
>>> g.add_edge(3, 3)
>>> sorted(g.bfs(2))
[0, 1, 2, 3]

File: breadth_first_search_2.py
 - Function 'breadth_first_search' takes 2 arguments: graph, start.  Docstring: Implementation of breadth first search using queue.Queue.

>>> ''.join(breadth_first_search(G, 'A'))
'ABCDEF'
 - Function 'breadth_first_search_with_deque' takes 2 arguments: graph, start.  Docstring: Implementation of breadth first search using collection.queue.

>>> ''.join(breadth_first_search_with_deque(G, 'A'))
'ABCDEF'
 - Function 'benchmark_function' takes 1 arguments: name.  No docstring available.

File: breadth_first_search_shortest_path.py
 - Function '__init__' takes 3 arguments: self, graph, source_vertex.  Docstring: Graph is implemented as dictionary of adjacency lists. Also,
Source vertex have to be defined upon initialization.
 - Function 'breath_first_search' takes 1 arguments: self.  Docstring: This function is a helper for running breath first search on this graph.
>>> g = Graph(graph, "G")
>>> g.breath_first_search()
>>> g.parent
{'G': None, 'C': 'G', 'A': 'C', 'F': 'C', 'B': 'A', 'E': 'A', 'D': 'B'}
 - Function 'shortest_path' takes 2 arguments: self, target_vertex.  Docstring: This shortest path function returns a string, describing the result:
1.) No path is found. The string is a human readable message to indicate this.
2.) The shortest path is found. The string is in the form
    `v1(->v2->v3->...->vn)`, where v1 is the source vertex and vn is the target
    vertex, if it exists separately.

>>> g = Graph(graph, "G")
>>> g.breath_first_search()

Case 1 - No path is found.
>>> g.shortest_path("Foo")
Traceback (most recent call last):
    ...
ValueError: No path from vertex: G to vertex: Foo

Case 2 - The path is found.
>>> g.shortest_path("D")
'G->C->A->B->D'
>>> g.shortest_path("G")
'G'

File: breadth_first_search_shortest_path_2.py
 - Function 'bfs_shortest_path' takes 3 arguments: graph, start, goal.  Docstring: Find shortest path between `start` and `goal` nodes.
Args:
    graph (dict): node/list of neighboring nodes key/value pairs.
    start: start node.
    goal: target node.
Returns:
    Shortest path between `start` and `goal` nodes as a string of nodes.
    'Not found' string if no path found.
Example:
    >>> bfs_shortest_path(demo_graph, "G", "D")
    ['G', 'C', 'A', 'B', 'D']
    >>> bfs_shortest_path(demo_graph, "G", "G")
    ['G']
    >>> bfs_shortest_path(demo_graph, "G", "Unknown")
    []
 - Function 'bfs_shortest_path_distance' takes 3 arguments: graph, start, target.  Docstring: Find shortest path distance between `start` and `target` nodes.
Args:
    graph: node/list of neighboring nodes key/value pairs.
    start: node to start search from.
    target: node to search for.
Returns:
    Number of edges in shortest path between `start` and `target` nodes.
    -1 if no path exists.
Example:
    >>> bfs_shortest_path_distance(demo_graph, "G", "D")
    4
    >>> bfs_shortest_path_distance(demo_graph, "A", "A")
    0
    >>> bfs_shortest_path_distance(demo_graph, "A", "Unknown")
    -1

File: breadth_first_search_zero_one_shortest_path.py
 - Function '__init__' takes 2 arguments: self, size.  No docstring available.
 - Function '__getitem__' takes 2 arguments: self, vertex.  Docstring: Get all the vertices adjacent to the given one.
 - Function 'size' takes 1 arguments: self.  No docstring available.
 - Function 'add_edge' takes 4 arguments: self, from_vertex, to_vertex, weight.  Docstring: >>> g = AdjacencyList(2)
>>> g.add_edge(0, 1, 0)
>>> g.add_edge(1, 0, 1)
>>> list(g[0])
[Edge(destination_vertex=1, weight=0)]
>>> list(g[1])
[Edge(destination_vertex=0, weight=1)]
>>> g.add_edge(0, 1, 2)
Traceback (most recent call last):
    ...
ValueError: Edge weight must be either 0 or 1.
>>> g.add_edge(0, 2, 1)
Traceback (most recent call last):
    ...
ValueError: Vertex indexes must be in [0; size).
 - Function 'get_shortest_path' takes 3 arguments: self, start_vertex, finish_vertex.  Docstring: Return the shortest distance from start_vertex to finish_vertex in 0-1-graph.
      1                  1         1
 0--------->3        6--------7>------->8
 |          ^        ^        ^         |1
 |          |        |        |0        v
0|          |0      1|        9-------->10
 |          |        |        ^    1
 v          |        |        |0
 1--------->2<-------4------->5
      0         1        1
>>> g = AdjacencyList(11)
>>> g.add_edge(0, 1, 0)
>>> g.add_edge(0, 3, 1)
>>> g.add_edge(1, 2, 0)
>>> g.add_edge(2, 3, 0)
>>> g.add_edge(4, 2, 1)
>>> g.add_edge(4, 5, 1)
>>> g.add_edge(4, 6, 1)
>>> g.add_edge(5, 9, 0)
>>> g.add_edge(6, 7, 1)
>>> g.add_edge(7, 8, 1)
>>> g.add_edge(8, 10, 1)
>>> g.add_edge(9, 7, 0)
>>> g.add_edge(9, 10, 1)
>>> g.add_edge(1, 2, 2)
Traceback (most recent call last):
    ...
ValueError: Edge weight must be either 0 or 1.
>>> g.get_shortest_path(0, 3)
0
>>> g.get_shortest_path(0, 4)
Traceback (most recent call last):
    ...
ValueError: No path from start_vertex to finish_vertex.
>>> g.get_shortest_path(4, 10)
2
>>> g.get_shortest_path(4, 8)
2
>>> g.get_shortest_path(0, 1)
0
>>> g.get_shortest_path(1, 0)
Traceback (most recent call last):
    ...
ValueError: No path from start_vertex to finish_vertex.

File: check_bipatrite.py
 - Function 'is_bipartite_dfs' takes 1 arguments: graph.  Docstring: Check if a graph is bipartite using depth-first search (DFS).

Args:
    graph: Adjacency list representing the graph.

Returns:
    True if bipartite, False otherwise.

Checks if the graph can be divided into two sets of vertices, such that no two
vertices within the same set are connected by an edge.

Examples:
# FIXME: This test should pass.
>>> is_bipartite_dfs(defaultdict(list, {0: [1, 2], 1: [0, 3], 2: [0, 4]}))
Traceback (most recent call last):
    ...
RuntimeError: dictionary changed size during iteration
>>> is_bipartite_dfs(defaultdict(list, {0: [1, 2], 1: [0, 3], 2: [0, 1]}))
False
>>> is_bipartite_dfs({})
True
>>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})
True
>>> is_bipartite_dfs({0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3], 3: [0, 2]})
False
>>> is_bipartite_dfs({0: [4], 1: [], 2: [4], 3: [4], 4: [0, 2, 3]})
True
>>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})
False
>>> is_bipartite_dfs({7: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})
Traceback (most recent call last):
    ...
KeyError: 0

# FIXME: This test should fails with KeyError: 4.
>>> is_bipartite_dfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 9: [0]})
False
>>> is_bipartite_dfs({0: [-1, 3], 1: [0, -2]})
Traceback (most recent call last):
    ...
KeyError: -1
>>> is_bipartite_dfs({-1: [0, 2], 0: [-1, 1], 1: [0, 2], 2: [-1, 1]})
True
>>> is_bipartite_dfs({0.9: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})
Traceback (most recent call last):
    ...
KeyError: 0

# FIXME: This test should fails with TypeError: list indices must be integers or...
>>> is_bipartite_dfs({0: [1.0, 3.0], 1.0: [0, 2.0], 2.0: [1.0, 3.0], 3.0: [0, 2.0]})
True
>>> is_bipartite_dfs({"a": [1, 3], "b": [0, 2], "c": [1, 3], "d": [0, 2]})
Traceback (most recent call last):
    ...
KeyError: 1
>>> is_bipartite_dfs({0: ["b", "d"], 1: ["a", "c"], 2: ["b", "d"], 3: ["a", "c"]})
Traceback (most recent call last):
    ...
KeyError: 'b'
 - Function 'depth_first_search' takes 2 arguments: node, color.  Docstring: Perform Depth-First Search (DFS) on the graph starting from a node.

Args:
    node: The current node being visited.
    color: The color assigned to the current node.

Returns:
    True if the graph is bipartite starting from the current node,
    False otherwise.
 - Function 'is_bipartite_bfs' takes 1 arguments: graph.  Docstring: Check if a graph is bipartite using a breadth-first search (BFS).

Args:
    graph: Adjacency list representing the graph.

Returns:
    True if bipartite, False otherwise.

Check if the graph can be divided into two sets of vertices, such that no two
vertices within the same set are connected by an edge.

Examples:
# FIXME: This test should pass.
>>> is_bipartite_bfs(defaultdict(list, {0: [1, 2], 1: [0, 3], 2: [0, 4]}))
Traceback (most recent call last):
    ...
RuntimeError: dictionary changed size during iteration
>>> is_bipartite_bfs(defaultdict(list, {0: [1, 2], 1: [0, 2], 2: [0, 1]}))
False
>>> is_bipartite_bfs({})
True
>>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})
True
>>> is_bipartite_bfs({0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3], 3: [0, 2]})
False
>>> is_bipartite_bfs({0: [4], 1: [], 2: [4], 3: [4], 4: [0, 2, 3]})
True
>>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})
False
>>> is_bipartite_bfs({7: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: [0]})
Traceback (most recent call last):
    ...
KeyError: 0

# FIXME: This test should fails with KeyError: 4.
>>> is_bipartite_bfs({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 9: [0]})
False
>>> is_bipartite_bfs({0: [-1, 3], 1: [0, -2]})
Traceback (most recent call last):
    ...
KeyError: -1
>>> is_bipartite_bfs({-1: [0, 2], 0: [-1, 1], 1: [0, 2], 2: [-1, 1]})
True
>>> is_bipartite_bfs({0.9: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]})
Traceback (most recent call last):
    ...
KeyError: 0

# FIXME: This test should fails with TypeError: list indices must be integers or...
>>> is_bipartite_bfs({0: [1.0, 3.0], 1.0: [0, 2.0], 2.0: [1.0, 3.0], 3.0: [0, 2.0]})
True
>>> is_bipartite_bfs({"a": [1, 3], "b": [0, 2], "c": [1, 3], "d": [0, 2]})
Traceback (most recent call last):
    ...
KeyError: 1
>>> is_bipartite_bfs({0: ["b", "d"], 1: ["a", "c"], 2: ["b", "d"], 3: ["a", "c"]})
Traceback (most recent call last):
    ...
KeyError: 'b'

File: check_cycle.py
 - Function 'check_cycle' takes 1 arguments: graph.  Docstring: Returns True if graph is cyclic else False
>>> check_cycle(graph={0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]})
False
>>> check_cycle(graph={0:[1, 2], 1:[2], 2:[0, 3], 3:[3]})
True
 - Function 'depth_first_search' takes 4 arguments: graph, vertex, visited, rec_stk.  Docstring: Recur for all neighbours.
If any neighbour is visited and in rec_stk then graph is cyclic.
>>> graph = {0:[], 1:[0, 3], 2:[0, 4], 3:[5], 4:[5], 5:[]}
>>> vertex, visited, rec_stk = 0, set(), set()
>>> depth_first_search(graph, vertex, visited, rec_stk)
False

File: connected_components.py
 - Function 'dfs' takes 3 arguments: graph, vert, visited.  Docstring: Use depth first search to find all vertices
being in the same component as initial vertex
>>> dfs(test_graph_1, 0, 5 * [False])
[0, 1, 3, 2]
>>> dfs(test_graph_2, 0, 6 * [False])
[0, 1, 3, 2]
 - Function 'connected_components' takes 1 arguments: graph.  Docstring: This function takes graph as a parameter
and then returns the list of connected components
>>> connected_components(test_graph_1)
[[0, 1, 3, 2], [4, 5, 6]]
>>> connected_components(test_graph_2)
[[0, 1, 3, 2], [4], [5]]

File: deep_clone_graph.py
 - Function '__post_init__' takes 1 arguments: self.  Docstring: >>> Node(3).neighbors
[]
 - Function '__hash__' takes 1 arguments: self.  Docstring: >>> hash(Node(3)) != 0
True
 - Function 'clone_graph' takes 1 arguments: node.  Docstring: This function returns a clone of a connected undirected graph.
>>> clone_graph(Node(1))
Node(value=1, neighbors=[])
>>> clone_graph(Node(1, [Node(2)]))
Node(value=1, neighbors=[Node(value=2, neighbors=[])])
>>> clone_graph(None) is None
True

File: depth_first_search.py
 - Function 'depth_first_search' takes 2 arguments: graph, start.  Docstring: Depth First Search on Graph
:param graph: directed graph in dictionary format
:param start: starting vertex as a string
:returns: the trace of the search
>>> input_G = { "A": ["B", "C", "D"], "B": ["A", "D", "E"],
... "C": ["A", "F"], "D": ["B", "D"], "E": ["B", "F"],
... "F": ["C", "E", "G"], "G": ["F"] }
>>> output_G = list({'A', 'B', 'C', 'D', 'E', 'F', 'G'})
>>> all(x in output_G for x in list(depth_first_search(input_G, "A")))
True
>>> all(x in output_G for x in list(depth_first_search(input_G, "G")))
True

File: depth_first_search_2.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'print_graph' takes 1 arguments: self.  Docstring: Print the graph vertices.

Example:
>>> g = Graph()
>>> g.add_edge(0, 1)
>>> g.add_edge(0, 2)
>>> g.add_edge(1, 2)
>>> g.add_edge(2, 0)
>>> g.add_edge(2, 3)
>>> g.add_edge(3, 3)
>>> g.print_graph()
{0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}
0  ->  1 -> 2
1  ->  2
2  ->  0 -> 3
3  ->  3
 - Function 'add_edge' takes 3 arguments: self, from_vertex, to_vertex.  Docstring: Add an edge between two vertices.

:param from_vertex: The source vertex.
:param to_vertex: The destination vertex.

Example:
>>> g = Graph()
>>> g.add_edge(0, 1)
>>> g.add_edge(0, 2)
>>> g.print_graph()
{0: [1, 2]}
0  ->  1 -> 2
 - Function 'dfs' takes 1 arguments: self.  Docstring: Perform depth-first search (DFS) traversal on the graph
and print the visited vertices.

Example:
>>> g = Graph()
>>> g.add_edge(0, 1)
>>> g.add_edge(0, 2)
>>> g.add_edge(1, 2)
>>> g.add_edge(2, 0)
>>> g.add_edge(2, 3)
>>> g.add_edge(3, 3)
>>> g.dfs()
0 1 2 3
 - Function 'dfs_recursive' takes 3 arguments: self, start_vertex, visited.  Docstring: Perform a recursive depth-first search (DFS) traversal on the graph.

:param start_vertex: The starting vertex for the traversal.
:param visited: A list to track visited vertices.

Example:
>>> g = Graph()
>>> g.add_edge(0, 1)
>>> g.add_edge(0, 2)
>>> g.add_edge(1, 2)
>>> g.add_edge(2, 0)
>>> g.add_edge(2, 3)
>>> g.add_edge(3, 3)
>>> visited = [False] * len(g.vertex)
>>> g.dfs_recursive(0, visited)
0 1 2 3

File: dijkstra.py
 - Function 'dijkstra' takes 3 arguments: graph, start, end.  Docstring: Return the cost of the shortest path between vertices start and end.

>>> dijkstra(G, "E", "C")
6
>>> dijkstra(G2, "E", "F")
3
>>> dijkstra(G3, "E", "F")
3

File: dijkstra_2.py
 - Function 'print_dist' takes 2 arguments: dist, v.  No docstring available.
 - Function 'min_dist' takes 3 arguments: mdist, vset, v.  No docstring available.
 - Function 'dijkstra' takes 3 arguments: graph, v, src.  No docstring available.

File: dijkstra_algorithm.py
 - Function '__init__' takes 1 arguments: self.  Docstring: Priority queue class constructor method.

Examples:
>>> priority_queue_test = PriorityQueue()
>>> priority_queue_test.cur_size
0
>>> priority_queue_test.array
[]
>>> priority_queue_test.pos
{}
 - Function 'is_empty' takes 1 arguments: self.  Docstring: Conditional boolean method to determine if the priority queue is empty or not.

Examples:
>>> priority_queue_test = PriorityQueue()
>>> priority_queue_test.is_empty()
True
>>> priority_queue_test.insert((2, 'A'))
>>> priority_queue_test.is_empty()
False
 - Function 'min_heapify' takes 2 arguments: self, idx.  Docstring: Sorts the queue array so that the minimum element is root.

Examples:
>>> priority_queue_test = PriorityQueue()
>>> priority_queue_test.cur_size = 3
>>> priority_queue_test.pos = {'A': 0, 'B': 1, 'C': 2}

>>> priority_queue_test.array = [(5, 'A'), (10, 'B'), (15, 'C')]
>>> priority_queue_test.min_heapify(0)
Traceback (most recent call last):
    ...
TypeError: 'list' object is not callable
>>> priority_queue_test.array
[(5, 'A'), (10, 'B'), (15, 'C')]

>>> priority_queue_test.array = [(10, 'A'), (5, 'B'), (15, 'C')]
>>> priority_queue_test.min_heapify(0)
Traceback (most recent call last):
    ...
TypeError: 'list' object is not callable
>>> priority_queue_test.array
[(10, 'A'), (5, 'B'), (15, 'C')]

>>> priority_queue_test.array = [(10, 'A'), (15, 'B'), (5, 'C')]
>>> priority_queue_test.min_heapify(0)
Traceback (most recent call last):
    ...
TypeError: 'list' object is not callable
>>> priority_queue_test.array
[(10, 'A'), (15, 'B'), (5, 'C')]

>>> priority_queue_test.array = [(10, 'A'), (5, 'B')]
>>> priority_queue_test.cur_size = len(priority_queue_test.array)
>>> priority_queue_test.pos = {'A': 0, 'B': 1}
>>> priority_queue_test.min_heapify(0)
Traceback (most recent call last):
    ...
TypeError: 'list' object is not callable
>>> priority_queue_test.array
[(10, 'A'), (5, 'B')]
 - Function 'insert' takes 2 arguments: self, tup.  Docstring: Inserts a node into the Priority Queue.

Examples:
>>> priority_queue_test = PriorityQueue()
>>> priority_queue_test.insert((10, 'A'))
>>> priority_queue_test.array
[(10, 'A')]
>>> priority_queue_test.insert((15, 'B'))
>>> priority_queue_test.array
[(10, 'A'), (15, 'B')]
>>> priority_queue_test.insert((5, 'C'))
>>> priority_queue_test.array
[(5, 'C'), (10, 'A'), (15, 'B')]
 - Function 'extract_min' takes 1 arguments: self.  Docstring: Removes and returns the min element at top of priority queue.

Examples:
>>> priority_queue_test = PriorityQueue()
>>> priority_queue_test.array = [(10, 'A'), (15, 'B')]
>>> priority_queue_test.cur_size = len(priority_queue_test.array)
>>> priority_queue_test.pos = {'A': 0, 'B': 1}
>>> priority_queue_test.insert((5, 'C'))
>>> priority_queue_test.extract_min()
'C'
>>> priority_queue_test.array[0]
(15, 'B')
 - Function 'left' takes 2 arguments: self, i.  Docstring: Returns the index of left child

Examples:
>>> priority_queue_test = PriorityQueue()
>>> priority_queue_test.left(0)
1
>>> priority_queue_test.left(1)
3
 - Function 'right' takes 2 arguments: self, i.  Docstring: Returns the index of right child

Examples:
>>> priority_queue_test = PriorityQueue()
>>> priority_queue_test.right(0)
2
>>> priority_queue_test.right(1)
4
 - Function 'par' takes 2 arguments: self, i.  Docstring: Returns the index of parent

Examples:
>>> priority_queue_test = PriorityQueue()
>>> priority_queue_test.par(1)
0
>>> priority_queue_test.par(2)
1
>>> priority_queue_test.par(4)
2
 - Function 'swap' takes 3 arguments: self, i, j.  Docstring: Swaps array elements at indices i and j, update the pos{}

Examples:
>>> priority_queue_test = PriorityQueue()
>>> priority_queue_test.array = [(10, 'A'), (15, 'B')]
>>> priority_queue_test.cur_size = len(priority_queue_test.array)
>>> priority_queue_test.pos = {'A': 0, 'B': 1}
>>> priority_queue_test.swap(0, 1)
>>> priority_queue_test.array
[(15, 'B'), (10, 'A')]
>>> priority_queue_test.pos
{'A': 1, 'B': 0}
 - Function 'decrease_key' takes 3 arguments: self, tup, new_d.  Docstring: Decrease the key value for a given tuple, assuming the new_d is at most old_d.

Examples:
>>> priority_queue_test = PriorityQueue()
>>> priority_queue_test.array = [(10, 'A'), (15, 'B')]
>>> priority_queue_test.cur_size = len(priority_queue_test.array)
>>> priority_queue_test.pos = {'A': 0, 'B': 1}
>>> priority_queue_test.decrease_key((10, 'A'), 5)
>>> priority_queue_test.array
[(5, 'A'), (15, 'B')]
 - Function '__init__' takes 2 arguments: self, num.  Docstring: Graph class constructor

Examples:
>>> graph_test = Graph(1)
>>> graph_test.num_nodes
1
>>> graph_test.dist
[0]
>>> graph_test.par
[-1]
>>> graph_test.adjList
{}
 - Function 'add_edge' takes 4 arguments: self, u, v, w.  Docstring: Add edge going from node u to v and v to u with weight w: u (w)-> v, v (w) -> u

Examples:
>>> graph_test = Graph(1)
>>> graph_test.add_edge(1, 2, 1)
>>> graph_test.add_edge(2, 3, 2)
>>> graph_test.adjList
{1: [(2, 1)], 2: [(1, 1), (3, 2)], 3: [(2, 2)]}
 - Function 'show_graph' takes 1 arguments: self.  Docstring: Show the graph: u -> v(w)

Examples:
>>> graph_test = Graph(1)
>>> graph_test.add_edge(1, 2, 1)
>>> graph_test.show_graph()
1 -> 2(1)
2 -> 1(1)
>>> graph_test.add_edge(2, 3, 2)
>>> graph_test.show_graph()
1 -> 2(1)
2 -> 1(1) -> 3(2)
3 -> 2(2)
 - Function 'dijkstra' takes 2 arguments: self, src.  Docstring: Dijkstra algorithm

Examples:
>>> graph_test = Graph(3)
>>> graph_test.add_edge(0, 1, 2)
>>> graph_test.add_edge(1, 2, 2)
>>> graph_test.dijkstra(0)
Distance from node: 0
Node 0 has distance: 0
Node 1 has distance: 2
Node 2 has distance: 4
>>> graph_test.dist
[0, 2, 4]

>>> graph_test = Graph(2)
>>> graph_test.add_edge(0, 1, 2)
>>> graph_test.dijkstra(0)
Distance from node: 0
Node 0 has distance: 0
Node 1 has distance: 2
>>> graph_test.dist
[0, 2]

>>> graph_test = Graph(3)
>>> graph_test.add_edge(0, 1, 2)
>>> graph_test.dijkstra(0)
Distance from node: 0
Node 0 has distance: 0
Node 1 has distance: 2
Node 2 has distance: 0
>>> graph_test.dist
[0, 2, 0]

>>> graph_test = Graph(3)
>>> graph_test.add_edge(0, 1, 2)
>>> graph_test.add_edge(1, 2, 2)
>>> graph_test.add_edge(0, 2, 1)
>>> graph_test.dijkstra(0)
Distance from node: 0
Node 0 has distance: 0
Node 1 has distance: 2
Node 2 has distance: 1
>>> graph_test.dist
[0, 2, 1]

>>> graph_test = Graph(4)
>>> graph_test.add_edge(0, 1, 4)
>>> graph_test.add_edge(1, 2, 2)
>>> graph_test.add_edge(2, 3, 1)
>>> graph_test.add_edge(0, 2, 3)
>>> graph_test.dijkstra(0)
Distance from node: 0
Node 0 has distance: 0
Node 1 has distance: 4
Node 2 has distance: 3
Node 3 has distance: 4
>>> graph_test.dist
[0, 4, 3, 4]

>>> graph_test = Graph(4)
>>> graph_test.add_edge(0, 1, 4)
>>> graph_test.add_edge(1, 2, 2)
>>> graph_test.add_edge(2, 3, 1)
>>> graph_test.add_edge(0, 2, 7)
>>> graph_test.dijkstra(0)
Distance from node: 0
Node 0 has distance: 0
Node 1 has distance: 4
Node 2 has distance: 6
Node 3 has distance: 7
>>> graph_test.dist
[0, 4, 6, 7]
 - Function 'show_distances' takes 2 arguments: self, src.  Docstring: Show the distances from src to all other nodes in a graph

Examples:
>>> graph_test = Graph(1)
>>> graph_test.show_distances(0)
Distance from node: 0
Node 0 has distance: 0
 - Function 'show_path' takes 3 arguments: self, src, dest.  Docstring: Shows the shortest path from src to dest.
WARNING: Use it *after* calling dijkstra.

Examples:
>>> graph_test = Graph(4)
>>> graph_test.add_edge(0, 1, 1)
>>> graph_test.add_edge(1, 2, 2)
>>> graph_test.add_edge(2, 3, 3)
>>> graph_test.dijkstra(0)
Distance from node: 0
Node 0 has distance: 0
Node 1 has distance: 1
Node 2 has distance: 3
Node 3 has distance: 6
>>> graph_test.show_path(0, 3)  # doctest: +NORMALIZE_WHITESPACE
----Path to reach 3 from 0----
0 -> 1 -> 2 -> 3
Total cost of path:  6

File: dijkstra_alternate.py
 - Function '__init__' takes 2 arguments: self, vertices.  Docstring: >>> graph = Graph(2)
>>> graph.vertices
2
>>> len(graph.graph)
2
>>> len(graph.graph[0])
2
 - Function 'print_solution' takes 2 arguments: self, distances_from_source.  Docstring: >>> Graph(0).print_solution([])  # doctest: +NORMALIZE_WHITESPACE
Vertex   Distance from Source
 - Function 'minimum_distance' takes 3 arguments: self, distances_from_source, visited.  Docstring: A utility function to find the vertex with minimum distance value, from the set
of vertices not yet included in shortest path tree.

>>> Graph(3).minimum_distance([1, 2, 3], [False, False, True])
0
 - Function 'dijkstra' takes 2 arguments: self, source.  Docstring: Function that implements Dijkstra's single source shortest path algorithm for a
graph represented using adjacency matrix representation.

>>> Graph(4).dijkstra(1)  # doctest: +NORMALIZE_WHITESPACE
Vertex  Distance from Source
0                10000000
1                0
2                10000000
3                10000000

File: dijkstra_binary_grid.py
 - Function 'dijkstra' takes 4 arguments: grid, source, destination, allow_diagonal.  Docstring: Implements Dijkstra's algorithm on a binary grid.

Args:
    grid (np.ndarray): A 2D numpy array representing the grid.
    1 represents a walkable node and 0 represents an obstacle.
    source (Tuple[int, int]): A tuple representing the start node.
    destination (Tuple[int, int]): A tuple representing the
    destination node.
    allow_diagonal (bool): A boolean determining whether
    diagonal movements are allowed.

Returns:
    Tuple[Union[float, int], List[Tuple[int, int]]]:
    The shortest distance from the start node to the destination node
    and the shortest path as a list of nodes.

>>> dijkstra(np.array([[1, 1, 1], [0, 1, 0], [0, 1, 1]]), (0, 0), (2, 2), False)
(4.0, [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)])

>>> dijkstra(np.array([[1, 1, 1], [0, 1, 0], [0, 1, 1]]), (0, 0), (2, 2), True)
(2.0, [(0, 0), (1, 1), (2, 2)])

>>> dijkstra(np.array([[1, 1, 1], [0, 0, 1], [0, 1, 1]]), (0, 0), (2, 2), False)
(4.0, [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)])

File: dinic.py
 - Function '__init__' takes 2 arguments: self, n.  No docstring available.
 - Function 'add_edge' takes 5 arguments: self, a, b, c, rcap.  No docstring available.
 - Function 'depth_first_search' takes 4 arguments: self, vertex, sink, flow.  No docstring available.
 - Function 'max_flow' takes 3 arguments: self, source, sink.  No docstring available.

File: directed_and_undirected_weighted_graph.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'add_pair' takes 4 arguments: self, u, v, w.  No docstring available.
 - Function 'all_nodes' takes 1 arguments: self.  No docstring available.
 - Function 'remove_pair' takes 3 arguments: self, u, v.  No docstring available.
 - Function 'dfs' takes 3 arguments: self, s, d.  No docstring available.
 - Function 'fill_graph_randomly' takes 2 arguments: self, c.  No docstring available.
 - Function 'bfs' takes 2 arguments: self, s.  No docstring available.
 - Function 'in_degree' takes 2 arguments: self, u.  No docstring available.
 - Function 'out_degree' takes 2 arguments: self, u.  No docstring available.
 - Function 'topological_sort' takes 2 arguments: self, s.  No docstring available.
 - Function 'cycle_nodes' takes 1 arguments: self.  No docstring available.
 - Function 'has_cycle' takes 1 arguments: self.  No docstring available.
 - Function 'dfs_time' takes 3 arguments: self, s, e.  No docstring available.
 - Function 'bfs_time' takes 2 arguments: self, s.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'add_pair' takes 4 arguments: self, u, v, w.  No docstring available.
 - Function 'remove_pair' takes 3 arguments: self, u, v.  No docstring available.
 - Function 'dfs' takes 3 arguments: self, s, d.  No docstring available.
 - Function 'fill_graph_randomly' takes 2 arguments: self, c.  No docstring available.
 - Function 'bfs' takes 2 arguments: self, s.  No docstring available.
 - Function 'degree' takes 2 arguments: self, u.  No docstring available.
 - Function 'cycle_nodes' takes 1 arguments: self.  No docstring available.
 - Function 'has_cycle' takes 1 arguments: self.  No docstring available.
 - Function 'all_nodes' takes 1 arguments: self.  No docstring available.
 - Function 'dfs_time' takes 3 arguments: self, s, e.  No docstring available.
 - Function 'bfs_time' takes 2 arguments: self, s.  No docstring available.

File: edmonds_karp_multiple_source_and_sink.py
 - Function '__init__' takes 4 arguments: self, graph, sources, sinks.  No docstring available.
 - Function '_normalize_graph' takes 3 arguments: self, sources, sinks.  No docstring available.
 - Function 'find_maximum_flow' takes 1 arguments: self.  No docstring available.
 - Function 'set_maximum_flow_algorithm' takes 2 arguments: self, algorithm.  No docstring available.
 - Function '__init__' takes 2 arguments: self, flow_network.  No docstring available.
 - Function 'execute' takes 1 arguments: self.  No docstring available.
 - Function '_algorithm' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 2 arguments: self, flow_network.  No docstring available.
 - Function 'get_maximum_flow' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 2 arguments: self, flow_network.  No docstring available.
 - Function '_algorithm' takes 1 arguments: self.  No docstring available.
 - Function 'process_vertex' takes 2 arguments: self, vertex_index.  No docstring available.
 - Function 'push' takes 3 arguments: self, from_index, to_index.  No docstring available.
 - Function 'relabel' takes 2 arguments: self, vertex_index.  No docstring available.

File: eulerian_path_and_circuit_for_undirected_graph.py
 - Function 'dfs' takes 4 arguments: u, graph, visited_edge, path.  No docstring available.
 - Function 'check_circuit_or_path' takes 2 arguments: graph, max_node.  No docstring available.
 - Function 'check_euler' takes 2 arguments: graph, max_node.  No docstring available.
 - Function 'main' takes 0 arguments: .  No docstring available.

File: even_tree.py
 - Function 'dfs' takes 1 arguments: start.  Docstring: DFS traversal
 - Function 'even_tree' takes 0 arguments: .  Docstring: 2 1
3 1
4 3
5 2
6 1
7 2
8 6
9 8
10 8
On removing edges (1,3) and (1,6), we can get the desired result 2.

File: finding_bridges.py
 - Function '__get_demo_graph' takes 1 arguments: index.  No docstring available.
 - Function 'compute_bridges' takes 1 arguments: graph.  Docstring: Return the list of undirected graph bridges [(a1, b1), ..., (ak, bk)]; ai <= bi
>>> compute_bridges(__get_demo_graph(0))
[(3, 4), (2, 3), (2, 5)]
>>> compute_bridges(__get_demo_graph(1))
[(6, 7), (0, 6), (1, 9), (3, 4), (2, 4), (2, 5)]
>>> compute_bridges(__get_demo_graph(2))
[(1, 6), (4, 6), (0, 4)]
>>> compute_bridges(__get_demo_graph(3))
[]
>>> compute_bridges({})
[]
 - Function 'dfs' takes 4 arguments: at, parent, bridges, id_.  No docstring available.

File: frequent_pattern_graph_miner.py
 - Function 'get_distinct_edge' takes 1 arguments: edge_array.  Docstring: Return Distinct edges from edge array of multiple graphs
>>> sorted(get_distinct_edge(edge_array))
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
 - Function 'get_bitcode' takes 2 arguments: edge_array, distinct_edge.  Docstring: Return bitcode of distinct_edge
 - Function 'get_frequency_table' takes 1 arguments: edge_array.  Docstring: Returns Frequency Table
 - Function 'get_nodes' takes 1 arguments: frequency_table.  Docstring: Returns nodes
format nodes={bitcode:edges that represent the bitcode}
>>> get_nodes([['ab', 5, '11111'], ['ac', 5, '11111'], ['df', 5, '11111'],
...            ['bd', 5, '11111'], ['bc', 5, '11111']])
{'11111': ['ab', 'ac', 'df', 'bd', 'bc']}
 - Function 'get_cluster' takes 1 arguments: nodes.  Docstring: Returns cluster
format cluster:{WT(bitcode):nodes with same WT}
 - Function 'get_support' takes 1 arguments: cluster.  Docstring: Returns support
>>> get_support({5: {'11111': ['ab', 'ac', 'df', 'bd', 'bc']},
...              4: {'11101': ['ef', 'eg', 'de', 'fg'], '11011': ['cd']},
...              3: {'11001': ['ad'], '10101': ['dg']},
...              2: {'10010': ['dh', 'bh'], '11000': ['be'], '10100': ['gh'],
...                  '10001': ['ce']},
...              1: {'00100': ['fh', 'eh'], '10000': ['hi']}})
[100.0, 80.0, 60.0, 40.0, 20.0]
 - Function 'print_all' takes 0 arguments: .  No docstring available.
 - Function 'create_edge' takes 4 arguments: nodes, graph, cluster, c1.  Docstring: create edge between the nodes
 - Function 'construct_graph' takes 2 arguments: cluster, nodes.  No docstring available.
 - Function 'my_dfs' takes 4 arguments: graph, start, end, path.  Docstring: find different DFS walk from given node to Header node
 - Function 'find_freq_subgraph_given_support' takes 3 arguments: s, cluster, graph.  Docstring: find edges of multiple frequent subgraphs
 - Function 'freq_subgraphs_edge_list' takes 1 arguments: paths.  Docstring: returns Edge list for frequent subgraphs
 - Function 'preprocess' takes 1 arguments: edge_array.  Docstring: Preprocess the edge array
>>> preprocess([['ab-e1', 'ac-e3', 'ad-e5', 'bc-e4', 'bd-e2', 'be-e6', 'bh-e12',
...              'cd-e2', 'ce-e4', 'de-e1', 'df-e8', 'dg-e5', 'dh-e10', 'ef-e3',
...              'eg-e2', 'fg-e6', 'gh-e6', 'hi-e3']])

File: gale_shapley_bigraph.py
 - Function 'stable_matching' takes 2 arguments: donor_pref, recipient_pref.  Docstring: Finds the stable match in any bipartite graph, i.e a pairing where no 2 objects
prefer each other over their partner.  The function accepts the preferences of
oegan donors and recipients (where both are assigned numbers from 0 to n-1) and
returns a list where the index position corresponds to the donor and value at the
index is the organ recipient.

To better understand the algorithm, see also:
https://github.com/akashvshroff/Gale_Shapley_Stable_Matching (README).
https://www.youtube.com/watch?v=Qcv1IqHWAzg&t=13s (Numberphile YouTube).

>>> donor_pref = [[0, 1, 3, 2], [0, 2, 3, 1], [1, 0, 2, 3], [0, 3, 1, 2]]
>>> recipient_pref = [[3, 1, 2, 0], [3, 1, 0, 2], [0, 3, 1, 2], [1, 0, 3, 2]]
>>> stable_matching(donor_pref, recipient_pref)
[1, 2, 3, 0]

File: graphs_floyd_warshall.py
 - Function '_print_dist' takes 2 arguments: dist, v.  No docstring available.
 - Function 'floyd_warshall' takes 2 arguments: graph, v.  Docstring: :param graph: 2D array calculated from weight[edge[i, j]]
:type graph: List[List[float]]
:param v: number of vertices
:type v: int
:return: shortest distance between all vertex pairs
distance[u][v] will contain the shortest distance from vertex u to v.

1. For all edges from v to n, distance[i][j] = weight(edge(i, j)).
3. The algorithm then performs distance[i][j] = min(distance[i][j], distance[i][k] +
    distance[k][j]) for each possible pair i, j of vertices.
4. The above is repeated for each vertex k in the graph.
5. Whenever distance[i][j] is given a new minimum value, next vertex[i][j] is
    updated to the next vertex[i][k].

File: graph_adjacency_list.py
 - Function '__init__' takes 4 arguments: self, vertices, edges, directed.  Docstring: Parameters:
 - vertices: (list[T]) The list of vertex names the client wants to
pass in. Default is empty.
- edges: (list[list[T]]) The list of edges the client wants to
pass in. Each edge is a 2-element list. Default is empty.
- directed: (bool) Indicates if graph is directed or undirected.
Default is True.
 - Function 'add_vertex' takes 2 arguments: self, vertex.  Docstring: Adds a vertex to the graph. If the given vertex already exists,
a ValueError will be thrown.
 - Function 'add_edge' takes 3 arguments: self, source_vertex, destination_vertex.  Docstring: Creates an edge from source vertex to destination vertex. If any
given vertex doesn't exist or the edge already exists, a ValueError
will be thrown.
 - Function 'remove_vertex' takes 2 arguments: self, vertex.  Docstring: Removes the given vertex from the graph and deletes all incoming and
outgoing edges from the given vertex as well. If the given vertex
does not exist, a ValueError will be thrown.
 - Function 'remove_edge' takes 3 arguments: self, source_vertex, destination_vertex.  Docstring: Removes the edge between the two vertices. If any given vertex
doesn't exist or the edge does not exist, a ValueError will be thrown.
 - Function 'contains_vertex' takes 2 arguments: self, vertex.  Docstring: Returns True if the graph contains the vertex, False otherwise.
 - Function 'contains_edge' takes 3 arguments: self, source_vertex, destination_vertex.  Docstring: Returns True if the graph contains the edge from the source_vertex to the
destination_vertex, False otherwise. If any given vertex doesn't exist, a
ValueError will be thrown.
 - Function 'clear_graph' takes 1 arguments: self.  Docstring: Clears all vertices and edges.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function '__assert_graph_edge_exists_check' takes 4 arguments: self, undirected_graph, directed_graph, edge.  No docstring available.
 - Function '__assert_graph_edge_does_not_exist_check' takes 4 arguments: self, undirected_graph, directed_graph, edge.  No docstring available.
 - Function '__assert_graph_vertex_exists_check' takes 4 arguments: self, undirected_graph, directed_graph, vertex.  No docstring available.
 - Function '__assert_graph_vertex_does_not_exist_check' takes 4 arguments: self, undirected_graph, directed_graph, vertex.  No docstring available.
 - Function '__generate_random_edges' takes 3 arguments: self, vertices, edge_pick_count.  No docstring available.
 - Function '__generate_graphs' takes 5 arguments: self, vertex_count, min_val, max_val, edge_pick_count.  No docstring available.
 - Function 'test_init_check' takes 1 arguments: self.  No docstring available.
 - Function 'test_contains_vertex' takes 1 arguments: self.  No docstring available.
 - Function 'test_add_vertices' takes 1 arguments: self.  No docstring available.
 - Function 'test_remove_vertices' takes 1 arguments: self.  No docstring available.
 - Function 'test_add_and_remove_vertices_repeatedly' takes 1 arguments: self.  No docstring available.
 - Function 'test_contains_edge' takes 1 arguments: self.  No docstring available.
 - Function 'test_add_edge' takes 1 arguments: self.  No docstring available.
 - Function 'test_remove_edge' takes 1 arguments: self.  No docstring available.
 - Function 'test_add_and_remove_edges_repeatedly' takes 1 arguments: self.  No docstring available.
 - Function 'test_add_vertex_exception_check' takes 1 arguments: self.  No docstring available.
 - Function 'test_remove_vertex_exception_check' takes 1 arguments: self.  No docstring available.
 - Function 'test_add_edge_exception_check' takes 1 arguments: self.  No docstring available.
 - Function 'test_remove_edge_exception_check' takes 1 arguments: self.  No docstring available.
 - Function 'test_contains_edge_exception_check' takes 1 arguments: self.  No docstring available.

File: graph_adjacency_matrix.py
 - Function '__init__' takes 4 arguments: self, vertices, edges, directed.  Docstring: Parameters:
- vertices: (list[T]) The list of vertex names the client wants to
pass in. Default is empty.
- edges: (list[list[T]]) The list of edges the client wants to
pass in. Each edge is a 2-element list. Default is empty.
- directed: (bool) Indicates if graph is directed or undirected.
Default is True.
 - Function 'add_edge' takes 3 arguments: self, source_vertex, destination_vertex.  Docstring: Creates an edge from source vertex to destination vertex. If any
given vertex doesn't exist or the edge already exists, a ValueError
will be thrown.
 - Function 'remove_edge' takes 3 arguments: self, source_vertex, destination_vertex.  Docstring: Removes the edge between the two vertices. If any given vertex
doesn't exist or the edge does not exist, a ValueError will be thrown.
 - Function 'add_vertex' takes 2 arguments: self, vertex.  Docstring: Adds a vertex to the graph. If the given vertex already exists,
a ValueError will be thrown.
 - Function 'remove_vertex' takes 2 arguments: self, vertex.  Docstring: Removes the given vertex from the graph and deletes all incoming and
outgoing edges from the given vertex as well. If the given vertex
does not exist, a ValueError will be thrown.
 - Function 'contains_vertex' takes 2 arguments: self, vertex.  Docstring: Returns True if the graph contains the vertex, False otherwise.
 - Function 'contains_edge' takes 3 arguments: self, source_vertex, destination_vertex.  Docstring: Returns True if the graph contains the edge from the source_vertex to the
destination_vertex, False otherwise. If any given vertex doesn't exist, a
ValueError will be thrown.
 - Function 'clear_graph' takes 1 arguments: self.  Docstring: Clears all vertices and edges.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function '__assert_graph_edge_exists_check' takes 4 arguments: self, undirected_graph, directed_graph, edge.  No docstring available.
 - Function '__assert_graph_edge_does_not_exist_check' takes 4 arguments: self, undirected_graph, directed_graph, edge.  No docstring available.
 - Function '__assert_graph_vertex_exists_check' takes 4 arguments: self, undirected_graph, directed_graph, vertex.  No docstring available.
 - Function '__assert_graph_vertex_does_not_exist_check' takes 4 arguments: self, undirected_graph, directed_graph, vertex.  No docstring available.
 - Function '__generate_random_edges' takes 3 arguments: self, vertices, edge_pick_count.  No docstring available.
 - Function '__generate_graphs' takes 5 arguments: self, vertex_count, min_val, max_val, edge_pick_count.  No docstring available.
 - Function 'test_init_check' takes 1 arguments: self.  No docstring available.
 - Function 'test_contains_vertex' takes 1 arguments: self.  No docstring available.
 - Function 'test_add_vertices' takes 1 arguments: self.  No docstring available.
 - Function 'test_remove_vertices' takes 1 arguments: self.  No docstring available.
 - Function 'test_add_and_remove_vertices_repeatedly' takes 1 arguments: self.  No docstring available.
 - Function 'test_contains_edge' takes 1 arguments: self.  No docstring available.
 - Function 'test_add_edge' takes 1 arguments: self.  No docstring available.
 - Function 'test_remove_edge' takes 1 arguments: self.  No docstring available.
 - Function 'test_add_and_remove_edges_repeatedly' takes 1 arguments: self.  No docstring available.
 - Function 'test_add_vertex_exception_check' takes 1 arguments: self.  No docstring available.
 - Function 'test_remove_vertex_exception_check' takes 1 arguments: self.  No docstring available.
 - Function 'test_add_edge_exception_check' takes 1 arguments: self.  No docstring available.
 - Function 'test_remove_edge_exception_check' takes 1 arguments: self.  No docstring available.
 - Function 'test_contains_edge_exception_check' takes 1 arguments: self.  No docstring available.

File: graph_list.py
 - Function '__init__' takes 2 arguments: self, directed.  Docstring: Parameters:
directed: (bool) Indicates if graph is directed or undirected. Default is True.
 - Function 'add_edge' takes 3 arguments: self, source_vertex, destination_vertex.  Docstring: Connects vertices together. Creates and Edge from source vertex to destination
vertex.
Vertices will be created if not found in graph
 - Function '__repr__' takes 1 arguments: self.  No docstring available.

File: greedy_best_first.py
 - Function '__init__' takes 7 arguments: self, pos_x, pos_y, goal_x, goal_y, g_cost, parent.  No docstring available.
 - Function 'calculate_heuristic' takes 1 arguments: self.  Docstring: The heuristic here is the Manhattan Distance
Could elaborate to offer more than one choice
 - Function '__lt__' takes 2 arguments: self, other.  No docstring available.
 - Function '__eq__' takes 2 arguments: self, other.  No docstring available.
 - Function '__init__' takes 4 arguments: self, grid, start, goal.  No docstring available.
 - Function 'search' takes 1 arguments: self.  Docstring: Search for the path,
if a path is not found, only the starting position is returned
 - Function 'get_successors' takes 2 arguments: self, parent.  Docstring: Returns a list of successors (both in the grid and free spaces)
 - Function 'retrace_path' takes 2 arguments: self, node.  Docstring: Retrace the path from parents to parents until start node

File: greedy_min_vertex_cover.py
 - Function 'greedy_min_vertex_cover' takes 1 arguments: graph.  Docstring: Greedy APX Algorithm for min Vertex Cover
@input: graph (graph stored in an adjacency list where each vertex
        is represented with an integer)
@example:
>>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}
>>> greedy_min_vertex_cover(graph)
{0, 1, 2, 4}

File: g_topological_sort.py
 - Function 'print_stack' takes 2 arguments: stack, clothes.  No docstring available.
 - Function 'depth_first_search' takes 3 arguments: u, visited, graph.  No docstring available.
 - Function 'topological_sort' takes 2 arguments: graph, visited.  No docstring available.

File: kahns_algorithm_long.py
 - Function 'longest_distance' takes 1 arguments: graph.  No docstring available.

File: kahns_algorithm_topo.py
 - Function 'topological_sort' takes 1 arguments: graph.  Docstring: Kahn's Algorithm is used to find Topological ordering of Directed Acyclic Graph
using BFS

File: karger.py
 - Function 'partition_graph' takes 1 arguments: graph.  Docstring: Partitions a graph using Karger's Algorithm. Implemented from
pseudocode found here:
https://en.wikipedia.org/wiki/Karger%27s_algorithm.
This function involves random choices, meaning it will not give
consistent outputs.

Args:
    graph: A dictionary containing adacency lists for the graph.
        Nodes must be strings.

Returns:
    The cutset of the cut found by Karger's Algorithm.

>>> graph = {'0':['1'], '1':['0']}
>>> partition_graph(graph)
{('0', '1')}

File: markov_chain.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'add_node' takes 2 arguments: self, node.  No docstring available.
 - Function 'add_transition_probability' takes 4 arguments: self, node1, node2, probability.  No docstring available.
 - Function 'get_nodes' takes 1 arguments: self.  No docstring available.
 - Function 'transition' takes 2 arguments: self, node.  No docstring available.
 - Function 'get_transitions' takes 3 arguments: start, transitions, steps.  Docstring: Running Markov Chain algorithm and calculating the number of times each node is
visited

>>> transitions = [
... ('a', 'a', 0.9),
... ('a', 'b', 0.075),
... ('a', 'c', 0.025),
... ('b', 'a', 0.15),
... ('b', 'b', 0.8),
... ('b', 'c', 0.05),
... ('c', 'a', 0.25),
... ('c', 'b', 0.25),
... ('c', 'c', 0.5)
... ]

>>> result = get_transitions('a', transitions, 5000)

>>> result['a'] > result['b'] > result['c']
True

File: matching_min_vertex_cover.py
 - Function 'matching_min_vertex_cover' takes 1 arguments: graph.  Docstring: APX Algorithm for min Vertex Cover using Matching Approach
@input: graph (graph stored in an adjacency list where each vertex
        is represented as an integer)
@example:
>>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]}
>>> matching_min_vertex_cover(graph)
{0, 1, 2, 4}
 - Function 'get_edges' takes 1 arguments: graph.  Docstring: Return a set of couples that represents all of the edges.
@input: graph (graph stored in an adjacency list where each vertex is
        represented as an integer)
@example:
>>> graph = {0: [1, 3], 1: [0, 3], 2: [0, 3], 3: [0, 1, 2]}
>>> get_edges(graph)
{(0, 1), (3, 1), (0, 3), (2, 0), (3, 0), (2, 3), (1, 0), (3, 2), (1, 3)}

File: minimum_path_sum.py
 - Function 'min_path_sum' takes 1 arguments: grid.  Docstring: Find the path from top left to bottom right of array of numbers
with the lowest possible sum and return the sum along this path.
>>> min_path_sum([
...     [1, 3, 1],
...     [1, 5, 1],
...     [4, 2, 1],
... ])
7

>>> min_path_sum([
...     [1, 0, 5, 6, 7],
...     [8, 9, 0, 4, 2],
...     [4, 4, 4, 5, 1],
...     [9, 6, 3, 1, 0],
...     [8, 4, 3, 2, 7],
... ])
20

>>> min_path_sum(None)
Traceback (most recent call last):
    ...
TypeError: The grid does not contain the appropriate information

>>> min_path_sum([[]])
Traceback (most recent call last):
    ...
TypeError: The grid does not contain the appropriate information
 - Function 'fill_row' takes 2 arguments: current_row, row_above.  Docstring: >>> fill_row([2, 2, 2], [1, 2, 3])
[3, 4, 5]

File: minimum_spanning_tree_boruvka.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'add_vertex' takes 2 arguments: self, vertex.  Docstring: Adds a vertex to the graph
 - Function 'add_edge' takes 4 arguments: self, head, tail, weight.  Docstring: Adds an edge to the graph
 - Function 'distinct_weight' takes 1 arguments: self.  Docstring: For Boruvks's algorithm the weights should be distinct
Converts the weights to be distinct
 - Function '__str__' takes 1 arguments: self.  Docstring: Returns string representation of the graph
 - Function 'get_edges' takes 1 arguments: self.  Docstring: Returna all edges in the graph
 - Function 'get_vertices' takes 1 arguments: self.  Docstring: Returns all vertices in the graph
 - Function 'build' takes 2 arguments: vertices, edges.  Docstring: Builds a graph from the given set of vertices and edges
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__len__' takes 1 arguments: self.  No docstring available.
 - Function 'make_set' takes 2 arguments: self, item.  No docstring available.
 - Function 'find' takes 2 arguments: self, item.  No docstring available.
 - Function 'union' takes 3 arguments: self, item1, item2.  No docstring available.
 - Function 'boruvka_mst' takes 1 arguments: graph.  Docstring: Implementation of Boruvka's algorithm
>>> g = Graph()
>>> g = Graph.build([0, 1, 2, 3], [[0, 1, 1], [0, 2, 1],[2, 3, 1]])
>>> g.distinct_weight()
>>> bg = Graph.boruvka_mst(g)
>>> print(bg)
1 -> 0 == 1
2 -> 0 == 2
0 -> 1 == 1
0 -> 2 == 2
3 -> 2 == 3
2 -> 3 == 3

File: minimum_spanning_tree_kruskal.py
 - Function 'kruskal' takes 2 arguments: num_nodes, edges.  Docstring: >>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1)])
[(2, 3, 1), (0, 1, 3), (1, 2, 5)]

>>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1), (0, 2, 1), (0, 3, 2)])
[(2, 3, 1), (0, 2, 1), (0, 1, 3)]

>>> kruskal(4, [(0, 1, 3), (1, 2, 5), (2, 3, 1), (0, 2, 1), (0, 3, 2),
... (2, 1, 1)])
[(2, 3, 1), (0, 2, 1), (2, 1, 1)]
 - Function 'find_parent' takes 1 arguments: i.  No docstring available.

File: minimum_spanning_tree_kruskal2.py
 - Function '__init__' takes 2 arguments: self, data.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'make_set' takes 2 arguments: self, data.  No docstring available.
 - Function 'find_set' takes 2 arguments: self, data.  No docstring available.
 - Function 'link' takes 3 arguments: self, node1, node2.  No docstring available.
 - Function 'union' takes 3 arguments: self, data1, data2.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'add_node' takes 2 arguments: self, node.  No docstring available.
 - Function 'add_edge' takes 4 arguments: self, node1, node2, weight.  No docstring available.
 - Function 'kruskal' takes 1 arguments: self.  Docstring: Details: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm

Example:
>>> g1 = GraphUndirectedWeighted[int]()
>>> g1.add_edge(1, 2, 1)
>>> g1.add_edge(2, 3, 2)
>>> g1.add_edge(3, 4, 1)
>>> g1.add_edge(3, 5, 100) # Removed in MST
>>> g1.add_edge(4, 5, 5)
>>> assert 5 in g1.connections[3]
>>> mst = g1.kruskal()
>>> assert 5 not in mst.connections[3]

>>> g2 = GraphUndirectedWeighted[str]()
>>> g2.add_edge('A', 'B', 1)
>>> g2.add_edge('B', 'C', 2)
>>> g2.add_edge('C', 'D', 1)
>>> g2.add_edge('C', 'E', 100) # Removed in MST
>>> g2.add_edge('D', 'E', 5)
>>> assert 'E' in g2.connections["C"]
>>> mst = g2.kruskal()
>>> assert 'E' not in mst.connections['C']

File: minimum_spanning_tree_prims.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'get_position' takes 2 arguments: self, vertex.  No docstring available.
 - Function 'set_position' takes 3 arguments: self, vertex, pos.  No docstring available.
 - Function 'top_to_bottom' takes 5 arguments: self, heap, start, size, positions.  No docstring available.
 - Function 'bottom_to_top' takes 5 arguments: self, val, index, heap, position.  No docstring available.
 - Function 'heapify' takes 3 arguments: self, heap, positions.  No docstring available.
 - Function 'delete_minimum' takes 3 arguments: self, heap, positions.  No docstring available.
 - Function 'prisms_algorithm' takes 1 arguments: adjacency_list.  Docstring: >>> adjacency_list = {0: [[1, 1], [3, 3]],
...                   1: [[0, 1], [2, 6], [3, 5], [4, 1]],
...                   2: [[1, 6], [4, 5], [5, 2]],
...                   3: [[0, 3], [1, 5], [4, 1]],
...                   4: [[1, 1], [2, 5], [3, 1], [5, 4]],
...                   5: [[2, 2], [4, 4]]}
>>> prisms_algorithm(adjacency_list)
[(0, 1), (1, 4), (4, 3), (4, 5), (5, 2)]

File: minimum_spanning_tree_prims2.py
 - Function 'get_parent_position' takes 1 arguments: position.  Docstring: heap helper function get the position of the parent of the current node

>>> get_parent_position(1)
0
>>> get_parent_position(2)
0
 - Function 'get_child_left_position' takes 1 arguments: position.  Docstring: heap helper function get the position of the left child of the current node

>>> get_child_left_position(0)
1
 - Function 'get_child_right_position' takes 1 arguments: position.  Docstring: heap helper function get the position of the right child of the current node

>>> get_child_right_position(0)
2
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__len__' takes 1 arguments: self.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function 'is_empty' takes 1 arguments: self.  No docstring available.
 - Function 'push' takes 3 arguments: self, elem, weight.  No docstring available.
 - Function 'extract_min' takes 1 arguments: self.  No docstring available.
 - Function 'update_key' takes 3 arguments: self, elem, weight.  No docstring available.
 - Function '_bubble_up' takes 2 arguments: self, elem.  No docstring available.
 - Function '_bubble_down' takes 2 arguments: self, elem.  No docstring available.
 - Function '_swap_nodes' takes 3 arguments: self, node1_pos, node2_pos.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function '__len__' takes 1 arguments: self.  No docstring available.
 - Function 'add_node' takes 2 arguments: self, node.  No docstring available.
 - Function 'add_edge' takes 4 arguments: self, node1, node2, weight.  No docstring available.
 - Function 'prims_algo' takes 1 arguments: graph.  Docstring: >>> graph = GraphUndirectedWeighted()

>>> graph.add_edge("a", "b", 3)
>>> graph.add_edge("b", "c", 10)
>>> graph.add_edge("c", "d", 5)
>>> graph.add_edge("a", "c", 15)
>>> graph.add_edge("b", "d", 100)

>>> dist, parent = prims_algo(graph)

>>> abs(dist["a"] - dist["b"])
3
>>> abs(dist["d"] - dist["b"])
15
>>> abs(dist["a"] - dist["c"])
13

File: multi_heuristic_astar.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'minkey' takes 1 arguments: self.  No docstring available.
 - Function 'empty' takes 1 arguments: self.  No docstring available.
 - Function 'put' takes 3 arguments: self, item, priority.  No docstring available.
 - Function 'remove_element' takes 2 arguments: self, item.  No docstring available.
 - Function 'top_show' takes 1 arguments: self.  No docstring available.
 - Function 'get' takes 1 arguments: self.  No docstring available.
 - Function 'consistent_heuristic' takes 2 arguments: p, goal.  No docstring available.
 - Function 'heuristic_2' takes 2 arguments: p, goal.  No docstring available.
 - Function 'heuristic_1' takes 2 arguments: p, goal.  No docstring available.
 - Function 'key' takes 4 arguments: start, i, goal, g_function.  No docstring available.
 - Function 'do_something' takes 3 arguments: back_pointer, goal, start.  No docstring available.
 - Function 'valid' takes 1 arguments: p.  No docstring available.
 - Function 'expand_state' takes 8 arguments: s, j, visited, g_function, close_list_anchor, close_list_inad, open_list, back_pointer.  No docstring available.
 - Function 'make_common_ground' takes 0 arguments: .  No docstring available.
 - Function 'multi_a_star' takes 3 arguments: start, goal, n_heuristic.  No docstring available.

File: page_rank.py
 - Function '__init__' takes 2 arguments: self, name.  No docstring available.
 - Function 'add_inbound' takes 2 arguments: self, node.  No docstring available.
 - Function 'add_outbound' takes 2 arguments: self, node.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function 'page_rank' takes 3 arguments: nodes, limit, d.  No docstring available.
 - Function 'main' takes 0 arguments: .  No docstring available.

File: prim.py
 - Function '__init__' takes 2 arguments: self, id_.  Docstring: Arguments:
    id - input an id to identify the vertex
Attributes:
    neighbors - a list of the vertices it is linked to
    edges     - a dict to store the edges's weight
 - Function '__lt__' takes 2 arguments: self, other.  Docstring: Comparison rule to < operator.
 - Function '__repr__' takes 1 arguments: self.  Docstring: Return the vertex id.
 - Function 'add_neighbor' takes 2 arguments: self, vertex.  Docstring: Add a pointer to a vertex at neighbor's list.
 - Function 'add_edge' takes 3 arguments: self, vertex, weight.  Docstring: Destination vertex and weight.
 - Function 'connect' takes 4 arguments: graph, a, b, edge.  No docstring available.
 - Function 'prim' takes 2 arguments: graph, root.  Docstring: Prim's Algorithm.

Runtime:
    O(mn) with `m` edges and `n` vertices

Return:
    List with the edges of a Minimum Spanning Tree

Usage:
    prim(graph, graph[0])
 - Function 'prim_heap' takes 2 arguments: graph, root.  Docstring: Prim's Algorithm with min heap.

Runtime:
    O((m + n)log n) with `m` edges and `n` vertices

Yield:
    Edges of a Minimum Spanning Tree

Usage:
    prim(graph, graph[0])
 - Function 'test_vector' takes 0 arguments: .  Docstring: # Creates a list to store x vertices.
>>> x = 5
>>> G = [Vertex(n) for n in range(x)]

>>> connect(G, 1, 2, 15)
>>> connect(G, 1, 3, 12)
>>> connect(G, 2, 4, 13)
>>> connect(G, 2, 5, 5)
>>> connect(G, 3, 2, 6)
>>> connect(G, 3, 4, 6)
>>> connect(G, 0, 0, 0)  # Generate the minimum spanning tree:
>>> G_heap = G[:]
>>> MST = prim(G, G[0])
>>> MST_heap = prim_heap(G, G[0])
>>> for i in MST:
...     print(i)
(2, 3)
(3, 1)
(4, 3)
(5, 2)
>>> for i in MST_heap:
...     print(i)
(2, 3)
(3, 1)
(4, 3)
(5, 2)

File: random_graph_generator.py
 - Function 'random_graph' takes 3 arguments: vertices_number, probability, directed.  Docstring: Generate a random graph
@input: vertices_number (number of vertices),
        probability (probability that a generic edge (u,v) exists),
        directed (if True: graph will be a directed graph,
                  otherwise it will be an undirected graph)
@examples:
>>> random.seed(1)
>>> random_graph(4, 0.5)
{0: [1], 1: [0, 2, 3], 2: [1, 3], 3: [1, 2]}
>>> random.seed(1)
>>> random_graph(4, 0.5, True)
{0: [1], 1: [2, 3], 2: [3], 3: []}
 - Function 'complete_graph' takes 1 arguments: vertices_number.  Docstring: Generate a complete graph with vertices_number vertices.
@input: vertices_number (number of vertices),
        directed (False if the graph is undirected, True otherwise)
@example:
>>> complete_graph(3)
{0: [1, 2], 1: [0, 2], 2: [0, 1]}

File: scc_kosaraju.py
 - Function 'dfs' takes 1 arguments: u.  No docstring available.
 - Function 'dfs2' takes 1 arguments: u.  No docstring available.
 - Function 'kosaraju' takes 0 arguments: .  No docstring available.

File: strongly_connected_components.py
 - Function 'topology_sort' takes 3 arguments: graph, vert, visited.  Docstring: Use depth first search to sort graph
At this time graph is the same as input
>>> topology_sort(test_graph_1, 0, 5 * [False])
[1, 2, 4, 3, 0]
>>> topology_sort(test_graph_2, 0, 6 * [False])
[2, 1, 5, 4, 3, 0]
 - Function 'find_components' takes 3 arguments: reversed_graph, vert, visited.  Docstring: Use depth first search to find strongly connected
vertices. Now graph is reversed
>>> find_components({0: [1], 1: [2], 2: [0]}, 0, 5 * [False])
[0, 1, 2]
>>> find_components({0: [2], 1: [0], 2: [0, 1]}, 0, 6 * [False])
[0, 2, 1]
 - Function 'strongly_connected_components' takes 1 arguments: graph.  Docstring: This function takes graph as a parameter
and then returns the list of strongly connected components
>>> strongly_connected_components(test_graph_1)
[[0, 1, 2], [3], [4]]
>>> strongly_connected_components(test_graph_2)
[[0, 2, 1], [3, 5, 4]]

File: tarjans_scc.py
 - Function 'tarjan' takes 1 arguments: g.  Docstring: Tarjan's algo for finding strongly connected components in a directed graph

Uses two main attributes of each node to track reachability, the index of that node
within a component(index), and the lowest index reachable from that node(lowlink).

We then perform a dfs of the each component making sure to update these parameters
for each node and saving the nodes we visit on the way.

If ever we find that the lowest reachable node from a current node is equal to the
index of the current node then it must be the root of a strongly connected
component and so we save it and it's equireachable vertices as a strongly
connected component.

Complexity: strong_connect() is called at most once for each node and has a
complexity of O(|E|) as it is DFS.
Therefore this has complexity O(|V| + |E|) for a graph G = (V, E)

>>> tarjan([[2, 3, 4], [2, 3, 4], [0, 1, 3], [0, 1, 2], [1]])
[[4, 3, 1, 2, 0]]
>>> tarjan([[], [], [], []])
[[0], [1], [2], [3]]
>>> a = [0, 1, 2, 3, 4, 5, 4]
>>> b = [1, 0, 3, 2, 5, 4, 0]
>>> n = 7
>>> sorted(tarjan(create_graph(n, list(zip(a, b))))) == sorted(
...     tarjan(create_graph(n, list(zip(a[::-1], b[::-1])))))
True
>>> a = [0, 1, 2, 3, 4, 5, 6]
>>> b = [0, 1, 2, 3, 4, 5, 6]
>>> sorted(tarjan(create_graph(n, list(zip(a, b)))))
[[0], [1], [2], [3], [4], [5], [6]]
 - Function 'strong_connect' takes 3 arguments: v, index, components.  No docstring available.
 - Function 'create_graph' takes 2 arguments: n, edges.  Docstring: >>> n = 7
>>> source = [0, 0, 1, 2, 3, 3, 4, 4, 6]
>>> target = [1, 3, 2, 0, 1, 4, 5, 6, 5]
>>> edges = list(zip(source, target))
>>> create_graph(n, edges)
[[1, 3], [2], [0], [1, 4], [5, 6], [], [5]]

File: test_min_spanning_tree_kruskal.py
 - Function 'test_kruskal_successful_result' takes 0 arguments: .  No docstring available.

File: test_min_spanning_tree_prim.py
 - Function 'test_prim_successful_result' takes 0 arguments: .  No docstring available.

File: best_time_to_buy_and_sell_stock.py
 - Function 'max_profit' takes 1 arguments: prices.  Docstring: >>> max_profit([7, 1, 5, 3, 6, 4])
5
>>> max_profit([7, 6, 4, 3, 1])
0

File: fractional_cover_problem.py
 - Function 'ratio' takes 1 arguments: self.  Docstring: Return the value-to-weight ratio for the item.

Returns:
    float: The value-to-weight ratio for the item.

Examples:
>>> Item(10, 65).ratio
6.5

>>> Item(20, 100).ratio
5.0

>>> Item(30, 120).ratio
4.0
 - Function 'fractional_cover' takes 2 arguments: items, capacity.  Docstring: Solve the Fractional Cover Problem.

Args:
    items: A list of items, where each item has weight and value attributes.
    capacity: The maximum weight capacity of the knapsack.

Returns:
    The maximum value that can be obtained by selecting fractions of items to cover
    the knapsack's capacity.

Raises:
    ValueError: If capacity is negative.

Examples:
>>> fractional_cover((Item(10, 60), Item(20, 100), Item(30, 120)), capacity=50)
240.0

>>> fractional_cover([Item(20, 100), Item(30, 120), Item(10, 60)], capacity=25)
135.0

>>> fractional_cover([Item(10, 60), Item(20, 100), Item(30, 120)], capacity=60)
280.0

>>> fractional_cover(items=[Item(5, 30), Item(10, 60), Item(15, 90)], capacity=30)
180.0

>>> fractional_cover(items=[], capacity=50)
0.0

>>> fractional_cover(items=[Item(10, 60)], capacity=5)
30.0

>>> fractional_cover(items=[Item(10, 60)], capacity=1)
6.0

>>> fractional_cover(items=[Item(10, 60)], capacity=0)
0.0

>>> fractional_cover(items=[Item(10, 60)], capacity=-1)
Traceback (most recent call last):
    ...
ValueError: Capacity cannot be negative

File: fractional_knapsack.py
 - Function 'frac_knapsack' takes 4 arguments: vl, wt, w, n.  Docstring: >>> frac_knapsack([60, 100, 120], [10, 20, 30], 50, 3)
240.0
>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 10, 4)
105.0
>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 4)
95.0
>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6], 8, 4)
60.0
>>> frac_knapsack([10, 40, 30], [5, 4, 6, 3], 8, 4)
60.0
>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 0, 4)
0
>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 0)
95.0
>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], -8, 4)
0
>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, -4)
95.0
>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 800, 4)
130
>>> frac_knapsack([10, 40, 30, 50], [5, 4, 6, 3], 8, 400)
95.0
>>> frac_knapsack("ABCD", [5, 4, 6, 3], 8, 400)
Traceback (most recent call last):
    ...
TypeError: unsupported operand type(s) for /: 'str' and 'int'

File: fractional_knapsack_2.py
 - Function 'fractional_knapsack' takes 3 arguments: value, weight, capacity.  Docstring: >>> value = [1, 3, 5, 7, 9]
>>> weight = [0.9, 0.7, 0.5, 0.3, 0.1]
>>> fractional_knapsack(value, weight, 5)
(25, [1, 1, 1, 1, 1])
>>> fractional_knapsack(value, weight, 15)
(25, [1, 1, 1, 1, 1])
>>> fractional_knapsack(value, weight, 25)
(25, [1, 1, 1, 1, 1])
>>> fractional_knapsack(value, weight, 26)
(25, [1, 1, 1, 1, 1])
>>> fractional_knapsack(value, weight, -1)
(-90.0, [0, 0, 0, 0, -10.0])
>>> fractional_knapsack([1, 3, 5, 7], weight, 30)
(16, [1, 1, 1, 1])
>>> fractional_knapsack(value, [0.9, 0.7, 0.5, 0.3, 0.1], 30)
(25, [1, 1, 1, 1, 1])
>>> fractional_knapsack([], [], 30)
(0, [])

File: gas_station.py
 - Function 'get_gas_stations' takes 2 arguments: gas_quantities, costs.  Docstring: This function returns a tuple of gas stations.

Args:
    gas_quantities: Amount of gas available at each station
    costs: The cost of gas required to move from one station to the next

Returns:
    A tuple of gas stations

>>> gas_stations = get_gas_stations([1, 2, 3, 4, 5], [3, 4, 5, 1, 2])
>>> len(gas_stations)
5
>>> gas_stations[0]
GasStation(gas_quantity=1, cost=3)
>>> gas_stations[-1]
GasStation(gas_quantity=5, cost=2)
 - Function 'can_complete_journey' takes 1 arguments: gas_stations.  Docstring: This function returns the index from which to start the journey
in order to reach the end.

Args:
    gas_quantities [list]: Amount of gas available at each station
    cost [list]: The cost of gas required to move from one station to the next

Returns:
    start [int]: start index needed to complete the journey

Examples:
>>> can_complete_journey(get_gas_stations([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]))
3
>>> can_complete_journey(get_gas_stations([2, 3, 4], [3, 4, 3]))
-1

File: minimum_waiting_time.py
 - Function 'minimum_waiting_time' takes 1 arguments: queries.  Docstring: This function takes a list of query times and returns the minimum waiting time
for all queries to be completed.

Args:
    queries: A list of queries measured in picoseconds

Returns:
    total_waiting_time: Minimum waiting time measured in picoseconds

Examples:
>>> minimum_waiting_time([3, 2, 1, 2, 6])
17
>>> minimum_waiting_time([3, 2, 1])
4
>>> minimum_waiting_time([1, 2, 3, 4])
10
>>> minimum_waiting_time([5, 5, 5, 5])
30
>>> minimum_waiting_time([])
0

File: optimal_merge_pattern.py
 - Function 'optimal_merge_pattern' takes 1 arguments: files.  Docstring: Function to merge all the files with optimum cost

Args:
    files [list]: A list of sizes of different files to be merged

Returns:
    optimal_merge_cost [int]: Optimal cost to merge all those files

Examples:
>>> optimal_merge_pattern([2, 3, 4])
14
>>> optimal_merge_pattern([5, 10, 20, 30, 30])
205
>>> optimal_merge_pattern([8, 8, 8, 8, 8])
96

File: smallest_range.py
 - Function 'smallest_range' takes 1 arguments: nums.  Docstring: Find the smallest range from each list in nums.

Uses min heap for efficiency. The range includes at least one number from each list.

Args:
    nums: List of k sorted integer lists.

Returns:
    list: Smallest range as a two-element list.

Examples:
>>> smallest_range([[4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30]])
[20, 24]
>>> smallest_range([[1, 2, 3], [1, 2, 3], [1, 2, 3]])
[1, 1]
>>> smallest_range(((1, 2, 3), (1, 2, 3), (1, 2, 3)))
[1, 1]
>>> smallest_range(((-3, -2, -1), (0, 0, 0), (1, 2, 3)))
[-1, 1]
>>> smallest_range([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
[3, 7]
>>> smallest_range([[0, 0, 0], [0, 0, 0], [0, 0, 0]])
[0, 0]
>>> smallest_range([[], [], []])
Traceback (most recent call last):
    ...
IndexError: list index out of range

File: adler32.py
 - Function 'adler32' takes 1 arguments: plain_text.  Docstring: Function implements adler-32 hash.
Iterates and evaluates a new value for each character

>>> adler32('Algorithms')
363791387

>>> adler32('go adler em all')
708642122

File: chaos_machine.py
 - Function 'push' takes 1 arguments: seed.  No docstring available.
 - Function 'pull' takes 0 arguments: .  No docstring available.
 - Function 'xorshift' takes 2 arguments: x, y.  No docstring available.
 - Function 'reset' takes 0 arguments: .  No docstring available.

File: djb2.py
 - Function 'djb2' takes 1 arguments: s.  Docstring: Implementation of djb2 hash algorithm that
is popular because of it's magic constants.

>>> djb2('Algorithms')
3782405311

>>> djb2('scramble bits')
1609059040

File: elf.py
 - Function 'elf_hash' takes 1 arguments: data.  Docstring: Implementation of ElfHash Algorithm, a variant of PJW hash function.

>>> elf_hash('lorem ipsum')
253956621

File: enigma_machine.py
 - Function 'rotator' takes 0 arguments: .  No docstring available.
 - Function 'engine' takes 1 arguments: input_character.  No docstring available.

File: fletcher16.py
 - Function 'fletcher16' takes 1 arguments: text.  Docstring: Loop through every character in the data and add to two sums.

>>> fletcher16('hello world')
6752
>>> fletcher16('onethousandfourhundredthirtyfour')
28347
>>> fletcher16('The quick brown fox jumps over the lazy dog.')
5655

File: hamming_code.py
 - Function 'text_to_bits' takes 3 arguments: text, encoding, errors.  Docstring: >>> text_to_bits("msg")
'011011010111001101100111'
 - Function 'text_from_bits' takes 3 arguments: bits, encoding, errors.  Docstring: >>> text_from_bits('011011010111001101100111')
'msg'
 - Function 'emitter_converter' takes 2 arguments: size_par, data.  Docstring: :param size_par: how many parity bits the message must have
:param data:  information bits
:return: message to be transmitted by unreliable medium
        - bits of information merged with parity bits

>>> emitter_converter(4, "101010111111")
['1', '1', '1', '1', '0', '1', '0', '0', '1', '0', '1', '1', '1', '1', '1', '1']
>>> emitter_converter(5, "101010111111")
Traceback (most recent call last):
    ...
ValueError: size of parity don't match with size of data
 - Function 'receptor_converter' takes 2 arguments: size_par, data.  Docstring: >>> receptor_converter(4, "1111010010111111")
(['1', '0', '1', '0', '1', '0', '1', '1', '1', '1', '1', '1'], True)

File: luhn.py
 - Function 'is_luhn' takes 1 arguments: string.  Docstring: Perform Luhn validation on an input string
Algorithm:
* Double every other digit starting from 2nd last digit.
* Subtract 9 if number is greater than 9.
* Sum the numbers
*
>>> test_cases = (79927398710, 79927398711, 79927398712, 79927398713,
...     79927398714, 79927398715, 79927398716, 79927398717, 79927398718,
...     79927398719)
>>> [is_luhn(str(test_case)) for test_case in test_cases]
[False, False, False, True, False, False, False, False, False, False]

File: md5.py
 - Function 'to_little_endian' takes 1 arguments: string_32.  Docstring: Converts the given string to little-endian in groups of 8 chars.

Arguments:
    string_32 {[string]} -- [32-char string]

Raises:
    ValueError -- [input is not 32 char]

Returns:
    32-char little-endian string
>>> to_little_endian(b'1234567890abcdfghijklmnopqrstuvw')
b'pqrstuvwhijklmno90abcdfg12345678'
>>> to_little_endian(b'1234567890')
Traceback (most recent call last):
...
ValueError: Input must be of length 32
 - Function 'reformat_hex' takes 1 arguments: i.  Docstring: Converts the given non-negative integer to hex string.

Example: Suppose the input is the following:
    i = 1234

    The input is 0x000004d2 in hex, so the little-endian hex string is
    "d2040000".

Arguments:
    i {[int]} -- [integer]

Raises:
    ValueError -- [input is negative]

Returns:
    8-char little-endian hex string

>>> reformat_hex(1234)
b'd2040000'
>>> reformat_hex(666)
b'9a020000'
>>> reformat_hex(0)
b'00000000'
>>> reformat_hex(1234567890)
b'd2029649'
>>> reformat_hex(1234567890987654321)
b'b11c6cb1'
>>> reformat_hex(-1)
Traceback (most recent call last):
...
ValueError: Input must be non-negative
 - Function 'preprocess' takes 1 arguments: message.  Docstring: Preprocesses the message string:
- Convert message to bit string
- Pad bit string to a multiple of 512 chars:
    - Append a 1
    - Append 0's until length = 448 (mod 512)
    - Append length of original message (64 chars)

Example: Suppose the input is the following:
    message = "a"

    The message bit string is "01100001", which is 8 bits long. Thus, the
    bit string needs 439 bits of padding so that
    (bit_string + "1" + padding) = 448 (mod 512).
    The message length is "000010000...0" in 64-bit little-endian binary.
    The combined bit string is then 512 bits long.

Arguments:
    message {[string]} -- [message string]

Returns:
    processed bit string padded to a multiple of 512 chars

>>> preprocess(b"a") == (b"01100001" + b"1" +
...                     (b"0" * 439) + b"00001000" + (b"0" * 56))
True
>>> preprocess(b"") == b"1" + (b"0" * 447) + (b"0" * 64)
True
 - Function 'get_block_words' takes 1 arguments: bit_string.  Docstring: Splits bit string into blocks of 512 chars and yields each block as a list
of 32-bit words

Example: Suppose the input is the following:
    bit_string =
        "000000000...0" +  # 0x00 (32 bits, padded to the right)
        "000000010...0" +  # 0x01 (32 bits, padded to the right)
        "000000100...0" +  # 0x02 (32 bits, padded to the right)
        "000000110...0" +  # 0x03 (32 bits, padded to the right)
        ...
        "000011110...0"    # 0x0a (32 bits, padded to the right)

    Then len(bit_string) == 512, so there'll be 1 block. The block is split
    into 32-bit words, and each word is converted to little endian. The
    first word is interpreted as 0 in decimal, the second word is
    interpreted as 1 in decimal, etc.

    Thus, block_words == [[0, 1, 2, 3, ..., 15]].

Arguments:
    bit_string {[string]} -- [bit string with multiple of 512 as length]

Raises:
    ValueError -- [length of bit string isn't multiple of 512]

Yields:
    a list of 16 32-bit words

>>> test_string = ("".join(format(n << 24, "032b") for n in range(16))
...                  .encode("utf-8"))
>>> list(get_block_words(test_string))
[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]]
>>> list(get_block_words(test_string * 4)) == [list(range(16))] * 4
True
>>> list(get_block_words(b"1" * 512)) == [[4294967295] * 16]
True
>>> list(get_block_words(b""))
[]
>>> list(get_block_words(b"1111"))
Traceback (most recent call last):
...
ValueError: Input must have length that's a multiple of 512
 - Function 'not_32' takes 1 arguments: i.  Docstring: Perform bitwise NOT on given int.

Arguments:
    i {[int]} -- [given int]

Raises:
    ValueError -- [input is negative]

Returns:
    Result of bitwise NOT on i

>>> not_32(34)
4294967261
>>> not_32(1234)
4294966061
>>> not_32(4294966061)
1234
>>> not_32(0)
4294967295
>>> not_32(1)
4294967294
>>> not_32(-1)
Traceback (most recent call last):
...
ValueError: Input must be non-negative
 - Function 'sum_32' takes 2 arguments: a, b.  Docstring: Add two numbers as 32-bit ints.

Arguments:
    a {[int]} -- [first given int]
    b {[int]} -- [second given int]

Returns:
    (a + b) as an unsigned 32-bit int

>>> sum_32(1, 1)
2
>>> sum_32(2, 3)
5
>>> sum_32(0, 0)
0
>>> sum_32(-1, -1)
4294967294
>>> sum_32(4294967295, 1)
0
 - Function 'left_rotate_32' takes 2 arguments: i, shift.  Docstring: Rotate the bits of a given int left by a given amount.

Arguments:
    i {[int]} -- [given int]
    shift {[int]} -- [shift amount]

Raises:
    ValueError -- [either given int or shift is negative]

Returns:
    `i` rotated to the left by `shift` bits

>>> left_rotate_32(1234, 1)
2468
>>> left_rotate_32(1111, 4)
17776
>>> left_rotate_32(2147483648, 1)
1
>>> left_rotate_32(2147483648, 3)
4
>>> left_rotate_32(4294967295, 4)
4294967295
>>> left_rotate_32(1234, 0)
1234
>>> left_rotate_32(0, 0)
0
>>> left_rotate_32(-1, 0)
Traceback (most recent call last):
...
ValueError: Input must be non-negative
>>> left_rotate_32(0, -1)
Traceback (most recent call last):
...
ValueError: Shift must be non-negative
 - Function 'md5_me' takes 1 arguments: message.  Docstring: Returns the 32-char MD5 hash of a given message.

Reference: https://en.wikipedia.org/wiki/MD5#Algorithm

Arguments:
    message {[string]} -- [message]

Returns:
    32-char MD5 hash string

>>> md5_me(b"")
b'd41d8cd98f00b204e9800998ecf8427e'
>>> md5_me(b"The quick brown fox jumps over the lazy dog")
b'9e107d9d372bb6826bd81d3542a419d6'
>>> md5_me(b"The quick brown fox jumps over the lazy dog.")
b'e4d909c290d0fb1ca068ffaddf22cbd0'

>>> import hashlib
>>> from string import ascii_letters
>>> msgs = [b"", ascii_letters.encode("utf-8"), "".encode("utf-8"),
...         b"The quick brown fox jumps over the lazy dog."]
>>> all(md5_me(msg) == hashlib.md5(msg).hexdigest().encode("utf-8") for msg in msgs)
True

File: sdbm.py
 - Function 'sdbm' takes 1 arguments: plain_text.  Docstring: Function implements sdbm hash, easy to use, great for bits scrambling.
iterates over each character in the given string and applies function to each of
them.

>>> sdbm('Algorithms')
1462174910723540325254304520539387479031000036

>>> sdbm('scramble bits')
730247649148944819640658295400555317318720608290373040936089

File: sha1.py
 - Function '__init__' takes 2 arguments: self, data.  Docstring: Initiates the variables data and h. h is a list of 5 8-digit hexadecimal
numbers corresponding to
(1732584193, 4023233417, 2562383102, 271733878, 3285377520)
respectively. We will start with this as a message digest. 0x is how you write
hexadecimal numbers in Python
 - Function 'rotate' takes 2 arguments: n, b.  Docstring: Static method to be used inside other methods. Left rotates n by b.
>>> SHA1Hash('').rotate(12,2)
48
 - Function 'padding' takes 1 arguments: self.  Docstring: Pads the input message with zeros so that padded_data has 64 bytes or 512 bits
 - Function 'split_blocks' takes 1 arguments: self.  Docstring: Returns a list of bytestrings each of length 64
 - Function 'expand_block' takes 2 arguments: self, block.  Docstring: Takes a bytestring-block of length 64, unpacks it to a list of integers and
returns a list of 80 integers after some bit operations
 - Function 'final_hash' takes 1 arguments: self.  Docstring: Calls all the other methods to process the input. Pads the data, then splits
into blocks and then does a series of operations for each block (including
expansion).
For each block, the variable h that was initialized is copied to a,b,c,d,e
and these 5 variables a,b,c,d,e undergo several changes. After all the blocks
are processed, these 5 variables are pairwise added to h ie a to h[0], b to h[1]
and so on. This h becomes our final hash which is returned.
 - Function 'test_sha1_hash' takes 0 arguments: .  No docstring available.
 - Function 'main' takes 0 arguments: .  Docstring: Provides option 'string' or 'file' to take input and prints the calculated SHA1
hash. unittest.main() has been commented out because we probably don't want to run
the test each time.

File: sha256.py
 - Function '__init__' takes 2 arguments: self, data.  No docstring available.
 - Function 'preprocessing' takes 1 arguments: data.  No docstring available.
 - Function 'final_hash' takes 1 arguments: self.  No docstring available.
 - Function 'ror' takes 3 arguments: self, value, rotations.  Docstring: Right rotate a given unsigned number by a certain amount of rotations
 - Function 'test_match_hashes' takes 1 arguments: self.  No docstring available.
 - Function 'main' takes 0 arguments: .  Docstring: Provides option 'string' or 'file' to take input
and prints the calculated SHA-256 hash

File: greedy_knapsack.py
 - Function 'calc_profit' takes 3 arguments: profit, weight, max_weight.  Docstring: Function description is as follows-
:param profit: Take a list of profits
:param weight: Take a list of weight if bags corresponding to the profits
:param max_weight: Maximum weight that could be carried
:return: Maximum expected gain

>>> calc_profit([1, 2, 3], [3, 4, 5], 15)
6
>>> calc_profit([10, 9 , 8], [3 ,4 , 5], 25)
27

File: recursive_approach_knapsack.py
 - Function 'knapsack' takes 5 arguments: weights, values, number_of_items, max_weight, index.  Docstring: Function description is as follows-
:param weights: Take a list of weights
:param values: Take a list of profits corresponding to the weights
:param number_of_items: number of items available to pick from
:param max_weight: Maximum weight that could be carried
:param index: the element we are looking at
:return: Maximum expected gain
>>> knapsack([1, 2, 4, 5], [5, 4, 8, 6], 4, 5, 0)
13
>>> knapsack([3 ,4 , 5], [10, 9 , 8], 3, 25, 0)
27

File: test_greedy_knapsack.py
 - Function 'test_sorted' takes 1 arguments: self.  Docstring: kp.calc_profit takes the required argument (profit, weight, max_weight)
and returns whether the answer matches to the expected ones
 - Function 'test_negative_max_weight' takes 1 arguments: self.  Docstring: Returns ValueError for any negative max_weight value
:return: ValueError
 - Function 'test_negative_profit_value' takes 1 arguments: self.  Docstring: Returns ValueError for any negative profit value in the list
:return: ValueError
 - Function 'test_negative_weight_value' takes 1 arguments: self.  Docstring: Returns ValueError for any negative weight value in the list
:return: ValueError
 - Function 'test_null_max_weight' takes 1 arguments: self.  Docstring: Returns ValueError for any zero max_weight value
:return: ValueError
 - Function 'test_unequal_list_length' takes 1 arguments: self.  Docstring: Returns IndexError if length of lists (profit and weight) are unequal.
:return: IndexError

File: test_knapsack.py
 - Function 'test_base_case' takes 1 arguments: self.  Docstring: test for the base case
 - Function 'test_easy_case' takes 1 arguments: self.  Docstring: test for the base case
 - Function 'test_knapsack' takes 1 arguments: self.  Docstring: test for the knapsack

File: gaussian_elimination.py
 - Function 'retroactive_resolution' takes 2 arguments: coefficients, vector.  Docstring: This function performs a retroactive linear system resolution
    for triangular matrix

Examples:
    2x1 + 2x2 - 1x3 = 5         2x1 + 2x2 = -1
    0x1 - 2x2 - 1x3 = -7        0x1 - 2x2 = -1
    0x1 + 0x2 + 5x3 = 15
>>> gaussian_elimination([[2, 2, -1], [0, -2, -1], [0, 0, 5]], [[5], [-7], [15]])
array([[2.],
       [2.],
       [3.]])
>>> gaussian_elimination([[2, 2], [0, -2]], [[-1], [-1]])
array([[-1. ],
       [ 0.5]])
 - Function 'gaussian_elimination' takes 2 arguments: coefficients, vector.  Docstring: This function performs Gaussian elimination method

Examples:
    1x1 - 4x2 - 2x3 = -2        1x1 + 2x2 = 5
    5x1 + 2x2 - 2x3 = -3        5x1 + 2x2 = 5
    1x1 - 1x2 + 0x3 = 4
>>> gaussian_elimination([[1, -4, -2], [5, 2, -2], [1, -1, 0]], [[-2], [-3], [4]])
array([[ 2.3 ],
       [-1.7 ],
       [ 5.55]])
>>> gaussian_elimination([[1, 2], [5, 2]], [[5], [5]])
array([[0. ],
       [2.5]])

File: jacobi_iteration_method.py
 - Function 'jacobi_iteration_method' takes 4 arguments: coefficient_matrix, constant_matrix, init_val, iterations.  Docstring: Jacobi Iteration Method:
An iterative algorithm to determine the solutions of strictly diagonally dominant
system of linear equations

4x1 +  x2 +  x3 =  2
 x1 + 5x2 + 2x3 = -6
 x1 + 2x2 + 4x3 = -4

x_init = [0.5, -0.5 , -0.5]

Examples:

>>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])
>>> constant = np.array([[2], [-6], [-4]])
>>> init_val = [0.5, -0.5, -0.5]
>>> iterations = 3
>>> jacobi_iteration_method(coefficient, constant, init_val, iterations)
[0.909375, -1.14375, -0.7484375]


>>> coefficient = np.array([[4, 1, 1], [1, 5, 2]])
>>> constant = np.array([[2], [-6], [-4]])
>>> init_val = [0.5, -0.5, -0.5]
>>> iterations = 3
>>> jacobi_iteration_method(coefficient, constant, init_val, iterations)
Traceback (most recent call last):
    ...
ValueError: Coefficient matrix dimensions must be nxn but received 2x3

>>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])
>>> constant = np.array([[2], [-6]])
>>> init_val = [0.5, -0.5, -0.5]
>>> iterations = 3
>>> jacobi_iteration_method(
...     coefficient, constant, init_val, iterations
... )  # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
    ...
ValueError: Coefficient and constant matrices dimensions must be nxn and nx1 but
            received 3x3 and 2x1

>>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])
>>> constant = np.array([[2], [-6], [-4]])
>>> init_val = [0.5, -0.5]
>>> iterations = 3
>>> jacobi_iteration_method(
...     coefficient, constant, init_val, iterations
... )  # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
    ...
ValueError: Number of initial values must be equal to number of rows in coefficient
            matrix but received 2 and 3

>>> coefficient = np.array([[4, 1, 1], [1, 5, 2], [1, 2, 4]])
>>> constant = np.array([[2], [-6], [-4]])
>>> init_val = [0.5, -0.5, -0.5]
>>> iterations = 0
>>> jacobi_iteration_method(coefficient, constant, init_val, iterations)
Traceback (most recent call last):
    ...
ValueError: Iterations must be at least 1
 - Function 'strictly_diagonally_dominant' takes 1 arguments: table.  Docstring: >>> table = np.array([[4, 1, 1, 2], [1, 5, 2, -6], [1, 2, 4, -4]])
>>> strictly_diagonally_dominant(table)
True

>>> table = np.array([[4, 1, 1, 2], [1, 5, 2, -6], [1, 2, 3, -4]])
>>> strictly_diagonally_dominant(table)
Traceback (most recent call last):
    ...
ValueError: Coefficient matrix is not strictly diagonally dominant

File: lu_decomposition.py
 - Function 'lower_upper_decomposition' takes 1 arguments: table.  Docstring: Perform LU decomposition on a given matrix and raises an error if the matrix
isn't square or if no such decomposition exists
>>> matrix = np.array([[2, -2, 1], [0, 1, 2], [5, 3, 1]])
>>> lower_mat, upper_mat = lower_upper_decomposition(matrix)
>>> lower_mat
array([[1. , 0. , 0. ],
       [0. , 1. , 0. ],
       [2.5, 8. , 1. ]])
>>> upper_mat
array([[  2. ,  -2. ,   1. ],
       [  0. ,   1. ,   2. ],
       [  0. ,   0. , -17.5]])

>>> matrix = np.array([[4, 3], [6, 3]])
>>> lower_mat, upper_mat = lower_upper_decomposition(matrix)
>>> lower_mat
array([[1. , 0. ],
       [1.5, 1. ]])
>>> upper_mat
array([[ 4. ,  3. ],
       [ 0. , -1.5]])

# Matrix is not square
>>> matrix = np.array([[2, -2, 1], [0, 1, 2]])
>>> lower_mat, upper_mat = lower_upper_decomposition(matrix)
Traceback (most recent call last):
    ...
ValueError: 'table' has to be of square shaped array but got a 2x3 array:
[[ 2 -2  1]
 [ 0  1  2]]

# Matrix is invertible, but its first leading principal minor is 0
>>> matrix = np.array([[0, 1], [1, 0]])
>>> lower_mat, upper_mat = lower_upper_decomposition(matrix)
Traceback (most recent call last):
...
ArithmeticError: No LU decomposition exists

# Matrix is singular, but its first leading principal minor is 1
>>> matrix = np.array([[1, 0], [1, 0]])
>>> lower_mat, upper_mat = lower_upper_decomposition(matrix)
>>> lower_mat
array([[1., 0.],
       [1., 1.]])
>>> upper_mat
array([[1., 0.],
       [0., 0.]])

# Matrix is singular, but its first leading principal minor is 0
>>> matrix = np.array([[0, 1], [0, 1]])
>>> lower_mat, upper_mat = lower_upper_decomposition(matrix)
Traceback (most recent call last):
...
ArithmeticError: No LU decomposition exists

File: conjugate_gradient.py
 - Function '_is_matrix_spd' takes 1 arguments: matrix.  Docstring: Returns True if input matrix is symmetric positive definite.
Returns False otherwise.

For a matrix to be SPD, all eigenvalues must be positive.

>>> import numpy as np
>>> matrix = np.array([
... [4.12401784, -5.01453636, -0.63865857],
... [-5.01453636, 12.33347422, -3.40493586],
... [-0.63865857, -3.40493586,  5.78591885]])
>>> _is_matrix_spd(matrix)
True
>>> matrix = np.array([
... [0.34634879,  1.96165514,  2.18277744],
... [0.74074469, -1.19648894, -1.34223498],
... [-0.7687067 ,  0.06018373, -1.16315631]])
>>> _is_matrix_spd(matrix)
False
 - Function '_create_spd_matrix' takes 1 arguments: dimension.  Docstring: Returns a symmetric positive definite matrix given a dimension.

Input:
dimension gives the square matrix dimension.

Output:
spd_matrix is an diminesion x dimensions symmetric positive definite (SPD) matrix.

>>> import numpy as np
>>> dimension = 3
>>> spd_matrix = _create_spd_matrix(dimension)
>>> _is_matrix_spd(spd_matrix)
True
 - Function 'conjugate_gradient' takes 4 arguments: spd_matrix, load_vector, max_iterations, tol.  Docstring: Returns solution to the linear system np.dot(spd_matrix, x) = b.

Input:
spd_matrix is an NxN Symmetric Positive Definite (SPD) matrix.
load_vector is an Nx1 vector.

Output:
x is an Nx1 vector that is the solution vector.

>>> import numpy as np
>>> spd_matrix = np.array([
... [8.73256573, -5.02034289, -2.68709226],
... [-5.02034289,  3.78188322,  0.91980451],
... [-2.68709226,  0.91980451,  1.94746467]])
>>> b = np.array([
... [-5.80872761],
... [ 3.23807431],
... [ 1.95381422]])
>>> conjugate_gradient(spd_matrix, b)
array([[-0.63114139],
       [-0.01561498],
       [ 0.13979294]])
 - Function 'test_conjugate_gradient' takes 0 arguments: .  Docstring: >>> test_conjugate_gradient()  # self running tests

File: gaussian_elimination_pivoting.py
 - Function 'solve_linear_system' takes 1 arguments: matrix.  Docstring: Solve a linear system of equations using Gaussian elimination with partial pivoting

Args:
- matrix: Coefficient matrix with the last column representing the constants.

Returns:
- Solution vector.

Raises:
- ValueError: If the matrix is not correct (i.e., singular).

https://courses.engr.illinois.edu/cs357/su2013/lect.htm Lecture 7

Example:
>>> A = np.array([[2, 1, -1], [-3, -1, 2], [-2, 1, 2]], dtype=float)
>>> B = np.array([8, -11, -3], dtype=float)
>>> solution = solve_linear_system(np.column_stack((A, B)))
>>> np.allclose(solution, np.array([2., 3., -1.]))
True
>>> solve_linear_system(np.array([[0, 0], [0, 0]],  dtype=float))
array([nan, nan])

File: lib.py
 - Function '__init__' takes 2 arguments: self, components.  Docstring: input: components or nothing
simple constructor for init the vector
 - Function '__len__' takes 1 arguments: self.  Docstring: returns the size of the vector
 - Function '__str__' takes 1 arguments: self.  Docstring: returns a string representation of the vector
 - Function '__add__' takes 2 arguments: self, other.  Docstring: input: other vector
assumes: other vector has the same size
returns a new vector that represents the sum.
 - Function '__sub__' takes 2 arguments: self, other.  Docstring: input: other vector
assumes: other vector has the same size
returns a new vector that represents the difference.
 - Function '__mul__' takes 2 arguments: self, other.  No docstring available.
 - Function '__mul__' takes 2 arguments: self, other.  No docstring available.
 - Function '__mul__' takes 2 arguments: self, other.  Docstring: mul implements the scalar multiplication
and the dot-product
 - Function 'copy' takes 1 arguments: self.  Docstring: copies this vector and returns it.
 - Function 'component' takes 2 arguments: self, i.  Docstring: input: index (0-indexed)
output: the i-th component of the vector.
 - Function 'change_component' takes 3 arguments: self, pos, value.  Docstring: input: an index (pos) and a value
changes the specified component (pos) with the
'value'
 - Function 'euclidean_length' takes 1 arguments: self.  Docstring: returns the euclidean length of the vector

>>> Vector([2, 3, 4]).euclidean_length()
5.385164807134504
>>> Vector([1]).euclidean_length()
1.0
>>> Vector([0, -1, -2, -3, 4, 5, 6]).euclidean_length()
9.539392014169456
>>> Vector([]).euclidean_length()
Traceback (most recent call last):
    ...
Exception: Vector is empty
 - Function 'angle' takes 3 arguments: self, other, deg.  Docstring: find angle between two Vector (self, Vector)

>>> Vector([3, 4, -1]).angle(Vector([2, -1, 1]))
1.4906464636572374
>>> Vector([3, 4, -1]).angle(Vector([2, -1, 1]), deg = True)
85.40775111366095
>>> Vector([3, 4, -1]).angle(Vector([2, -1]))
Traceback (most recent call last):
    ...
Exception: invalid operand!
 - Function 'zero_vector' takes 1 arguments: dimension.  Docstring: returns a zero-vector of size 'dimension'
 - Function 'unit_basis_vector' takes 2 arguments: dimension, pos.  Docstring: returns a unit basis vector with a One
at index 'pos' (indexing at 0)
 - Function 'axpy' takes 3 arguments: scalar, x, y.  Docstring: input: a 'scalar' and two vectors 'x' and 'y'
output: a vector
computes the axpy operation
 - Function 'random_vector' takes 3 arguments: n, a, b.  Docstring: input: size (N) of the vector.
       random range (a,b)
output: returns a random vector of size N, with
        random integer components between 'a' and 'b'.
 - Function '__init__' takes 4 arguments: self, matrix, w, h.  Docstring: simple constructor for initializing the matrix with components.
 - Function '__str__' takes 1 arguments: self.  Docstring: returns a string representation of this matrix.
 - Function '__add__' takes 2 arguments: self, other.  Docstring: implements matrix addition.
 - Function '__sub__' takes 2 arguments: self, other.  Docstring: implements matrix subtraction.
 - Function '__mul__' takes 2 arguments: self, other.  No docstring available.
 - Function '__mul__' takes 2 arguments: self, other.  No docstring available.
 - Function '__mul__' takes 2 arguments: self, other.  Docstring: implements the matrix-vector multiplication.
implements the matrix-scalar multiplication
 - Function 'height' takes 1 arguments: self.  Docstring: getter for the height
 - Function 'width' takes 1 arguments: self.  Docstring: getter for the width
 - Function 'component' takes 3 arguments: self, x, y.  Docstring: returns the specified (x,y) component
 - Function 'change_component' takes 4 arguments: self, x, y, value.  Docstring: changes the x-y component of this matrix
 - Function 'minor' takes 3 arguments: self, x, y.  Docstring: returns the minor along (x, y)
 - Function 'cofactor' takes 3 arguments: self, x, y.  Docstring: returns the cofactor (signed minor) along (x, y)
 - Function 'determinant' takes 1 arguments: self.  Docstring: returns the determinant of an nxn matrix using Laplace expansion
 - Function 'square_zero_matrix' takes 1 arguments: n.  Docstring: returns a square zero-matrix of dimension NxN
 - Function 'random_matrix' takes 4 arguments: width, height, a, b.  Docstring: returns a random matrix WxH with integer components
between 'a' and 'b'

File: polynom_for_points.py
 - Function 'points_to_polynomial' takes 1 arguments: coordinates.  Docstring: coordinates is a two dimensional matrix: [[x, y], [x, y], ...]
number of points you want to use

>>> print(points_to_polynomial([]))
Traceback (most recent call last):
    ...
ValueError: The program cannot work out a fitting polynomial.
>>> print(points_to_polynomial([[]]))
Traceback (most recent call last):
    ...
ValueError: The program cannot work out a fitting polynomial.
>>> print(points_to_polynomial([[1, 0], [2, 0], [3, 0]]))
f(x)=x^2*0.0+x^1*-0.0+x^0*0.0
>>> print(points_to_polynomial([[1, 1], [2, 1], [3, 1]]))
f(x)=x^2*0.0+x^1*-0.0+x^0*1.0
>>> print(points_to_polynomial([[1, 3], [2, 3], [3, 3]]))
f(x)=x^2*0.0+x^1*-0.0+x^0*3.0
>>> print(points_to_polynomial([[1, 1], [2, 2], [3, 3]]))
f(x)=x^2*0.0+x^1*1.0+x^0*0.0
>>> print(points_to_polynomial([[1, 1], [2, 4], [3, 9]]))
f(x)=x^2*1.0+x^1*-0.0+x^0*0.0
>>> print(points_to_polynomial([[1, 3], [2, 6], [3, 11]]))
f(x)=x^2*1.0+x^1*-0.0+x^0*2.0
>>> print(points_to_polynomial([[1, -3], [2, -6], [3, -11]]))
f(x)=x^2*-1.0+x^1*-0.0+x^0*-2.0
>>> print(points_to_polynomial([[1, 5], [2, 2], [3, 9]]))
f(x)=x^2*5.0+x^1*-18.0+x^0*18.0

File: power_iteration.py
 - Function 'power_iteration' takes 4 arguments: input_matrix, vector, error_tol, max_iterations.  Docstring: Power Iteration.
Find the largest eigenvalue and corresponding eigenvector
of matrix input_matrix given a random vector in the same space.
Will work so long as vector has component of largest eigenvector.
input_matrix must be either real or Hermitian.

Input
input_matrix: input matrix whose largest eigenvalue we will find.
Numpy array. np.shape(input_matrix) == (N,N).
vector: random initial vector in same space as matrix.
Numpy array. np.shape(vector) == (N,) or (N,1)

Output
largest_eigenvalue: largest eigenvalue of the matrix input_matrix.
Float. Scalar.
largest_eigenvector: eigenvector corresponding to largest_eigenvalue.
Numpy array. np.shape(largest_eigenvector) == (N,) or (N,1).

>>> import numpy as np
>>> input_matrix = np.array([
... [41,  4, 20],
... [ 4, 26, 30],
... [20, 30, 50]
... ])
>>> vector = np.array([41,4,20])
>>> power_iteration(input_matrix,vector)
(79.66086378788381, array([0.44472726, 0.46209842, 0.76725662]))
 - Function 'test_power_iteration' takes 0 arguments: .  Docstring: >>> test_power_iteration()  # self running tests

File: rank_of_matrix.py
 - Function 'rank_of_matrix' takes 1 arguments: matrix.  Docstring: Finds the rank of a matrix.
Args:
    matrix: The matrix as a list of lists.
Returns:
    The rank of the matrix.
Example:
>>> matrix1 = [[1, 2, 3],
...            [4, 5, 6],
...            [7, 8, 9]]
>>> rank_of_matrix(matrix1)
2
>>> matrix2 = [[1, 0, 0],
...            [0, 1, 0],
...            [0, 0, 0]]
>>> rank_of_matrix(matrix2)
2
>>> matrix3 = [[1, 2, 3, 4],
...            [5, 6, 7, 8],
...            [9, 10, 11, 12]]
>>> rank_of_matrix(matrix3)
2
>>> rank_of_matrix([[2,3,-1,-1],
...                [1,-1,-2,4],
...                [3,1,3,-2],
...                [6,3,0,-7]])
4
>>> rank_of_matrix([[2,1,-3,-6],
...                [3,-3,1,2],
...                [1,1,1,2]])
3
>>> rank_of_matrix([[2,-1,0],
...                [1,3,4],
...                [4,1,-3]])
3
>>> rank_of_matrix([[3,2,1],
...                [-6,-4,-2]])
1
>>> rank_of_matrix([[],[]])
0
>>> rank_of_matrix([[1]])
1
>>> rank_of_matrix([[]])
0

File: rayleigh_quotient.py
 - Function 'is_hermitian' takes 1 arguments: matrix.  Docstring: Checks if a matrix is Hermitian.
>>> import numpy as np
>>> A = np.array([
... [2,    2+1j, 4],
... [2-1j,  3,  1j],
... [4,    -1j,  1]])
>>> is_hermitian(A)
True
>>> A = np.array([
... [2,    2+1j, 4+1j],
... [2-1j,  3,  1j],
... [4,    -1j,  1]])
>>> is_hermitian(A)
False
 - Function 'rayleigh_quotient' takes 2 arguments: a, v.  Docstring: Returns the Rayleigh quotient of a Hermitian matrix A and
vector v.
>>> import numpy as np
>>> A = np.array([
... [1,  2, 4],
... [2,  3,  -1],
... [4, -1,  1]
... ])
>>> v = np.array([
... [1],
... [2],
... [3]
... ])
>>> rayleigh_quotient(A, v)
array([[3.]])
 - Function 'tests' takes 0 arguments: .  No docstring available.

File: schur_complement.py
 - Function 'schur_complement' takes 4 arguments: mat_a, mat_b, mat_c, pseudo_inv.  Docstring: Schur complement of a symmetric matrix X given as a 2x2 block matrix
consisting of matrices A, B and C.
Matrix A must be quadratic and non-singular.
In case A is singular, a pseudo-inverse may be provided using
the pseudo_inv argument.

Link to Wiki: https://en.wikipedia.org/wiki/Schur_complement
See also Convex Optimization - Boyd and Vandenberghe, A.5.5
>>> import numpy as np
>>> a = np.array([[1, 2], [2, 1]])
>>> b = np.array([[0, 3], [3, 0]])
>>> c = np.array([[2, 1], [6, 3]])
>>> schur_complement(a, b, c)
array([[ 5., -5.],
       [ 0.,  6.]])
 - Function 'test_schur_complement' takes 1 arguments: self.  No docstring available.
 - Function 'test_improper_a_b_dimensions' takes 1 arguments: self.  No docstring available.
 - Function 'test_improper_b_c_dimensions' takes 1 arguments: self.  No docstring available.

File: test_linear_algebra.py
 - Function 'test_component' takes 1 arguments: self.  Docstring: test for method component()
 - Function 'test_str' takes 1 arguments: self.  Docstring: test for method toString()
 - Function 'test_size' takes 1 arguments: self.  Docstring: test for method size()
 - Function 'test_euclidean_length' takes 1 arguments: self.  Docstring: test for method euclidean_length()
 - Function 'test_add' takes 1 arguments: self.  Docstring: test for + operator
 - Function 'test_sub' takes 1 arguments: self.  Docstring: test for - operator
 - Function 'test_mul' takes 1 arguments: self.  Docstring: test for * operator
 - Function 'test_zero_vector' takes 1 arguments: self.  Docstring: test for global function zero_vector()
 - Function 'test_unit_basis_vector' takes 1 arguments: self.  Docstring: test for global function unit_basis_vector()
 - Function 'test_axpy' takes 1 arguments: self.  Docstring: test for global function axpy() (operation)
 - Function 'test_copy' takes 1 arguments: self.  Docstring: test for method copy()
 - Function 'test_change_component' takes 1 arguments: self.  Docstring: test for method change_component()
 - Function 'test_str_matrix' takes 1 arguments: self.  Docstring: test for Matrix method str()
 - Function 'test_minor' takes 1 arguments: self.  Docstring: test for Matrix method minor()
 - Function 'test_cofactor' takes 1 arguments: self.  Docstring: test for Matrix method cofactor()
 - Function 'test_determinant' takes 1 arguments: self.  Docstring: test for Matrix method determinant()
 - Function 'test__mul__matrix' takes 1 arguments: self.  Docstring: test for Matrix * operator
 - Function 'test_change_component_matrix' takes 1 arguments: self.  Docstring: test for Matrix method change_component()
 - Function 'test_component_matrix' takes 1 arguments: self.  Docstring: test for Matrix method component()
 - Function 'test__add__matrix' takes 1 arguments: self.  Docstring: test for Matrix + operator
 - Function 'test__sub__matrix' takes 1 arguments: self.  Docstring: test for Matrix - operator
 - Function 'test_square_zero_matrix' takes 1 arguments: self.  Docstring: test for global function square_zero_matrix()

File: transformations_2d.py
 - Function 'scaling' takes 1 arguments: scaling_factor.  Docstring: >>> scaling(5)
[[5.0, 0.0], [0.0, 5.0]]
 - Function 'rotation' takes 1 arguments: angle.  Docstring: >>> rotation(45)  # doctest: +NORMALIZE_WHITESPACE
[[0.5253219888177297, -0.8509035245341184],
 [0.8509035245341184, 0.5253219888177297]]
 - Function 'projection' takes 1 arguments: angle.  Docstring: >>> projection(45)  # doctest: +NORMALIZE_WHITESPACE
[[0.27596319193541496, 0.446998331800279],
 [0.446998331800279, 0.7240368080645851]]
 - Function 'reflection' takes 1 arguments: angle.  Docstring: >>> reflection(45)  # doctest: +NORMALIZE_WHITESPACE
[[0.05064397763545947, 0.893996663600558],
 [0.893996663600558, 0.7018070490682369]]

File: simplex.py
 - Function '__init__' takes 4 arguments: self, tableau, n_vars, n_artificial_vars.  No docstring available.
 - Function 'generate_col_titles' takes 1 arguments: self.  Docstring: Generate column titles for tableau of specific dimensions

>>> Tableau(np.array([[-1,-1,0,0,1],[1,3,1,0,4],[3,1,0,1,4.]]),
... 2, 0).generate_col_titles()
['x1', 'x2', 's1', 's2', 'RHS']

>>> Tableau(np.array([[-1,-1,0,0,1],[1,3,1,0,4],[3,1,0,1,4.]]),
... 2, 2).generate_col_titles()
['x1', 'x2', 'RHS']
 - Function 'find_pivot' takes 1 arguments: self.  Docstring: Finds the pivot row and column.
>>> Tableau(np.array([[-2,1,0,0,0], [3,1,1,0,6], [1,2,0,1,7.]]),
... 2, 0).find_pivot()
(1, 0)
 - Function 'pivot' takes 3 arguments: self, row_idx, col_idx.  Docstring: Pivots on value on the intersection of pivot row and column.

>>> Tableau(np.array([[-2,-3,0,0,0],[1,3,1,0,4],[3,1,0,1,4.]]),
... 2, 2).pivot(1, 0).tolist()
... # doctest: +NORMALIZE_WHITESPACE
[[0.0, 3.0, 2.0, 0.0, 8.0],
[1.0, 3.0, 1.0, 0.0, 4.0],
[0.0, -8.0, -3.0, 1.0, -8.0]]
 - Function 'change_stage' takes 1 arguments: self.  Docstring: Exits first phase of the two-stage method by deleting artificial
rows and columns, or completes the algorithm if exiting the standard
case.

>>> Tableau(np.array([
... [3, 3, -1, -1, 0, 0, 4],
... [2, 1, 0, 0, 0, 0, 0.],
... [1, 2, -1, 0, 1, 0, 2],
... [2, 1, 0, -1, 0, 1, 2]
... ]), 2, 2).change_stage().tolist()
... # doctest: +NORMALIZE_WHITESPACE
[[2.0, 1.0, 0.0, 0.0, 0.0],
[1.0, 2.0, -1.0, 0.0, 2.0],
[2.0, 1.0, 0.0, -1.0, 2.0]]
 - Function 'run_simplex' takes 1 arguments: self.  Docstring: Operate on tableau until objective function cannot be
improved further.

# Standard linear program:
Max:  x1 +  x2
ST:   x1 + 3x2 <= 4
     3x1 +  x2 <= 4
>>> Tableau(np.array([[-1,-1,0,0,0],[1,3,1,0,4],[3,1,0,1,4.]]),
... 2, 0).run_simplex()
{'P': 2.0, 'x1': 1.0, 'x2': 1.0}

# Standard linear program with 3 variables:
Max: 3x1 +  x2 + 3x3
ST:  2x1 +  x2 +  x3  2
      x1 + 2x2 + 3x3  5
     2x1 + 2x2 +  x3  6
>>> Tableau(np.array([
... [-3,-1,-3,0,0,0,0],
... [2,1,1,1,0,0,2],
... [1,2,3,0,1,0,5],
... [2,2,1,0,0,1,6.]
... ]),3,0).run_simplex() # doctest: +ELLIPSIS
{'P': 5.4, 'x1': 0.199..., 'x3': 1.6}


# Optimal tableau input:
>>> Tableau(np.array([
... [0, 0, 0.25, 0.25, 2],
... [0, 1, 0.375, -0.125, 1],
... [1, 0, -0.125, 0.375, 1]
... ]), 2, 0).run_simplex()
{'P': 2.0, 'x1': 1.0, 'x2': 1.0}

# Non-standard: >= constraints
Max: 2x1 + 3x2 +  x3
ST:   x1 +  x2 +  x3 <= 40
     2x1 +  x2 -  x3 >= 10
         -  x2 +  x3 >= 10
>>> Tableau(np.array([
... [2, 0, 0, 0, -1, -1, 0, 0, 20],
... [-2, -3, -1, 0, 0, 0, 0, 0, 0],
... [1, 1, 1, 1, 0, 0, 0, 0, 40],
... [2, 1, -1, 0, -1, 0, 1, 0, 10],
... [0, -1, 1, 0, 0, -1, 0, 1, 10.]
... ]), 3, 2).run_simplex()
{'P': 70.0, 'x1': 10.0, 'x2': 10.0, 'x3': 20.0}

# Non standard: minimisation and equalities
Min: x1 +  x2
ST: 2x1 +  x2 = 12
    6x1 + 5x2 = 40
>>> Tableau(np.array([
... [8, 6, 0, 0, 52],
... [1, 1, 0, 0, 0],
... [2, 1, 1, 0, 12],
... [6, 5, 0, 1, 40.],
... ]), 2, 2).run_simplex()
{'P': 7.0, 'x1': 5.0, 'x2': 2.0}


# Pivot on slack variables
Max: 8x1 + 6x2
ST:   x1 + 3x2 <= 33
     4x1 + 2x2 <= 48
     2x1 + 4x2 <= 48
      x1 +  x2 >= 10
     x1        >= 2
>>> Tableau(np.array([
... [2, 1, 0, 0, 0, -1, -1, 0, 0, 12.0],
... [-8, -6, 0, 0, 0, 0, 0, 0, 0, 0.0],
... [1, 3, 1, 0, 0, 0, 0, 0, 0, 33.0],
... [4, 2, 0, 1, 0, 0, 0, 0, 0, 60.0],
... [2, 4, 0, 0, 1, 0, 0, 0, 0, 48.0],
... [1, 1, 0, 0, 0, -1, 0, 1, 0, 10.0],
... [1, 0, 0, 0, 0, 0, -1, 0, 1, 2.0]
... ]), 2, 2).run_simplex() # doctest: +ELLIPSIS
{'P': 132.0, 'x1': 12.000... 'x2': 5.999...}
 - Function 'interpret_tableau' takes 1 arguments: self.  Docstring: Given the final tableau, add the corresponding values of the basic
decision variables to the `output_dict`
>>> Tableau(np.array([
... [0,0,0.875,0.375,5],
... [0,1,0.375,-0.125,1],
... [1,0,-0.125,0.375,1]
... ]),2, 0).interpret_tableau()
{'P': 5.0, 'x1': 1.0, 'x2': 1.0}

File: apriori_algorithm.py
 - Function 'load_data' takes 0 arguments: .  Docstring: Returns a sample transaction dataset.

>>> load_data()
[['milk'], ['milk', 'butter'], ['milk', 'bread'], ['milk', 'bread', 'chips']]
 - Function 'prune' takes 3 arguments: itemset, candidates, length.  Docstring: Prune candidate itemsets that are not frequent.
The goal of pruning is to filter out candidate itemsets that are not frequent.  This
is done by checking if all the (k-1) subsets of a candidate itemset are present in
the frequent itemsets of the previous iteration (valid subsequences of the frequent
itemsets from the previous iteration).

Prunes candidate itemsets that are not frequent.

>>> itemset = ['X', 'Y', 'Z']
>>> candidates = [['X', 'Y'], ['X', 'Z'], ['Y', 'Z']]
>>> prune(itemset, candidates, 2)
[['X', 'Y'], ['X', 'Z'], ['Y', 'Z']]

>>> itemset = ['1', '2', '3', '4']
>>> candidates = ['1', '2', '4']
>>> prune(itemset, candidates, 3)
[]
 - Function 'apriori' takes 2 arguments: data, min_support.  Docstring: Returns a list of frequent itemsets and their support counts.

>>> data = [['A', 'B', 'C'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C']]
>>> apriori(data, 2)
[(['A', 'B'], 1), (['A', 'C'], 2), (['B', 'C'], 2)]

>>> data = [['1', '2', '3'], ['1', '2'], ['1', '3'], ['1', '4'], ['2', '3']]
>>> apriori(data, 3)
[]

File: astar.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__eq__' takes 2 arguments: self, cell.  No docstring available.
 - Function 'showcell' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 2 arguments: self, world_size.  No docstring available.
 - Function 'show' takes 1 arguments: self.  No docstring available.
 - Function 'get_neighbours' takes 2 arguments: self, cell.  Docstring: Return the neighbours of cell
 - Function 'astar' takes 3 arguments: world, start, goal.  Docstring: Implementation of a start algorithm.
world : Object of the world object.
start : Object of the cell as  start position.
stop  : Object of the cell as goal position.

>>> p = Gridworld()
>>> start = Cell()
>>> start.position = (0,0)
>>> goal = Cell()
>>> goal.position = (4,4)
>>> astar(p, start, goal)
[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]

File: automatic_differentiation.py
 - Function '__init__' takes 2 arguments: self, value.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function 'to_ndarray' takes 1 arguments: self.  No docstring available.
 - Function '__add__' takes 2 arguments: self, other.  No docstring available.
 - Function '__sub__' takes 2 arguments: self, other.  No docstring available.
 - Function '__mul__' takes 2 arguments: self, other.  No docstring available.
 - Function '__truediv__' takes 2 arguments: self, other.  No docstring available.
 - Function '__matmul__' takes 2 arguments: self, other.  No docstring available.
 - Function '__pow__' takes 2 arguments: self, power.  No docstring available.
 - Function 'add_param_to' takes 2 arguments: self, param_to.  No docstring available.
 - Function 'add_result_of' takes 2 arguments: self, result_of.  No docstring available.
 - Function '__init__' takes 3 arguments: self, op_type, other_params.  No docstring available.
 - Function 'add_params' takes 2 arguments: self, params.  No docstring available.
 - Function 'add_output' takes 2 arguments: self, output.  No docstring available.
 - Function '__eq__' takes 2 arguments: self, value.  No docstring available.
 - Function '__new__' takes 1 arguments: cls.  Docstring: Executes at the creation of class object and returns if
object is already created. This class follows singleton
design pattern.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__enter__' takes 1 arguments: self.  No docstring available.
 - Function '__exit__' takes 4 arguments: self, exc_type, exc, traceback.  No docstring available.
 - Function 'append' takes 5 arguments: self, op_type, params, output, other_params.  Docstring: Adds Operation object to the related Variable objects for
creating computational graph for calculating gradients.

Args:
    op_type: Operation type
    params: Input parameters to the operation
    output: Output variable of the operation
 - Function 'gradient' takes 3 arguments: self, target, source.  Docstring: Reverse accumulation of partial derivatives to calculate gradients
of target variable with respect to source variable.

Args:
    target: target variable for which gradients are calculated.
    source: source variable with respect to which the gradients are
    calculated.

Returns:
    Gradient of the source variable with respect to the target variable
 - Function 'derivative' takes 3 arguments: self, param, operation.  Docstring: Compute the derivative of given operation/function

Args:
    param: variable to be differentiated
    operation: function performed on the input variable

Returns:
    Derivative of input variable with respect to the output of
    the operation

File: data_transformations.py
 - Function 'normalization' takes 2 arguments: data, ndigits.  Docstring: Return a normalized list of values.

@params: data, a list of values to normalize
@returns: a list of normalized values (rounded to ndigits decimal places)
@examples:
>>> normalization([2, 7, 10, 20, 30, 50])
[0.0, 0.104, 0.167, 0.375, 0.583, 1.0]
>>> normalization([5, 10, 15, 20, 25])
[0.0, 0.25, 0.5, 0.75, 1.0]
 - Function 'standardization' takes 2 arguments: data, ndigits.  Docstring: Return a standardized list of values.

@params: data, a list of values to standardize
@returns: a list of standardized values (rounded to ndigits decimal places)
@examples:
>>> standardization([2, 7, 10, 20, 30, 50])
[-0.999, -0.719, -0.551, 0.009, 0.57, 1.69]
>>> standardization([5, 10, 15, 20, 25])
[-1.265, -0.632, 0.0, 0.632, 1.265]

File: decision_tree.py
 - Function '__init__' takes 3 arguments: self, depth, min_leaf_size.  No docstring available.
 - Function 'mean_squared_error' takes 3 arguments: self, labels, prediction.  Docstring: mean_squared_error:
@param labels: a one-dimensional numpy array
@param prediction: a floating point value
return value: mean_squared_error calculates the error if prediction is used to
    estimate the labels
>>> tester = DecisionTree()
>>> test_labels = np.array([1,2,3,4,5,6,7,8,9,10])
>>> test_prediction = float(6)
>>> tester.mean_squared_error(test_labels, test_prediction) == (
...     TestDecisionTree.helper_mean_squared_error_test(test_labels,
...         test_prediction))
True
>>> test_labels = np.array([1,2,3])
>>> test_prediction = float(2)
>>> tester.mean_squared_error(test_labels, test_prediction) == (
...     TestDecisionTree.helper_mean_squared_error_test(test_labels,
...         test_prediction))
True
 - Function 'train' takes 3 arguments: self, x, y.  Docstring: train:
@param x: a one-dimensional numpy array
@param y: a one-dimensional numpy array.
The contents of y are the labels for the corresponding X values

train() does not have a return value

Examples:
1. Try to train when x & y are of same length & 1 dimensions (No errors)
>>> dt = DecisionTree()
>>> dt.train(np.array([10,20,30,40,50]),np.array([0,0,0,1,1]))

2. Try to train when x is 2 dimensions
>>> dt = DecisionTree()
>>> dt.train(np.array([[1,2,3,4,5],[1,2,3,4,5]]),np.array([0,0,0,1,1]))
Traceback (most recent call last):
    ...
ValueError: Input data set must be one-dimensional

3. Try to train when x and y are not of the same length
>>> dt = DecisionTree()
>>> dt.train(np.array([1,2,3,4,5]),np.array([[0,0,0,1,1],[0,0,0,1,1]]))
Traceback (most recent call last):
    ...
ValueError: x and y have different lengths

4. Try to train when x & y are of the same length but different dimensions
>>> dt = DecisionTree()
>>> dt.train(np.array([1,2,3,4,5]),np.array([[1],[2],[3],[4],[5]]))
Traceback (most recent call last):
    ...
ValueError: Data set labels must be one-dimensional

This section is to check that the inputs conform to our dimensionality
constraints
 - Function 'predict' takes 2 arguments: self, x.  Docstring: predict:
@param x: a floating point value to predict the label of
the prediction function works by recursively calling the predict function
of the appropriate subtrees based on the tree's decision boundary
 - Function 'helper_mean_squared_error_test' takes 2 arguments: labels, prediction.  Docstring: helper_mean_squared_error_test:
@param labels: a one dimensional numpy array
@param prediction: a floating point value
return value: helper_mean_squared_error_test calculates the mean squared error
 - Function 'main' takes 0 arguments: .  Docstring: In this demonstration we're generating a sample data set from the sin function in
numpy.  We then train a decision tree on the data set and use the decision tree to
predict the label of 10 different test values. Then the mean squared error over
this test is displayed.

File: dimensionality_reduction.py
 - Function 'column_reshape' takes 1 arguments: input_array.  Docstring: Function to reshape a row Numpy array into a column Numpy array
>>> input_array = np.array([1, 2, 3])
>>> column_reshape(input_array)
array([[1],
       [2],
       [3]])
 - Function 'covariance_within_classes' takes 3 arguments: features, labels, classes.  Docstring: Function to compute the covariance matrix inside each class.
>>> features = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> labels = np.array([0, 1, 0])
>>> covariance_within_classes(features, labels, 2)
array([[0.66666667, 0.66666667, 0.66666667],
       [0.66666667, 0.66666667, 0.66666667],
       [0.66666667, 0.66666667, 0.66666667]])
 - Function 'covariance_between_classes' takes 3 arguments: features, labels, classes.  Docstring: Function to compute the covariance matrix between multiple classes
>>> features = np.array([[9, 2, 3], [4, 3, 6], [1, 8, 9]])
>>> labels = np.array([0, 1, 0])
>>> covariance_between_classes(features, labels, 2)
array([[ 3.55555556,  1.77777778, -2.66666667],
       [ 1.77777778,  0.88888889, -1.33333333],
       [-2.66666667, -1.33333333,  2.        ]])
 - Function 'principal_component_analysis' takes 2 arguments: features, dimensions.  Docstring: Principal Component Analysis.

For more details, see: https://en.wikipedia.org/wiki/Principal_component_analysis.
Parameters:
    * features: the features extracted from the dataset
    * dimensions: to filter the projected data for the desired dimension

>>> test_principal_component_analysis()
 - Function 'linear_discriminant_analysis' takes 4 arguments: features, labels, classes, dimensions.  Docstring: Linear Discriminant Analysis.

For more details, see: https://en.wikipedia.org/wiki/Linear_discriminant_analysis.
Parameters:
    * features: the features extracted from the dataset
    * labels: the class labels of the features
    * classes: the number of classes present in the dataset
    * dimensions: to filter the projected data for the desired dimension

>>> test_linear_discriminant_analysis()
 - Function 'test_linear_discriminant_analysis' takes 0 arguments: .  No docstring available.
 - Function 'test_principal_component_analysis' takes 0 arguments: .  No docstring available.

File: frequent_pattern_growth.py
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function 'inc' takes 2 arguments: self, num_occur.  No docstring available.
 - Function 'disp' takes 2 arguments: self, ind.  No docstring available.
 - Function 'create_tree' takes 2 arguments: data_set, min_sup.  Docstring: Create Frequent Pattern tree

Args:
    data_set: A list of transactions, where each transaction is a list of items.
    min_sup: The minimum support threshold.
    Items with support less than this will be pruned. Default is 1.

Returns:
    The root of the FP-Tree.
    header_table: The header table dictionary with item information.

Example:
>>> data_set = [
...    ['A', 'B', 'C'],
...    ['A', 'C'],
...    ['A', 'B', 'E'],
...    ['A', 'B', 'C', 'E'],
...    ['B', 'E']
... ]
>>> min_sup = 2
>>> fp_tree, header_table = create_tree(data_set, min_sup)
>>> fp_tree
TreeNode('Null Set', 1, None)
>>> len(header_table)
4
>>> header_table["A"]
[[4, None], TreeNode('A', 4, TreeNode('Null Set', 1, None))]
>>> header_table["E"][1]  # doctest: +NORMALIZE_WHITESPACE
TreeNode('E', 1, TreeNode('B', 3, TreeNode('A', 4, TreeNode('Null Set', 1, None))))
>>> sorted(header_table)
['A', 'B', 'C', 'E']
>>> fp_tree.name
'Null Set'
>>> sorted(fp_tree.children)
['A', 'B']
>>> fp_tree.children['A'].name
'A'
>>> sorted(fp_tree.children['A'].children)
['B', 'C']
 - Function 'update_tree' takes 4 arguments: items, in_tree, header_table, count.  Docstring: Update the FP-Tree with a transaction.

Args:
    items: List of items in the transaction.
    in_tree: The current node in the FP-Tree.
    header_table: The header table dictionary with item information.
    count: The count of the transaction.

Example:
>>> data_set = [
...    ['A', 'B', 'C'],
...    ['A', 'C'],
...    ['A', 'B', 'E'],
...    ['A', 'B', 'C', 'E'],
...    ['B', 'E']
... ]
>>> min_sup = 2
>>> fp_tree, header_table = create_tree(data_set, min_sup)
>>> fp_tree
TreeNode('Null Set', 1, None)
>>> transaction = ['A', 'B', 'E']
>>> update_tree(transaction, fp_tree, header_table, 1)
>>> fp_tree
TreeNode('Null Set', 1, None)
>>> fp_tree.children['A'].children['B'].children['E'].children
{}
>>> fp_tree.children['A'].children['B'].children['E'].count
2
>>> header_table['E'][1].name
'E'
 - Function 'update_header' takes 2 arguments: node_to_test, target_node.  Docstring: Update the header table with a node link.

Args:
    node_to_test: The node to be updated in the header table.
    target_node: The node to link to.

Example:
>>> data_set = [
...    ['A', 'B', 'C'],
...    ['A', 'C'],
...    ['A', 'B', 'E'],
...    ['A', 'B', 'C', 'E'],
...    ['B', 'E']
... ]
>>> min_sup = 2
>>> fp_tree, header_table = create_tree(data_set, min_sup)
>>> fp_tree
TreeNode('Null Set', 1, None)
>>> node1 = TreeNode("A", 3, None)
>>> node2 = TreeNode("B", 4, None)
>>> node1
TreeNode('A', 3, None)
>>> node1 = update_header(node1, node2)
>>> node1
TreeNode('A', 3, None)
>>> node1.node_link
TreeNode('B', 4, None)
>>> node2.node_link is None
True
 - Function 'ascend_tree' takes 2 arguments: leaf_node, prefix_path.  Docstring: Ascend the FP-Tree from a leaf node to its root, adding item names to the prefix
path.

Args:
    leaf_node: The leaf node to start ascending from.
    prefix_path: A list to store the item as they are ascended.

Example:
>>> data_set = [
...    ['A', 'B', 'C'],
...    ['A', 'C'],
...    ['A', 'B', 'E'],
...    ['A', 'B', 'C', 'E'],
...    ['B', 'E']
... ]
>>> min_sup = 2
>>> fp_tree, header_table = create_tree(data_set, min_sup)

>>> path = []
>>> ascend_tree(fp_tree.children['A'], path)
>>> path # ascending from a leaf node 'A'
['A']
 - Function 'find_prefix_path' takes 2 arguments: base_pat, tree_node.  Docstring: Find the conditional pattern base for a given base pattern.

Args:
    base_pat: The base pattern for which to find the conditional pattern base.
    tree_node: The node in the FP-Tree.

Example:
>>> data_set = [
...    ['A', 'B', 'C'],
...    ['A', 'C'],
...    ['A', 'B', 'E'],
...    ['A', 'B', 'C', 'E'],
...    ['B', 'E']
... ]
>>> min_sup = 2
>>> fp_tree, header_table = create_tree(data_set, min_sup)
>>> fp_tree
TreeNode('Null Set', 1, None)
>>> len(header_table)
4
>>> base_pattern = frozenset(['A'])
>>> sorted(find_prefix_path(base_pattern, fp_tree.children['A']))
[]
 - Function 'mine_tree' takes 5 arguments: in_tree, header_table, min_sup, pre_fix, freq_item_list.  Docstring: Mine the FP-Tree recursively to discover frequent itemsets.

Args:
    in_tree: The FP-Tree to mine.
    header_table: The header table dictionary with item information.
    min_sup: The minimum support threshold.
    pre_fix: A set of items as a prefix for the itemsets being mined.
    freq_item_list: A list to store the frequent itemsets.

Example:
>>> data_set = [
...    ['A', 'B', 'C'],
...    ['A', 'C'],
...    ['A', 'B', 'E'],
...    ['A', 'B', 'C', 'E'],
...    ['B', 'E']
... ]
>>> min_sup = 2
>>> fp_tree, header_table = create_tree(data_set, min_sup)
>>> fp_tree
TreeNode('Null Set', 1, None)
>>> frequent_itemsets = []
>>> mine_tree(fp_tree, header_table, min_sup, set([]), frequent_itemsets)
>>> expe_itm = [{'C'}, {'C', 'A'}, {'E'}, {'A', 'E'}, {'E', 'B'}, {'A'}, {'B'}]
>>> all(expected in frequent_itemsets for expected in expe_itm)
True

File: gradient_boosting_classifier.py
 - Function '__init__' takes 3 arguments: self, n_estimators, learning_rate.  Docstring: Initialize a GradientBoostingClassifier.

Parameters:
- n_estimators (int): The number of weak learners to train.
- learning_rate (float): The learning rate for updating the model.

Attributes:
- n_estimators (int): The number of weak learners.
- learning_rate (float): The learning rate.
- models (list): A list to store the trained weak learners.
 - Function 'fit' takes 3 arguments: self, features, target.  Docstring: Fit the GradientBoostingClassifier to the training data.

Parameters:
- features (np.ndarray): The training features.
- target (np.ndarray): The target values.

Returns:
None

>>> import numpy as np
>>> from sklearn.datasets import load_iris
>>> clf = GradientBoostingClassifier(n_estimators=100, learning_rate=0.1)
>>> iris = load_iris()
>>> X, y = iris.data, iris.target
>>> clf.fit(X, y)
>>> # Check if the model is trained
>>> len(clf.models) == 100
True
 - Function 'predict' takes 2 arguments: self, features.  Docstring: Make predictions on input data.

Parameters:
- features (np.ndarray): The input data for making predictions.

Returns:
- np.ndarray: An array of binary predictions (-1 or 1).

>>> import numpy as np
>>> from sklearn.datasets import load_iris
>>> clf = GradientBoostingClassifier(n_estimators=100, learning_rate=0.1)
>>> iris = load_iris()
>>> X, y = iris.data, iris.target
>>> clf.fit(X, y)
>>> y_pred = clf.predict(X)
>>> # Check if the predictions have the correct shape
>>> y_pred.shape == y.shape
True
 - Function 'gradient' takes 3 arguments: self, target, y_pred.  Docstring: Calculate the negative gradient (pseudo-residuals) for logistic loss.

Parameters:
- target (np.ndarray): The target values.
- y_pred (np.ndarray): The predicted values.

Returns:
- np.ndarray: An array of pseudo-residuals.

>>> import numpy as np
>>> clf = GradientBoostingClassifier(n_estimators=100, learning_rate=0.1)
>>> target = np.array([0, 1, 0, 1])
>>> y_pred = np.array([0.2, 0.8, 0.3, 0.7])
>>> residuals = clf.gradient(target, y_pred)
>>> # Check if residuals have the correct shape
>>> residuals.shape == target.shape
True

File: gradient_descent.py
 - Function '_error' takes 2 arguments: example_no, data_set.  Docstring: :param data_set: train data or test data
:param example_no: example number whose error has to be checked
:return: error in example pointed by example number.
 - Function '_hypothesis_value' takes 1 arguments: data_input_tuple.  Docstring: Calculates hypothesis function value for a given input
:param data_input_tuple: Input tuple of a particular example
:return: Value of hypothesis function at that point.
Note that there is an 'biased input' whose value is fixed as 1.
It is not explicitly mentioned in input data.. But, ML hypothesis functions use it.
So, we have to take care of it separately. Line 36 takes care of it.
 - Function 'output' takes 2 arguments: example_no, data_set.  Docstring: :param data_set: test data or train data
:param example_no: example whose output is to be fetched
:return: output for that example
 - Function 'calculate_hypothesis_value' takes 2 arguments: example_no, data_set.  Docstring: Calculates hypothesis value for a given example
:param data_set: test data or train_data
:param example_no: example whose hypothesis value is to be calculated
:return: hypothesis value for that example
 - Function 'summation_of_cost_derivative' takes 2 arguments: index, end.  Docstring: Calculates the sum of cost function derivative
:param index: index wrt derivative is being calculated
:param end: value where summation ends, default is m, number of examples
:return: Returns the summation of cost derivative
Note: If index is -1, this means we are calculating summation wrt to biased
    parameter.
 - Function 'get_cost_derivative' takes 1 arguments: index.  Docstring: :param index: index of the parameter vector wrt to derivative is to be calculated
:return: derivative wrt to that index
Note: If index is -1, this means we are calculating summation wrt to biased
    parameter.
 - Function 'run_gradient_descent' takes 0 arguments: .  No docstring available.
 - Function 'test_gradient_descent' takes 0 arguments: .  No docstring available.

File: k_means_clust.py
 - Function 'get_initial_centroids' takes 3 arguments: data, k, seed.  Docstring: Randomly choose k data points as initial centroids
 - Function 'centroid_pairwise_dist' takes 2 arguments: x, centroids.  No docstring available.
 - Function 'assign_clusters' takes 2 arguments: data, centroids.  No docstring available.
 - Function 'revise_centroids' takes 3 arguments: data, k, cluster_assignment.  No docstring available.
 - Function 'compute_heterogeneity' takes 4 arguments: data, k, centroids, cluster_assignment.  No docstring available.
 - Function 'plot_heterogeneity' takes 2 arguments: heterogeneity, k.  No docstring available.
 - Function 'kmeans' takes 6 arguments: data, k, initial_centroids, maxiter, record_heterogeneity, verbose.  Docstring: Runs k-means on given data and initial set of centroids.
maxiter: maximum number of iterations to run.(default=500)
record_heterogeneity: (optional) a list, to store the history of heterogeneity
                      as function of iterations
                      if None, do not store the history.
verbose: if True, print how many data points changed their cluster labels in
                      each iteration
 - Function 'report_generator' takes 3 arguments: predicted, clustering_variables, fill_missing_report.  Docstring: Generate a clustering report given these two arguments:
    predicted - dataframe with predicted cluster column
    fill_missing_report - dictionary of rules on how we are going to fill in missing
    values for final generated report (not included in modelling);
>>> predicted = pd.DataFrame()
>>> predicted['numbers'] = [1, 2, 3]
>>> predicted['col1'] = [0.5, 2.5, 4.5]
>>> predicted['col2'] = [100, 200, 300]
>>> predicted['col3'] = [10, 20, 30]
>>> predicted['Cluster'] = [1, 1, 2]
>>> report_generator(predicted, ['col1', 'col2'], 0)
           Features               Type   Mark           1           2
0    # of Customers        ClusterSize  False    2.000000    1.000000
1    % of Customers  ClusterProportion  False    0.666667    0.333333
2              col1    mean_with_zeros   True    1.500000    4.500000
3              col2    mean_with_zeros   True  150.000000  300.000000
4           numbers    mean_with_zeros  False    1.500000    3.000000
..              ...                ...    ...         ...         ...
99            dummy                 5%  False    1.000000    1.000000
100           dummy                95%  False    1.000000    1.000000
101           dummy              stdev  False    0.000000         NaN
102           dummy               mode  False    1.000000    1.000000
103           dummy             median  False    1.000000    1.000000
<BLANKLINE>
[104 rows x 5 columns]

File: k_nearest_neighbours.py
 - Function '__init__' takes 4 arguments: self, train_data, train_target, class_labels.  Docstring: Create a kNN classifier using the given training data and class labels
 - Function '_euclidean_distance' takes 2 arguments: a, b.  Docstring: Calculate the Euclidean distance between two points
>>> KNN._euclidean_distance(np.array([0, 0]), np.array([3, 4]))
5.0
>>> KNN._euclidean_distance(np.array([1, 2, 3]), np.array([1, 8, 11]))
10.0
 - Function 'classify' takes 3 arguments: self, pred_point, k.  Docstring: Classify a given point using the kNN algorithm
>>> train_X = np.array(
...     [[0, 0], [1, 0], [0, 1], [0.5, 0.5], [3, 3], [2, 3], [3, 2]]
... )
>>> train_y = np.array([0, 0, 0, 0, 1, 1, 1])
>>> classes = ['A', 'B']
>>> knn = KNN(train_X, train_y, classes)
>>> point = np.array([1.2, 1.2])
>>> knn.classify(point)
'A'

File: linear_discriminant_analysis.py
 - Function 'gaussian_distribution' takes 3 arguments: mean, std_dev, instance_count.  Docstring: Generate gaussian distribution instances based-on given mean and standard deviation
:param mean: mean value of class
:param std_dev: value of standard deviation entered by usr or default value of it
:param instance_count: instance number of class
:return: a list containing generated values based-on given mean, std_dev and
    instance_count

>>> gaussian_distribution(5.0, 1.0, 20) # doctest: +NORMALIZE_WHITESPACE
[6.288184753155463, 6.4494456086997705, 5.066335808938262, 4.235456349028368,
 3.9078267848958586, 5.031334516831717, 3.977896829989127, 3.56317055489747,
  5.199311976483754, 5.133374604658605, 5.546468300338232, 4.086029056264687,
   5.005005283626573, 4.935258239627312, 3.494170998739258, 5.537997178661033,
    5.320711100998849, 7.3891120432406865, 5.202969177309964, 4.855297691835079]
 - Function 'y_generator' takes 2 arguments: class_count, instance_count.  Docstring: Generate y values for corresponding classes
:param class_count: Number of classes(data groupings) in dataset
:param instance_count: number of instances in class
:return: corresponding values for data groupings in dataset

>>> y_generator(1, [10])
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
>>> y_generator(2, [5, 10])
[0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
>>> y_generator(4, [10, 5, 15, 20]) # doctest: +NORMALIZE_WHITESPACE
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
 - Function 'calculate_mean' takes 2 arguments: instance_count, items.  Docstring: Calculate given class mean
:param instance_count: Number of instances in class
:param items: items that related to specific class(data grouping)
:return: calculated actual mean of considered class

>>> items = gaussian_distribution(5.0, 1.0, 20)
>>> calculate_mean(len(items), items)
5.011267842911003
 - Function 'calculate_probabilities' takes 2 arguments: instance_count, total_count.  Docstring: Calculate the probability that a given instance will belong to which class
:param instance_count: number of instances in class
:param total_count: the number of all instances
:return: value of probability for considered class

>>> calculate_probabilities(20, 60)
0.3333333333333333
>>> calculate_probabilities(30, 100)
0.3
 - Function 'calculate_variance' takes 3 arguments: items, means, total_count.  Docstring: Calculate the variance
:param items: a list containing all items(gaussian distribution of all classes)
:param means: a list containing real mean values of each class
:param total_count: the number of all instances
:return: calculated variance for considered dataset

>>> items = gaussian_distribution(5.0, 1.0, 20)
>>> means = [5.011267842911003]
>>> total_count = 20
>>> calculate_variance([items], means, total_count)
0.9618530973487491
 - Function 'predict_y_values' takes 4 arguments: x_items, means, variance, probabilities.  Docstring: This function predicts new indexes(groups for our data)
:param x_items: a list containing all items(gaussian distribution of all classes)
:param means: a list containing real mean values of each class
:param variance: calculated value of variance by calculate_variance function
:param probabilities: a list containing all probabilities of classes
:return: a list containing predicted Y values

>>> x_items = [[6.288184753155463, 6.4494456086997705, 5.066335808938262,
...                4.235456349028368, 3.9078267848958586, 5.031334516831717,
...                3.977896829989127, 3.56317055489747, 5.199311976483754,
...                5.133374604658605, 5.546468300338232, 4.086029056264687,
...                5.005005283626573, 4.935258239627312, 3.494170998739258,
...                5.537997178661033, 5.320711100998849, 7.3891120432406865,
...                5.202969177309964, 4.855297691835079], [11.288184753155463,
...                11.44944560869977, 10.066335808938263, 9.235456349028368,
...                8.907826784895859, 10.031334516831716, 8.977896829989128,
...                8.56317055489747, 10.199311976483754, 10.133374604658606,
...                10.546468300338232, 9.086029056264687, 10.005005283626572,
...                9.935258239627313, 8.494170998739259, 10.537997178661033,
...                10.320711100998848, 12.389112043240686, 10.202969177309964,
...                9.85529769183508], [16.288184753155463, 16.449445608699772,
...                15.066335808938263, 14.235456349028368, 13.907826784895859,
...                15.031334516831716, 13.977896829989128, 13.56317055489747,
...                15.199311976483754, 15.133374604658606, 15.546468300338232,
...                14.086029056264687, 15.005005283626572, 14.935258239627313,
...                13.494170998739259, 15.537997178661033, 15.320711100998848,
...                17.389112043240686, 15.202969177309964, 14.85529769183508]]

>>> means = [5.011267842911003, 10.011267842911003, 15.011267842911002]
>>> variance = 0.9618530973487494
>>> probabilities = [0.3333333333333333, 0.3333333333333333, 0.3333333333333333]
>>> predict_y_values(x_items, means, variance,
...                  probabilities)  # doctest: +NORMALIZE_WHITESPACE
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
2, 2, 2, 2, 2, 2, 2, 2, 2]
 - Function 'accuracy' takes 2 arguments: actual_y, predicted_y.  Docstring: Calculate the value of accuracy based-on predictions
:param actual_y:a list containing initial Y values generated by 'y_generator'
    function
:param predicted_y: a list containing predicted Y values generated by
    'predict_y_values' function
:return: percentage of accuracy

>>> actual_y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
... 1, 1 ,1 ,1 ,1 ,1 ,1]
>>> predicted_y = [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0,
... 0, 0, 1, 1, 1, 0, 1, 1, 1]
>>> accuracy(actual_y, predicted_y)
50.0

>>> actual_y = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
... 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
>>> predicted_y = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
... 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
>>> accuracy(actual_y, predicted_y)
100.0
 - Function 'valid_input' takes 5 arguments: input_type, input_msg, err_msg, condition, default.  Docstring: Ask for user value and validate that it fulfill a condition.

:input_type: user input expected type of value
:input_msg: message to show user in the screen
:err_msg: message to show in the screen in case of error
:condition: function that represents the condition that user input is valid.
:default: Default value in case the user does not type anything
:return: user's input
 - Function 'main' takes 0 arguments: .  Docstring: This function starts execution phase

File: linear_regression.py
 - Function 'collect_dataset' takes 0 arguments: .  Docstring: Collect dataset of CSGO
The dataset contains ADR vs Rating of a Player
:return : dataset obtained from the link, as matrix
 - Function 'run_steep_gradient_descent' takes 5 arguments: data_x, data_y, len_data, alpha, theta.  Docstring: Run steep gradient descent and updates the Feature vector accordingly_
:param data_x   : contains the dataset
:param data_y   : contains the output associated with each data-entry
:param len_data : length of the data_
:param alpha    : Learning rate of the model
:param theta    : Feature vector (weight's for our model)
;param return    : Updated Feature's, using
                   curr_features - alpha_ * gradient(w.r.t. feature)
 - Function 'sum_of_square_error' takes 4 arguments: data_x, data_y, len_data, theta.  Docstring: Return sum of square error for error calculation
:param data_x    : contains our dataset
:param data_y    : contains the output (result vector)
:param len_data  : len of the dataset
:param theta     : contains the feature vector
:return          : sum of square error computed from given feature's
 - Function 'run_linear_regression' takes 2 arguments: data_x, data_y.  Docstring: Implement Linear regression over the dataset
:param data_x  : contains our dataset
:param data_y  : contains the output (result vector)
:return        : feature for line of best fit (Feature vector)
 - Function 'mean_absolute_error' takes 2 arguments: predicted_y, original_y.  Docstring: Return sum of square error for error calculation
:param predicted_y   : contains the output of prediction (result vector)
:param original_y    : contains values of expected outcome
:return          : mean absolute error computed from given feature's
 - Function 'main' takes 0 arguments: .  Docstring: Driver function

File: logistic_regression.py
 - Function 'sigmoid_function' takes 1 arguments: z.  Docstring: Also known as Logistic Function.

            1
f(x) =   -------
          1 + e

The sigmoid function approaches a value of 1 as its input 'x' becomes
increasing positive. Opposite for negative values.

Reference: https://en.wikipedia.org/wiki/Sigmoid_function

@param z:  input to the function
@returns: returns value in the range 0 to 1

Examples:
>>> sigmoid_function(4)
0.9820137900379085
>>> sigmoid_function(np.array([-3, 3]))
array([0.04742587, 0.95257413])
>>> sigmoid_function(np.array([-3, 3, 1]))
array([0.04742587, 0.95257413, 0.73105858])
>>> sigmoid_function(np.array([-0.01, -2, -1.9]))
array([0.49750002, 0.11920292, 0.13010847])
>>> sigmoid_function(np.array([-1.3, 5.3, 12]))
array([0.21416502, 0.9950332 , 0.99999386])
>>> sigmoid_function(np.array([0.01, 0.02, 4.1]))
array([0.50249998, 0.50499983, 0.9836975 ])
>>> sigmoid_function(np.array([0.8]))
array([0.68997448])
 - Function 'cost_function' takes 2 arguments: h, y.  Docstring: Cost function quantifies the error between predicted and expected values.
The cost function used in Logistic Regression is called Log Loss
or Cross Entropy Function.

J() = (1/m) *  [ -y * log(h(x)) - (1 - y) * log(1 - h(x)) ]

Where:
   - J() is the cost that we want to minimize during training
   - m is the number of training examples
   -  represents the summation over all training examples
   - y is the actual binary label (0 or 1) for a given example
   - h(x) is the predicted probability that x belongs to the positive class

@param h: the output of sigmoid function. It is the estimated probability
that the input example 'x' belongs to the positive class

@param y: the actual binary label associated with input example 'x'

Examples:
>>> estimations = sigmoid_function(np.array([0.3, -4.3, 8.1]))
>>> cost_function(h=estimations,y=np.array([1, 0, 1]))
0.18937868932131605
>>> estimations = sigmoid_function(np.array([4, 3, 1]))
>>> cost_function(h=estimations,y=np.array([1, 0, 0]))
1.459999655669926
>>> estimations = sigmoid_function(np.array([4, -3, -1]))
>>> cost_function(h=estimations,y=np.array([1,0,0]))
0.1266663223365915
>>> estimations = sigmoid_function(0)
>>> cost_function(h=estimations,y=np.array([1]))
0.6931471805599453

References:
   - https://en.wikipedia.org/wiki/Logistic_regression
 - Function 'log_likelihood' takes 3 arguments: x, y, weights.  No docstring available.
 - Function 'logistic_reg' takes 4 arguments: alpha, x, y, max_iterations.  No docstring available.
 - Function 'predict_prob' takes 1 arguments: x.  No docstring available.

File: loss_functions.py
 - Function 'binary_cross_entropy' takes 3 arguments: y_true, y_pred, epsilon.  Docstring: Calculate the mean binary cross-entropy (BCE) loss between true labels and predicted
probabilities.

BCE loss quantifies dissimilarity between true labels (0 or 1) and predicted
probabilities. It's widely used in binary classification tasks.

BCE = -(y_true * ln(y_pred) + (1 - y_true) * ln(1 - y_pred))

Reference: https://en.wikipedia.org/wiki/Cross_entropy

Parameters:
- y_true: True binary labels (0 or 1)
- y_pred: Predicted probabilities for class 1
- epsilon: Small constant to avoid numerical instability

>>> true_labels = np.array([0, 1, 1, 0, 1])
>>> predicted_probs = np.array([0.2, 0.7, 0.9, 0.3, 0.8])
>>> binary_cross_entropy(true_labels, predicted_probs)
0.2529995012327421
>>> true_labels = np.array([0, 1, 1, 0, 1])
>>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])
>>> binary_cross_entropy(true_labels, predicted_probs)
Traceback (most recent call last):
    ...
ValueError: Input arrays must have the same length.
 - Function 'binary_focal_cross_entropy' takes 5 arguments: y_true, y_pred, gamma, alpha, epsilon.  Docstring: Calculate the mean binary focal cross-entropy (BFCE) loss between true labels
and predicted probabilities.

BFCE loss quantifies dissimilarity between true labels (0 or 1) and predicted
probabilities. It's a variation of binary cross-entropy that addresses class
imbalance by focusing on hard examples.

BCFE = -(alpha * (1 - y_pred)**gamma * y_true * log(y_pred)
            + (1 - alpha) * y_pred**gamma * (1 - y_true) * log(1 - y_pred))

Reference: [Lin et al., 2018](https://arxiv.org/pdf/1708.02002.pdf)

Parameters:
- y_true: True binary labels (0 or 1).
- y_pred: Predicted probabilities for class 1.
- gamma: Focusing parameter for modulating the loss (default: 2.0).
- alpha: Weighting factor for class 1 (default: 0.25).
- epsilon: Small constant to avoid numerical instability.

>>> true_labels = np.array([0, 1, 1, 0, 1])
>>> predicted_probs = np.array([0.2, 0.7, 0.9, 0.3, 0.8])
>>> binary_focal_cross_entropy(true_labels, predicted_probs)
0.008257977659239775
>>> true_labels = np.array([0, 1, 1, 0, 1])
>>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])
>>> binary_focal_cross_entropy(true_labels, predicted_probs)
Traceback (most recent call last):
    ...
ValueError: Input arrays must have the same length.
 - Function 'categorical_cross_entropy' takes 3 arguments: y_true, y_pred, epsilon.  Docstring: Calculate categorical cross-entropy (CCE) loss between true class labels and
predicted class probabilities.

CCE = -(y_true * ln(y_pred))

Reference: https://en.wikipedia.org/wiki/Cross_entropy

Parameters:
- y_true: True class labels (one-hot encoded)
- y_pred: Predicted class probabilities
- epsilon: Small constant to avoid numerical instability

>>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]])
>>> categorical_cross_entropy(true_labels, pred_probs)
0.567395975254385
>>> true_labels = np.array([[1, 0], [0, 1]])
>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])
>>> categorical_cross_entropy(true_labels, pred_probs)
Traceback (most recent call last):
    ...
ValueError: Input arrays must have the same shape.
>>> true_labels = np.array([[2, 0, 1], [1, 0, 0]])
>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])
>>> categorical_cross_entropy(true_labels, pred_probs)
Traceback (most recent call last):
    ...
ValueError: y_true must be one-hot encoded.
>>> true_labels = np.array([[1, 0, 1], [1, 0, 0]])
>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])
>>> categorical_cross_entropy(true_labels, pred_probs)
Traceback (most recent call last):
    ...
ValueError: y_true must be one-hot encoded.
>>> true_labels = np.array([[1, 0, 0], [0, 1, 0]])
>>> pred_probs = np.array([[0.9, 0.1, 0.1], [0.2, 0.7, 0.1]])
>>> categorical_cross_entropy(true_labels, pred_probs)
Traceback (most recent call last):
    ...
ValueError: Predicted probabilities must sum to approximately 1.
 - Function 'categorical_focal_cross_entropy' takes 5 arguments: y_true, y_pred, alpha, gamma, epsilon.  Docstring: Calculate the mean categorical focal cross-entropy (CFCE) loss between true
labels and predicted probabilities for multi-class classification.

CFCE loss is a generalization of binary focal cross-entropy for multi-class
classification. It addresses class imbalance by focusing on hard examples.

CFCE = - alpha * (1 - y_pred)**gamma * y_true * log(y_pred)

Reference: [Lin et al., 2018](https://arxiv.org/pdf/1708.02002.pdf)

Parameters:
- y_true: True labels in one-hot encoded form.
- y_pred: Predicted probabilities for each class.
- alpha: Array of weighting factors for each class.
- gamma: Focusing parameter for modulating the loss (default: 2.0).
- epsilon: Small constant to avoid numerical instability.

Returns:
- The mean categorical focal cross-entropy loss.

>>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]])
>>> alpha = np.array([0.6, 0.2, 0.7])
>>> categorical_focal_cross_entropy(true_labels, pred_probs, alpha)
0.0025966118981496423

>>> true_labels = np.array([[0, 1, 0], [0, 0, 1]])
>>> pred_probs = np.array([[0.05, 0.95, 0], [0.1, 0.8, 0.1]])
>>> alpha = np.array([0.25, 0.25, 0.25])
>>> categorical_focal_cross_entropy(true_labels, pred_probs, alpha)
0.23315276982014324

>>> true_labels = np.array([[1, 0], [0, 1]])
>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])
>>> categorical_cross_entropy(true_labels, pred_probs)
Traceback (most recent call last):
    ...
ValueError: Input arrays must have the same shape.

>>> true_labels = np.array([[2, 0, 1], [1, 0, 0]])
>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])
>>> categorical_focal_cross_entropy(true_labels, pred_probs)
Traceback (most recent call last):
    ...
ValueError: y_true must be one-hot encoded.

>>> true_labels = np.array([[1, 0, 1], [1, 0, 0]])
>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1]])
>>> categorical_focal_cross_entropy(true_labels, pred_probs)
Traceback (most recent call last):
    ...
ValueError: y_true must be one-hot encoded.

>>> true_labels = np.array([[1, 0, 0], [0, 1, 0]])
>>> pred_probs = np.array([[0.9, 0.1, 0.1], [0.2, 0.7, 0.1]])
>>> categorical_focal_cross_entropy(true_labels, pred_probs)
Traceback (most recent call last):
    ...
ValueError: Predicted probabilities must sum to approximately 1.

>>> true_labels = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
>>> pred_probs = np.array([[0.9, 0.1, 0.0], [0.2, 0.7, 0.1], [0.0, 0.1, 0.9]])
>>> alpha = np.array([0.6, 0.2])
>>> categorical_focal_cross_entropy(true_labels, pred_probs, alpha)
Traceback (most recent call last):
    ...
ValueError: Length of alpha must match the number of classes.
 - Function 'hinge_loss' takes 2 arguments: y_true, y_pred.  Docstring: Calculate the mean hinge loss for between true labels and predicted probabilities
for training support vector machines (SVMs).

Hinge loss = max(0, 1 - true * pred)

Reference: https://en.wikipedia.org/wiki/Hinge_loss

Args:
- y_true: actual values (ground truth) encoded as -1 or 1
- y_pred: predicted values

>>> true_labels = np.array([-1, 1, 1, -1, 1])
>>> pred = np.array([-4, -0.3, 0.7, 5, 10])
>>> hinge_loss(true_labels, pred)
1.52
>>> true_labels = np.array([-1, 1, 1, -1, 1, 1])
>>> pred = np.array([-4, -0.3, 0.7, 5, 10])
>>> hinge_loss(true_labels, pred)
Traceback (most recent call last):
...
ValueError: Length of predicted and actual array must be same.
>>> true_labels = np.array([-1, 1, 10, -1, 1])
>>> pred = np.array([-4, -0.3, 0.7, 5, 10])
>>> hinge_loss(true_labels, pred)
Traceback (most recent call last):
...
ValueError: y_true can have values -1 or 1 only.
 - Function 'huber_loss' takes 3 arguments: y_true, y_pred, delta.  Docstring: Calculate the mean Huber loss between the given ground truth and predicted values.

The Huber loss describes the penalty incurred by an estimation procedure, and it
serves as a measure of accuracy for regression models.

Huber loss =
    0.5 * (y_true - y_pred)^2                   if |y_true - y_pred| <= delta
    delta * |y_true - y_pred| - 0.5 * delta^2   otherwise

Reference: https://en.wikipedia.org/wiki/Huber_loss

Parameters:
- y_true: The true values (ground truth)
- y_pred: The predicted values

>>> true_values = np.array([0.9, 10.0, 2.0, 1.0, 5.2])
>>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])
>>> np.isclose(huber_loss(true_values, predicted_values, 1.0), 2.102)
True
>>> true_labels = np.array([11.0, 21.0, 3.32, 4.0, 5.0])
>>> predicted_probs = np.array([8.3, 20.8, 2.9, 11.2, 5.0])
>>> np.isclose(huber_loss(true_labels, predicted_probs, 1.0), 1.80164)
True
>>> true_labels = np.array([11.0, 21.0, 3.32, 4.0])
>>> predicted_probs = np.array([8.3, 20.8, 2.9, 11.2, 5.0])
>>> huber_loss(true_labels, predicted_probs, 1.0)
Traceback (most recent call last):
...
ValueError: Input arrays must have the same length.
 - Function 'mean_squared_error' takes 2 arguments: y_true, y_pred.  Docstring: Calculate the mean squared error (MSE) between ground truth and predicted values.

MSE measures the squared difference between true values and predicted values, and it
serves as a measure of accuracy for regression models.

MSE = (1/n) * (y_true - y_pred)^2

Reference: https://en.wikipedia.org/wiki/Mean_squared_error

Parameters:
- y_true: The true values (ground truth)
- y_pred: The predicted values

>>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
>>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])
>>> np.isclose(mean_squared_error(true_values, predicted_values), 0.028)
True
>>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
>>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])
>>> mean_squared_error(true_labels, predicted_probs)
Traceback (most recent call last):
...
ValueError: Input arrays must have the same length.
 - Function 'mean_absolute_error' takes 2 arguments: y_true, y_pred.  Docstring: Calculates the Mean Absolute Error (MAE) between ground truth (observed)
    and predicted values.

MAE measures the absolute difference between true values and predicted values.

Equation:
MAE = (1/n) * (abs(y_true - y_pred))

Reference: https://en.wikipedia.org/wiki/Mean_absolute_error

Parameters:
- y_true: The true values (ground truth)
- y_pred: The predicted values

>>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
>>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])
>>> np.isclose(mean_absolute_error(true_values, predicted_values), 0.16)
True
>>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
>>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])
>>> np.isclose(mean_absolute_error(true_values, predicted_values), 2.16)
False
>>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
>>> predicted_probs = np.array([0.3, 0.8, 0.9, 5.2])
>>> mean_absolute_error(true_labels, predicted_probs)
Traceback (most recent call last):
...
ValueError: Input arrays must have the same length.
 - Function 'mean_squared_logarithmic_error' takes 2 arguments: y_true, y_pred.  Docstring: Calculate the mean squared logarithmic error (MSLE) between ground truth and
predicted values.

MSLE measures the squared logarithmic difference between true values and predicted
values for regression models. It's particularly useful for dealing with skewed or
large-value data, and it's often used when the relative differences between
predicted and true values are more important than absolute differences.

MSLE = (1/n) * (log(1 + y_true) - log(1 + y_pred))^2

Reference: https://insideaiml.com/blog/MeanSquared-Logarithmic-Error-Loss-1035

Parameters:
- y_true: The true values (ground truth)
- y_pred: The predicted values

>>> true_values = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
>>> predicted_values = np.array([0.8, 2.1, 2.9, 4.2, 5.2])
>>> mean_squared_logarithmic_error(true_values, predicted_values)
0.0030860877925181344
>>> true_labels = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
>>> predicted_probs = np.array([0.3, 0.8, 0.9, 0.2])
>>> mean_squared_logarithmic_error(true_labels, predicted_probs)
Traceback (most recent call last):
...
ValueError: Input arrays must have the same length.
 - Function 'mean_absolute_percentage_error' takes 3 arguments: y_true, y_pred, epsilon.  Docstring: Calculate the Mean Absolute Percentage Error between y_true and y_pred.

Mean Absolute Percentage Error calculates the average of the absolute
percentage differences between the predicted and true values.

Formula = (|y_true[i]-Y_pred[i]/y_true[i]|)/n

Source: https://stephenallwright.com/good-mape-score/

Parameters:
y_true (np.ndarray): Numpy array containing true/target values.
y_pred (np.ndarray): Numpy array containing predicted values.

Returns:
float: The Mean Absolute Percentage error between y_true and y_pred.

Examples:
>>> y_true = np.array([10, 20, 30, 40])
>>> y_pred = np.array([12, 18, 33, 45])
>>> mean_absolute_percentage_error(y_true, y_pred)
0.13125

>>> y_true = np.array([1, 2, 3, 4])
>>> y_pred = np.array([2, 3, 4, 5])
>>> mean_absolute_percentage_error(y_true, y_pred)
0.5208333333333333

>>> y_true = np.array([34, 37, 44, 47, 48, 48, 46, 43, 32, 27, 26, 24])
>>> y_pred = np.array([37, 40, 46, 44, 46, 50, 45, 44, 34, 30, 22, 23])
>>> mean_absolute_percentage_error(y_true, y_pred)
0.064671076436071
 - Function 'perplexity_loss' takes 3 arguments: y_true, y_pred, epsilon.  Docstring: Calculate the perplexity for the y_true and y_pred.

Compute the Perplexity which useful in predicting language model
accuracy in Natural Language Processing (NLP.)
Perplexity is measure of how certain the model in its predictions.

Perplexity Loss = exp(-1/N ( ln(p(x)))

Reference:
https://en.wikipedia.org/wiki/Perplexity

Args:
    y_true: Actual label encoded sentences of shape (batch_size, sentence_length)
    y_pred: Predicted sentences of shape (batch_size, sentence_length, vocab_size)
    epsilon: Small floating point number to avoid getting inf for log(0)

Returns:
    Perplexity loss between y_true and y_pred.

>>> y_true = np.array([[1, 4], [2, 3]])
>>> y_pred = np.array(
...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],
...      [0.24, 0.19, 0.09, 0.18, 0.27]],
...      [[0.03, 0.26, 0.21, 0.18, 0.30],
...       [0.28, 0.10, 0.33, 0.15, 0.12]]]
... )
>>> perplexity_loss(y_true, y_pred)
5.0247347775367945
>>> y_true = np.array([[1, 4], [2, 3]])
>>> y_pred = np.array(
...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],
...      [0.24, 0.19, 0.09, 0.18, 0.27],
...      [0.30, 0.10, 0.20, 0.15, 0.25]],
...      [[0.03, 0.26, 0.21, 0.18, 0.30],
...       [0.28, 0.10, 0.33, 0.15, 0.12],
...       [0.30, 0.10, 0.20, 0.15, 0.25]],]
... )
>>> perplexity_loss(y_true, y_pred)
Traceback (most recent call last):
...
ValueError: Sentence length of y_true and y_pred must be equal.
>>> y_true = np.array([[1, 4], [2, 11]])
>>> y_pred = np.array(
...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],
...      [0.24, 0.19, 0.09, 0.18, 0.27]],
...      [[0.03, 0.26, 0.21, 0.18, 0.30],
...       [0.28, 0.10, 0.33, 0.15, 0.12]]]
... )
>>> perplexity_loss(y_true, y_pred)
Traceback (most recent call last):
...
ValueError: Label value must not be greater than vocabulary size.
>>> y_true = np.array([[1, 4]])
>>> y_pred = np.array(
...    [[[0.28, 0.19, 0.21 , 0.15, 0.15],
...      [0.24, 0.19, 0.09, 0.18, 0.27]],
...      [[0.03, 0.26, 0.21, 0.18, 0.30],
...       [0.28, 0.10, 0.33, 0.15, 0.12]]]
... )
>>> perplexity_loss(y_true, y_pred)
Traceback (most recent call last):
...
ValueError: Batch size of y_true and y_pred must be equal.
 - Function 'smooth_l1_loss' takes 3 arguments: y_true, y_pred, beta.  Docstring: Calculate the Smooth L1 Loss between y_true and y_pred.

The Smooth L1 Loss is less sensitive to outliers than the L2 Loss and is often used
in regression problems, such as object detection.

Smooth L1 Loss =
    0.5 * (x - y)^2 / beta, if |x - y| < beta
    |x - y| - 0.5 * beta, otherwise

Reference:
https://pytorch.org/docs/stable/generated/torch.nn.SmoothL1Loss.html

Args:
    y_true: Array of true values.
    y_pred: Array of predicted values.
    beta: Specifies the threshold at which to change between L1 and L2 loss.

Returns:
    The calculated Smooth L1 Loss between y_true and y_pred.

Raises:
    ValueError: If the length of the two arrays is not the same.

>>> y_true = np.array([3, 5, 2, 7])
>>> y_pred = np.array([2.9, 4.8, 2.1, 7.2])
>>> smooth_l1_loss(y_true, y_pred, 1.0)
0.012500000000000022

>>> y_true = np.array([2, 4, 6])
>>> y_pred = np.array([1, 5, 7])
>>> smooth_l1_loss(y_true, y_pred, 1.0)
0.5

>>> y_true = np.array([1, 3, 5, 7])
>>> y_pred = np.array([1, 3, 5, 7])
>>> smooth_l1_loss(y_true, y_pred, 1.0)
0.0

>>> y_true = np.array([1, 3, 5])
>>> y_pred = np.array([1, 3, 5, 7])
>>> smooth_l1_loss(y_true, y_pred, 1.0)
Traceback (most recent call last):
...
ValueError: The length of the two arrays should be the same.
 - Function 'kullback_leibler_divergence' takes 2 arguments: y_true, y_pred.  Docstring: Calculate the Kullback-Leibler divergence (KL divergence) loss between true labels
and predicted probabilities.

KL divergence loss quantifies dissimilarity between true labels and predicted
probabilities. It's often used in training generative models.

KL = (y_true * ln(y_true / y_pred))

Reference: https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence

Parameters:
- y_true: True class probabilities
- y_pred: Predicted class probabilities

>>> true_labels = np.array([0.2, 0.3, 0.5])
>>> predicted_probs = np.array([0.3, 0.3, 0.4])
>>> kullback_leibler_divergence(true_labels, predicted_probs)
0.030478754035472025
>>> true_labels = np.array([0.2, 0.3, 0.5])
>>> predicted_probs = np.array([0.3, 0.3, 0.4, 0.5])
>>> kullback_leibler_divergence(true_labels, predicted_probs)
Traceback (most recent call last):
    ...
ValueError: Input arrays must have the same length.

File: mfcc.py
 - Function 'mfcc' takes 6 arguments: audio, sample_rate, ftt_size, hop_length, mel_filter_num, dct_filter_num.  Docstring: Calculate Mel Frequency Cepstral Coefficients (MFCCs) from an audio signal.

Args:
    audio: The input audio signal.
    sample_rate: The sample rate of the audio signal (in Hz).
    ftt_size: The size of the FFT window (default is 1024).
    hop_length: The hop length for frame creation (default is 20ms).
    mel_filter_num: The number of Mel filters (default is 10).
    dct_filter_num: The number of DCT filters (default is 40).

Returns:
    A matrix of MFCCs for the input audio.

Raises:
    ValueError: If the input audio is empty.

Example:
>>> sample_rate = 44100  # Sample rate of 44.1 kHz
>>> duration = 2.0  # Duration of 1 second
>>> t = np.linspace(0, duration, int(sample_rate * duration), endpoint=False)
>>> audio = 0.5 * np.sin(2 * np.pi * 440.0 * t)  # Generate a 440 Hz sine wave
>>> mfccs = mfcc(audio, sample_rate)
>>> mfccs.shape
(40, 101)
 - Function 'normalize' takes 1 arguments: audio.  Docstring: Normalize an audio signal by scaling it to have values between -1 and 1.

Args:
    audio: The input audio signal.

Returns:
    The normalized audio signal.

Examples:
>>> audio = np.array([1, 2, 3, 4, 5])
>>> normalized_audio = normalize(audio)
>>> np.max(normalized_audio)
1.0
>>> np.min(normalized_audio)
0.2
 - Function 'audio_frames' takes 4 arguments: audio, sample_rate, hop_length, ftt_size.  Docstring: Split an audio signal into overlapping frames.

Args:
    audio: The input audio signal.
    sample_rate: The sample rate of the audio signal.
    hop_length: The length of the hopping (default is 20ms).
    ftt_size: The size of the FFT window (default is 1024).

Returns:
    An array of overlapping frames.

Examples:
>>> audio = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]*1000)
>>> sample_rate = 8000
>>> frames = audio_frames(audio, sample_rate, hop_length=10, ftt_size=512)
>>> frames.shape
(126, 512)
 - Function 'calculate_fft' takes 2 arguments: audio_windowed, ftt_size.  Docstring: Calculate the Fast Fourier Transform (FFT) of windowed audio data.

Args:
    audio_windowed: The windowed audio signal.
    ftt_size: The size of the FFT (default is 1024).

Returns:
    The FFT of the audio data.

Examples:
>>> audio_windowed = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
>>> audio_fft = calculate_fft(audio_windowed, ftt_size=4)
>>> np.allclose(audio_fft[0], np.array([6.0+0.j, -1.5+0.8660254j, -1.5-0.8660254j]))
True
 - Function 'calculate_signal_power' takes 1 arguments: audio_fft.  Docstring: Calculate the power of the audio signal from its FFT.

Args:
    audio_fft: The FFT of the audio signal.

Returns:
    The power of the audio signal.

Examples:
>>> audio_fft = np.array([1+2j, 2+3j, 3+4j, 4+5j])
>>> power = calculate_signal_power(audio_fft)
>>> np.allclose(power, np.array([5, 13, 25, 41]))
True
 - Function 'freq_to_mel' takes 1 arguments: freq.  Docstring: Convert a frequency in Hertz to the mel scale.

Args:
    freq: The frequency in Hertz.

Returns:
    The frequency in mel scale.

Examples:
>>> round(freq_to_mel(1000), 2)
999.99
 - Function 'mel_to_freq' takes 1 arguments: mels.  Docstring: Convert a frequency in the mel scale to Hertz.

Args:
    mels: The frequency in mel scale.

Returns:
    The frequency in Hertz.

Examples:
>>> round(mel_to_freq(999.99), 2)
1000.01
 - Function 'mel_spaced_filterbank' takes 3 arguments: sample_rate, mel_filter_num, ftt_size.  Docstring: Create a Mel-spaced filter bank for audio processing.

Args:
    sample_rate: The sample rate of the audio.
    mel_filter_num: The number of mel filters (default is 10).
    ftt_size: The size of the FFT (default is 1024).

Returns:
    Mel-spaced filter bank.

Examples:
>>> round(mel_spaced_filterbank(8000, 10, 1024)[0][1], 10)
0.0004603981
 - Function 'get_filters' takes 2 arguments: filter_points, ftt_size.  Docstring: Generate filters for audio processing.

Args:
    filter_points: A list of filter points.
    ftt_size: The size of the FFT.

Returns:
    A matrix of filters.

Examples:
>>> get_filters(np.array([0, 20, 51, 95, 161, 256], dtype=int), 512).shape
(4, 257)
 - Function 'get_filter_points' takes 5 arguments: sample_rate, freq_min, freq_high, mel_filter_num, ftt_size.  Docstring: Calculate the filter points and frequencies for mel frequency filters.

Args:
    sample_rate: The sample rate of the audio.
    freq_min: The minimum frequency in Hertz.
    freq_high: The maximum frequency in Hertz.
    mel_filter_num: The number of mel filters (default is 10).
    ftt_size: The size of the FFT (default is 1024).

Returns:
    Filter points and corresponding frequencies.

Examples:
>>> filter_points = get_filter_points(8000, 0, 4000, mel_filter_num=4, ftt_size=512)
>>> filter_points[0]
array([  0,  20,  51,  95, 161, 256])
>>> filter_points[1]
array([   0.        ,  324.46707094,  799.33254207, 1494.30973963,
       2511.42581671, 4000.        ])
 - Function 'discrete_cosine_transform' takes 2 arguments: dct_filter_num, filter_num.  Docstring: Compute the Discrete Cosine Transform (DCT) basis matrix.

Args:
    dct_filter_num: The number of DCT filters to generate.
    filter_num: The number of the fbank filters.

Returns:
    The DCT basis matrix.

Examples:
>>> round(discrete_cosine_transform(3, 5)[0][0], 5)
0.44721
 - Function 'example' takes 1 arguments: wav_file_path.  Docstring: Example function to calculate Mel Frequency Cepstral Coefficients
(MFCCs) from an audio file.

Args:
    wav_file_path: The path to the WAV audio file.

Returns:
    np.ndarray: The computed MFCCs for the audio.

File: multilayer_perceptron_classifier.py
 - Function 'wrapper' takes 1 arguments: y.  Docstring: >>> wrapper(Y)
[0, 0, 1]

File: polynomial_regression.py
 - Function '__init__' takes 2 arguments: self, degree.  Docstring: @raises ValueError: if the polynomial degree is negative
 - Function '_design_matrix' takes 2 arguments: data, degree.  Docstring: Constructs a polynomial regression design matrix for the given input data. For
input data x = (x, x, ..., x) and polynomial degree m, the design matrix is
the Vandermonde matrix

    |1  x  x  x|
X = |1  x  x  x|
    |           |
    |1  x  x   x|

Reference: https://en.wikipedia.org/wiki/Vandermonde_matrix

@param data:    the input predictor values x, either for model fitting or for
                prediction
@param degree:  the polynomial degree m
@returns:       the Vandermonde matrix X (see above)
@raises ValueError: if input data is not N x 1

>>> x = np.array([0, 1, 2])
>>> PolynomialRegression._design_matrix(x, degree=0)
array([[1],
       [1],
       [1]])
>>> PolynomialRegression._design_matrix(x, degree=1)
array([[1, 0],
       [1, 1],
       [1, 2]])
>>> PolynomialRegression._design_matrix(x, degree=2)
array([[1, 0, 0],
       [1, 1, 1],
       [1, 2, 4]])
>>> PolynomialRegression._design_matrix(x, degree=3)
array([[1, 0, 0, 0],
       [1, 1, 1, 1],
       [1, 2, 4, 8]])
>>> PolynomialRegression._design_matrix(np.array([[0, 0], [0 , 0]]), degree=3)
Traceback (most recent call last):
...
ValueError: Data must have dimensions N x 1
 - Function 'fit' takes 3 arguments: self, x_train, y_train.  Docstring: Computes the polynomial regression model parameters using ordinary least squares
(OLS) estimation:

 = (XX)Xy = Xy

where X denotes the Moore-Penrose pseudoinverse of the design matrix X. This
function computes X using singular value decomposition (SVD).

References:
    - https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse
    - https://en.wikipedia.org/wiki/Singular_value_decomposition
    - https://en.wikipedia.org/wiki/Multicollinearity

@param x_train: the predictor values x for model fitting
@param y_train: the response values y for model fitting
@raises ArithmeticError:    if X isn't full rank, then XX is singular and 
                            doesn't exist

>>> x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
>>> y = x**3 - 2 * x**2 + 3 * x - 5
>>> poly_reg = PolynomialRegression(degree=3)
>>> poly_reg.fit(x, y)
>>> poly_reg.params
array([-5.,  3., -2.,  1.])
>>> poly_reg = PolynomialRegression(degree=20)
>>> poly_reg.fit(x, y)
Traceback (most recent call last):
...
ArithmeticError: Design matrix is not full rank, can't compute coefficients

Make sure errors don't grow too large:
>>> coefs = np.array([-250, 50, -2, 36, 20, -12, 10, 2, -1, -15, 1])
>>> y = PolynomialRegression._design_matrix(x, len(coefs) - 1) @ coefs
>>> poly_reg = PolynomialRegression(degree=len(coefs) - 1)
>>> poly_reg.fit(x, y)
>>> np.allclose(poly_reg.params, coefs, atol=10e-3)
True
 - Function 'predict' takes 2 arguments: self, data.  Docstring: Computes the predicted response values y for the given input data by
constructing the design matrix X and evaluating y = X.

@param data:    the predictor values x for prediction
@returns:       the predicted response values y = X
@raises ArithmeticError:    if this function is called before the model
                            parameters are fit

>>> x = np.array([0, 1, 2, 3, 4])
>>> y = x**3 - 2 * x**2 + 3 * x - 5
>>> poly_reg = PolynomialRegression(degree=3)
>>> poly_reg.fit(x, y)
>>> poly_reg.predict(np.array([-1]))
array([-11.])
>>> poly_reg.predict(np.array([-2]))
array([-27.])
>>> poly_reg.predict(np.array([6]))
array([157.])
>>> PolynomialRegression(degree=3).predict(x)
Traceback (most recent call last):
...
ArithmeticError: Predictor hasn't been fit yet
 - Function 'main' takes 0 arguments: .  Docstring: Fit a polynomial regression model to predict fuel efficiency using seaborn's mpg
dataset

>>> pass    # Placeholder, function is only for demo purposes

File: scoring_functions.py
 - Function 'mae' takes 2 arguments: predict, actual.  Docstring: Examples(rounded for precision):
>>> actual = [1,2,3];predict = [1,4,3]
>>> np.around(mae(predict,actual),decimals = 2)
0.67

>>> actual = [1,1,1];predict = [1,1,1]
>>> mae(predict,actual)
0.0
 - Function 'mse' takes 2 arguments: predict, actual.  Docstring: Examples(rounded for precision):
>>> actual = [1,2,3];predict = [1,4,3]
>>> np.around(mse(predict,actual),decimals = 2)
1.33

>>> actual = [1,1,1];predict = [1,1,1]
>>> mse(predict,actual)
0.0
 - Function 'rmse' takes 2 arguments: predict, actual.  Docstring: Examples(rounded for precision):
>>> actual = [1,2,3];predict = [1,4,3]
>>> np.around(rmse(predict,actual),decimals = 2)
1.15

>>> actual = [1,1,1];predict = [1,1,1]
>>> rmse(predict,actual)
0.0
 - Function 'rmsle' takes 2 arguments: predict, actual.  Docstring: Examples(rounded for precision):
>>> actual = [10,10,30];predict = [10,2,30]
>>> np.around(rmsle(predict,actual),decimals = 2)
0.75

>>> actual = [1,1,1];predict = [1,1,1]
>>> rmsle(predict,actual)
0.0
 - Function 'mbd' takes 2 arguments: predict, actual.  Docstring: This value is Negative, if the model underpredicts,
positive, if it overpredicts.

Example(rounded for precision):

Here the model overpredicts
>>> actual = [1,2,3];predict = [2,3,4]
>>> np.around(mbd(predict,actual),decimals = 2)
50.0

Here the model underpredicts
>>> actual = [1,2,3];predict = [0,1,1]
>>> np.around(mbd(predict,actual),decimals = 2)
-66.67
 - Function 'manual_accuracy' takes 2 arguments: predict, actual.  No docstring available.

File: self_organizing_map.py
 - Function 'get_winner' takes 3 arguments: self, weights, sample.  Docstring: Compute the winning vector by Euclidean distance

>>> SelfOrganizingMap().get_winner([[1, 2, 3], [4, 5, 6]], [1, 2, 3])
1
 - Function 'update' takes 5 arguments: self, weights, sample, j, alpha.  Docstring: Update the winning vector.

>>> SelfOrganizingMap().update([[1, 2, 3], [4, 5, 6]], [1, 2, 3], 1, 0.1)
[[1, 2, 3], [3.7, 4.7, 6]]
 - Function 'main' takes 0 arguments: .  No docstring available.

File: sequential_minimum_optimization.py
 - Function '__init__' takes 8 arguments: self, train, kernel_func, alpha_list, cost, b, tolerance, auto_norm.  No docstring available.
 - Function 'fit' takes 1 arguments: self.  No docstring available.
 - Function 'predict' takes 3 arguments: self, test_samples, classify.  No docstring available.
 - Function '_check_obey_kkt' takes 2 arguments: self, index.  No docstring available.
 - Function '_k' takes 3 arguments: self, i1, i2.  No docstring available.
 - Function '_e' takes 2 arguments: self, index.  Docstring: Two cases:
    1: Sample[index] is non-bound, fetch error from list: _error
    2: sample[index] is bound, use predicted value minus true value: g(xi) - yi
 - Function '_calculate_k_matrix' takes 1 arguments: self.  No docstring available.
 - Function '_predict' takes 2 arguments: self, sample.  No docstring available.
 - Function '_choose_alphas' takes 1 arguments: self.  No docstring available.
 - Function '_choose_a1' takes 1 arguments: self.  Docstring: Choose first alpha
Steps:
    1: First loop over all samples
    2: Second loop over all non-bound samples until no non-bound samples violate
       the KKT condition.
    3: Repeat these two processes until no samples violate the KKT condition
       after the first loop.
 - Function '_choose_a2' takes 2 arguments: self, i1.  Docstring: Choose the second alpha using a heuristic algorithm
Steps:
    1: Choose alpha2 that maximizes the step size (|E1 - E2|).
    2: Start in a random point, loop over all non-bound samples till alpha1 and
       alpha2 are optimized.
    3: Start in a random point, loop over all samples till alpha1 and alpha2 are
       optimized.
 - Function '_get_new_alpha' takes 9 arguments: self, i1, i2, a1, a2, e1, e2, y1, y2.  No docstring available.
 - Function '_norm' takes 2 arguments: self, data.  No docstring available.
 - Function '_is_unbound' takes 2 arguments: self, index.  No docstring available.
 - Function '_is_support' takes 2 arguments: self, index.  No docstring available.
 - Function 'unbound' takes 1 arguments: self.  No docstring available.
 - Function 'support' takes 1 arguments: self.  No docstring available.
 - Function 'length' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 5 arguments: self, kernel, degree, coef0, gamma.  No docstring available.
 - Function '_polynomial' takes 3 arguments: self, v1, v2.  No docstring available.
 - Function '_linear' takes 3 arguments: self, v1, v2.  No docstring available.
 - Function '_rbf' takes 3 arguments: self, v1, v2.  No docstring available.
 - Function '_check' takes 1 arguments: self.  No docstring available.
 - Function '_get_kernel' takes 2 arguments: self, kernel_name.  No docstring available.
 - Function '__call__' takes 3 arguments: self, v1, v2.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function 'count_time' takes 1 arguments: func.  No docstring available.
 - Function 'call_func' takes 0 arguments: .  No docstring available.
 - Function 'test_cancer_data' takes 0 arguments: .  No docstring available.
 - Function 'test_demonstration' takes 0 arguments: .  No docstring available.
 - Function 'test_linear_kernel' takes 2 arguments: ax, cost.  No docstring available.
 - Function 'test_rbf_kernel' takes 2 arguments: ax, cost.  No docstring available.
 - Function 'plot_partition_boundary' takes 5 arguments: model, train_data, ax, resolution, colors.  Docstring: We cannot get the optimal w of our kernel SVM model, which is different from a
linear SVM.  For this reason, we generate randomly distributed points with high
density, and predicted values of these points are calculated using our trained
model. Then we could use this predicted values to draw contour map, and this contour
map represents the SVM's partition boundary.

File: similarity_search.py
 - Function 'euclidean' takes 2 arguments: input_a, input_b.  Docstring: Calculates euclidean distance between two data.
:param input_a: ndarray of first vector.
:param input_b: ndarray of second vector.
:return: Euclidean distance of input_a and input_b. By using math.sqrt(),
         result will be float.

>>> euclidean(np.array([0]), np.array([1]))
1.0
>>> euclidean(np.array([0, 1]), np.array([1, 1]))
1.0
>>> euclidean(np.array([0, 0, 0]), np.array([0, 0, 1]))
1.0
 - Function 'similarity_search' takes 2 arguments: dataset, value_array.  Docstring: :param dataset: Set containing the vectors. Should be ndarray.
:param value_array: vector/vectors we want to know the nearest vector from dataset.
:return: Result will be a list containing
        1. the nearest vector
        2. distance from the vector

>>> dataset = np.array([[0], [1], [2]])
>>> value_array = np.array([[0]])
>>> similarity_search(dataset, value_array)
[[[0], 0.0]]

>>> dataset = np.array([[0, 0], [1, 1], [2, 2]])
>>> value_array = np.array([[0, 1]])
>>> similarity_search(dataset, value_array)
[[[0, 0], 1.0]]

>>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])
>>> value_array = np.array([[0, 0, 1]])
>>> similarity_search(dataset, value_array)
[[[0, 0, 0], 1.0]]

>>> dataset = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])
>>> value_array = np.array([[0, 0, 0], [0, 0, 1]])
>>> similarity_search(dataset, value_array)
[[[0, 0, 0], 0.0], [[0, 0, 0], 1.0]]

These are the errors that might occur:

1. If dimensions are different.
For example, dataset has 2d array and value_array has 1d array:
>>> dataset = np.array([[1]])
>>> value_array = np.array([1])
>>> similarity_search(dataset, value_array)
Traceback (most recent call last):
    ...
ValueError: Wrong input data's dimensions... dataset : 2, value_array : 1

2. If data's shapes are different.
For example, dataset has shape of (3, 2) and value_array has (2, 3).
We are expecting same shapes of two arrays, so it is wrong.
>>> dataset = np.array([[0, 0], [1, 1], [2, 2]])
>>> value_array = np.array([[0, 0, 0], [0, 0, 1]])
>>> similarity_search(dataset, value_array)
Traceback (most recent call last):
    ...
ValueError: Wrong input data's shape... dataset : 2, value_array : 3

3. If data types are different.
When trying to compare, we are expecting same types so they should be same.
If not, it'll come up with errors.
>>> dataset = np.array([[0, 0], [1, 1], [2, 2]], dtype=np.float32)
>>> value_array = np.array([[0, 0], [0, 1]], dtype=np.int32)
>>> similarity_search(dataset, value_array)  # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
    ...
TypeError: Input data have different datatype...
dataset : float32, value_array : int32
 - Function 'cosine_similarity' takes 2 arguments: input_a, input_b.  Docstring: Calculates cosine similarity between two data.
:param input_a: ndarray of first vector.
:param input_b: ndarray of second vector.
:return: Cosine similarity of input_a and input_b. By using math.sqrt(),
         result will be float.

>>> cosine_similarity(np.array([1]), np.array([1]))
1.0
>>> cosine_similarity(np.array([1, 2]), np.array([6, 32]))
0.9615239476408232

File: support_vector_machines.py
 - Function 'norm_squared' takes 1 arguments: vector.  Docstring: Return the squared second norm of vector
norm_squared(v) = sum(x * x for x in v)

Args:
    vector (ndarray): input vector

Returns:
    float: squared second norm of vector

>>> norm_squared([1, 2])
5
>>> norm_squared(np.asarray([1, 2]))
5
>>> norm_squared([0, 0])
0
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__linear' takes 3 arguments: self, vector1, vector2.  Docstring: Linear kernel (as if no kernel used at all)
 - Function '__rbf' takes 3 arguments: self, vector1, vector2.  Docstring: RBF: Radial Basis Function Kernel

Note: for more information see:
    https://en.wikipedia.org/wiki/Radial_basis_function_kernel

Args:
    vector1 (ndarray): first vector
    vector2 (ndarray): second vector)

Returns:
    float: exp(-(gamma * norm_squared(vector1 - vector2)))
 - Function 'fit' takes 3 arguments: self, observations, classes.  Docstring: Fits the SVC with a set of observations.

Args:
    observations (list[ndarray]): list of observations
    classes (ndarray): classification of each observation (in {1, -1})
 - Function 'to_minimize' takes 1 arguments: candidate.  Docstring: Opposite of the function to maximize

Args:
    candidate (ndarray): candidate array to test

Return:
    float: Wolfe's Dual result to minimize
 - Function 'predict' takes 2 arguments: self, observation.  Docstring: Get the expected class of an observation

Args:
    observation (Vector): observation

Returns:
    int {1, -1}: expected class

>>> xs = [
...     np.asarray([0, 1]), np.asarray([0, 2]),
...     np.asarray([1, 1]), np.asarray([1, 2])
... ]
>>> y = np.asarray([1, 1, -1, -1])
>>> s = SVC()
>>> s.fit(xs, y)
>>> s.predict(np.asarray([0, 1]))
1
>>> s.predict(np.asarray([1, 1]))
-1
>>> s.predict(np.asarray([2, 2]))
-1

File: word_frequency_functions.py
 - Function 'term_frequency' takes 2 arguments: term, document.  Docstring: Return the number of times a term occurs within
a given document.
@params: term, the term to search a document for, and document,
        the document to search within
@returns: an integer representing the number of times a term is
        found within the document

@examples:
>>> term_frequency("to", "To be, or not to be")
2
 - Function 'document_frequency' takes 2 arguments: term, corpus.  Docstring: Calculate the number of documents in a corpus that contain a
given term
@params : term, the term to search each document for, and corpus, a collection of
         documents. Each document should be separated by a newline.
@returns : the number of documents in the corpus that contain the term you are
           searching for and the number of documents in the corpus
@examples :
>>> document_frequency("first", "This is the first document in the corpus.\nThIsis the second document in the corpus.\nTHIS is the third document in the corpus.")
(1, 3)
 - Function 'inverse_document_frequency' takes 3 arguments: df, n, smoothing.  Docstring: Return an integer denoting the importance
of a word. This measure of importance is
calculated by log10(N/df), where N is the
number of documents and df is
the Document Frequency.
@params : df, the Document Frequency, N,
the number of documents in the corpus and
smoothing, if True return the idf-smooth
@returns : log10(N/df) or 1+log10(N/1+df)
@examples :
>>> inverse_document_frequency(3, 0)
Traceback (most recent call last):
 ...
ValueError: log10(0) is undefined.
>>> inverse_document_frequency(1, 3)
0.477
>>> inverse_document_frequency(0, 3)
Traceback (most recent call last):
 ...
ZeroDivisionError: df must be > 0
>>> inverse_document_frequency(0, 3,True)
1.477
 - Function 'tf_idf' takes 2 arguments: tf, idf.  Docstring: Combine the term frequency
and inverse document frequency functions to
calculate the originality of a term. This
'originality' is calculated by multiplying
the term frequency and the inverse document
frequency : tf-idf = TF * IDF
@params : tf, the term frequency, and idf, the inverse document
frequency
@examples :
>>> tf_idf(2, 0.477)
0.954

File: xgboost_classifier.py
 - Function 'data_handling' takes 1 arguments: data.  Docstring: >>> data_handling(({'data':'[5.1, 3.5, 1.4, 0.2]','target':([0])}))
('[5.1, 3.5, 1.4, 0.2]', [0])
>>> data_handling(
...     {'data': '[4.9, 3.0, 1.4, 0.2], [4.7, 3.2, 1.3, 0.2]', 'target': ([0, 0])}
... )
('[4.9, 3.0, 1.4, 0.2], [4.7, 3.2, 1.3, 0.2]', [0, 0])
 - Function 'xgboost' takes 2 arguments: features, target.  Docstring: # THIS TEST IS BROKEN!! >>> xgboost(np.array([[5.1, 3.6, 1.4, 0.2]]), np.array([0]))
XGBClassifier(base_score=0.5, booster='gbtree', callbacks=None,
              colsample_bylevel=1, colsample_bynode=1, colsample_bytree=1,
              early_stopping_rounds=None, enable_categorical=False,
              eval_metric=None, gamma=0, gpu_id=-1, grow_policy='depthwise',
              importance_type=None, interaction_constraints='',
              learning_rate=0.300000012, max_bin=256, max_cat_to_onehot=4,
              max_delta_step=0, max_depth=6, max_leaves=0, min_child_weight=1,
              missing=nan, monotone_constraints='()', n_estimators=100,
              n_jobs=0, num_parallel_tree=1, predictor='auto', random_state=0,
              reg_alpha=0, reg_lambda=1, ...)
 - Function 'main' takes 0 arguments: .  Docstring: >>> main()

Url for the algorithm:
https://xgboost.readthedocs.io/en/stable/
Iris type dataset is used to demonstrate algorithm.

File: xgboost_regressor.py
 - Function 'data_handling' takes 1 arguments: data.  Docstring: >>> data_handling((
...  {'data':'[ 8.3252 41. 6.9841269 1.02380952  322. 2.55555556   37.88 -122.23 ]'
...  ,'target':([4.526])}))
('[ 8.3252 41. 6.9841269 1.02380952  322. 2.55555556   37.88 -122.23 ]', [4.526])
 - Function 'xgboost' takes 3 arguments: features, target, test_features.  Docstring: >>> xgboost(np.array([[ 2.3571 ,   52. , 6.00813008, 1.06775068,
...    907. , 2.45799458,   40.58 , -124.26]]),np.array([1.114]),
... np.array([[1.97840000e+00,  3.70000000e+01,  4.98858447e+00,  1.03881279e+00,
...    1.14300000e+03,  2.60958904e+00,  3.67800000e+01, -1.19780000e+02]]))
array([[1.1139996]], dtype=float32)
 - Function 'main' takes 0 arguments: .  Docstring: The URL for this algorithm
https://xgboost.readthedocs.io/en/stable/
California house price dataset is used to demonstrate the algorithm.

Expected error values:
Mean Absolute Error: 0.30957163379906033
Mean Square Error: 0.22611560196662744

File: run.py
 - Function 'linear_regression_prediction' takes 5 arguments: train_dt, train_usr, train_mtch, test_dt, test_mtch.  Docstring: First method: linear regression
input : training data (date, total_user, total_event) in list of float
output : list of total user prediction in float
>>> n = linear_regression_prediction([2,3,4,5], [5,3,4,6], [3,1,2,4], [2,1], [2,2])
>>> abs(n - 5.0) < 1e-6  # Checking precision because of floating point errors
True
 - Function 'sarimax_predictor' takes 3 arguments: train_user, train_match, test_match.  Docstring: second method: Sarimax
sarimax is a statistic method which using previous input
and learn its pattern to predict future data
input : training data (total_user, with exog data = total_event) in list of float
output : list of total user prediction in float
>>> sarimax_predictor([4,2,6,8], [3,1,2,4], [2])
6.6666671111109626
 - Function 'support_vector_regressor' takes 3 arguments: x_train, x_test, train_user.  Docstring: Third method: Support vector regressor
svr is quite the same with svm(support vector machine)
it uses the same principles as the SVM for classification,
with only a few minor differences and the only different is that
it suits better for regression purpose
input : training data (date, total_user, total_event) in list of float
where x = list of set (date and total event)
output : list of total user prediction in float
>>> support_vector_regressor([[5,2],[1,5],[6,2]], [[3,2]], [2,1,4])
1.634932078116079
 - Function 'interquartile_range_checker' takes 1 arguments: train_user.  Docstring: Optional method: interquatile range
input : list of total user in float
output : low limit of input in float
this method can be used to check whether some data is outlier or not
>>> interquartile_range_checker([1,2,3,4,5,6,7,8,9,10])
2.8
 - Function 'data_safety_checker' takes 2 arguments: list_vote, actual_result.  Docstring: Used to review all the votes (list result prediction)
and compare it to the actual result.
input : list of predictions
output : print whether it's safe or not
>>> data_safety_checker([2, 3, 4], 5.0)
False

File: local_weighted_learning.py
 - Function 'weight_matrix' takes 3 arguments: point, x_train, tau.  Docstring: Calculate the weight of every point in the training data around a given
prediction point

Args:
    point: x-value at which the prediction is being made
    x_train: ndarray of x-values for training
    tau: bandwidth value, controls how quickly the weight of training values
        decreases as the distance from the prediction point increases

Returns:
    m x m weight matrix around the prediction point, where m is the size of
    the training set
>>> weight_matrix(
...     np.array([1., 1.]),
...     np.array([[16.99, 10.34], [21.01,23.68], [24.59,25.69]]),
...     0.6
... )
array([[1.43807972e-207, 0.00000000e+000, 0.00000000e+000],
       [0.00000000e+000, 0.00000000e+000, 0.00000000e+000],
       [0.00000000e+000, 0.00000000e+000, 0.00000000e+000]])
 - Function 'local_weight' takes 4 arguments: point, x_train, y_train, tau.  Docstring: Calculate the local weights at a given prediction point using the weight
matrix for that point

Args:
    point: x-value at which the prediction is being made
    x_train: ndarray of x-values for training
    y_train: ndarray of y-values for training
    tau: bandwidth value, controls how quickly the weight of training values
        decreases as the distance from the prediction point increases
Returns:
    ndarray of local weights
>>> local_weight(
...     np.array([1., 1.]),
...     np.array([[16.99, 10.34], [21.01,23.68], [24.59,25.69]]),
...     np.array([[1.01, 1.66, 3.5]]),
...     0.6
... )
array([[0.00873174],
       [0.08272556]])
 - Function 'local_weight_regression' takes 3 arguments: x_train, y_train, tau.  Docstring: Calculate predictions for each point in the training data

Args:
    x_train: ndarray of x-values for training
    y_train: ndarray of y-values for training
    tau: bandwidth value, controls how quickly the weight of training values
        decreases as the distance from the prediction point increases

Returns:
    ndarray of predictions
>>> local_weight_regression(
...     np.array([[16.99, 10.34], [21.01, 23.68], [24.59, 25.69]]),
...     np.array([[1.01, 1.66, 3.5]]),
...     0.6
... )
array([1.07173261, 1.65970737, 3.50160179])
 - Function 'load_data' takes 3 arguments: dataset_name, x_name, y_name.  Docstring: Load data from seaborn and split it into x and y points
>>> pass    # No doctests, function is for demo purposes only
 - Function 'plot_preds' takes 6 arguments: x_train, preds, x_data, y_data, x_name, y_name.  Docstring: Plot predictions and display the graph
>>> pass    # No doctests, function is for demo purposes only

File: lstm_prediction.py

File: abs.py
 - Function 'abs_val' takes 1 arguments: num.  Docstring: Find the absolute value of a number.

>>> abs_val(-5.1)
5.1
>>> abs_val(-5) == abs_val(5)
True
>>> abs_val(0)
0
 - Function 'abs_min' takes 1 arguments: x.  Docstring: >>> abs_min([0,5,1,11])
0
>>> abs_min([3,-10,-2])
-2
>>> abs_min([])
Traceback (most recent call last):
    ...
ValueError: abs_min() arg is an empty sequence
 - Function 'abs_max' takes 1 arguments: x.  Docstring: >>> abs_max([0,5,1,11])
11
>>> abs_max([3,-10,-2])
-10
>>> abs_max([])
Traceback (most recent call last):
    ...
ValueError: abs_max() arg is an empty sequence
 - Function 'abs_max_sort' takes 1 arguments: x.  Docstring: >>> abs_max_sort([0,5,1,11])
11
>>> abs_max_sort([3,-10,-2])
-10
>>> abs_max_sort([])
Traceback (most recent call last):
    ...
ValueError: abs_max_sort() arg is an empty sequence
 - Function 'test_abs_val' takes 0 arguments: .  Docstring: >>> test_abs_val()

File: addition_without_arithmetic.py
 - Function 'add' takes 2 arguments: first, second.  Docstring: Implementation of addition of integer

Examples:
>>> add(3, 5)
8
>>> add(13, 5)
18
>>> add(-7, 2)
-5
>>> add(0, -7)
-7
>>> add(-321, 0)
-321

File: aliquot_sum.py
 - Function 'aliquot_sum' takes 1 arguments: input_num.  Docstring: Finds the aliquot sum of an input integer, where the
aliquot sum of a number n is defined as the sum of all
natural numbers less than n that divide n evenly. For
example, the aliquot sum of 15 is 1 + 3 + 5 = 9. This is
a simple O(n) implementation.
@param input_num: a positive integer whose aliquot sum is to be found
@return: the aliquot sum of input_num, if input_num is positive.
Otherwise, raise a ValueError
Wikipedia Explanation: https://en.wikipedia.org/wiki/Aliquot_sum

>>> aliquot_sum(15)
9
>>> aliquot_sum(6)
6
>>> aliquot_sum(-1)
Traceback (most recent call last):
  ...
ValueError: Input must be positive
>>> aliquot_sum(0)
Traceback (most recent call last):
  ...
ValueError: Input must be positive
>>> aliquot_sum(1.6)
Traceback (most recent call last):
  ...
ValueError: Input must be an integer
>>> aliquot_sum(12)
16
>>> aliquot_sum(1)
0
>>> aliquot_sum(19)
1

File: allocation_number.py
 - Function 'allocation_num' takes 2 arguments: number_of_bytes, partitions.  Docstring: Divide a number of bytes into x partitions.
:param number_of_bytes: the total of bytes.
:param partitions: the number of partition need to be allocated.
:return: list of bytes to be assigned to each worker thread

>>> allocation_num(16647, 4)
['1-4161', '4162-8322', '8323-12483', '12484-16647']
>>> allocation_num(50000, 5)
['1-10000', '10001-20000', '20001-30000', '30001-40000', '40001-50000']
>>> allocation_num(888, 999)
Traceback (most recent call last):
    ...
ValueError: partitions can not > number_of_bytes!
>>> allocation_num(888, -4)
Traceback (most recent call last):
    ...
ValueError: partitions must be a positive number!

File: arc_length.py
 - Function 'arc_length' takes 2 arguments: angle, radius.  Docstring: >>> arc_length(45, 5)
3.9269908169872414
>>> arc_length(120, 15)
31.415926535897928
>>> arc_length(90, 10)
15.707963267948966

File: area.py
 - Function 'surface_area_cube' takes 1 arguments: side_length.  Docstring: Calculate the Surface Area of a Cube.

>>> surface_area_cube(1)
6
>>> surface_area_cube(1.6)
15.360000000000003
>>> surface_area_cube(0)
0
>>> surface_area_cube(3)
54
>>> surface_area_cube(-1)
Traceback (most recent call last):
    ...
ValueError: surface_area_cube() only accepts non-negative values
 - Function 'surface_area_cuboid' takes 3 arguments: length, breadth, height.  Docstring: Calculate the Surface Area of a Cuboid.

>>> surface_area_cuboid(1, 2, 3)
22
>>> surface_area_cuboid(0, 0, 0)
0
>>> surface_area_cuboid(1.6, 2.6, 3.6)
38.56
>>> surface_area_cuboid(-1, 2, 3)
Traceback (most recent call last):
    ...
ValueError: surface_area_cuboid() only accepts non-negative values
>>> surface_area_cuboid(1, -2, 3)
Traceback (most recent call last):
    ...
ValueError: surface_area_cuboid() only accepts non-negative values
>>> surface_area_cuboid(1, 2, -3)
Traceback (most recent call last):
    ...
ValueError: surface_area_cuboid() only accepts non-negative values
 - Function 'surface_area_sphere' takes 1 arguments: radius.  Docstring: Calculate the Surface Area of a Sphere.
Wikipedia reference: https://en.wikipedia.org/wiki/Sphere
Formula: 4 * pi * r^2

>>> surface_area_sphere(5)
314.1592653589793
>>> surface_area_sphere(1)
12.566370614359172
>>> surface_area_sphere(1.6)
32.169908772759484
>>> surface_area_sphere(0)
0.0
>>> surface_area_sphere(-1)
Traceback (most recent call last):
    ...
ValueError: surface_area_sphere() only accepts non-negative values
 - Function 'surface_area_hemisphere' takes 1 arguments: radius.  Docstring: Calculate the Surface Area of a Hemisphere.
Formula: 3 * pi * r^2

>>> surface_area_hemisphere(5)
235.61944901923448
>>> surface_area_hemisphere(1)
9.42477796076938
>>> surface_area_hemisphere(0)
0.0
>>> surface_area_hemisphere(1.1)
11.40398133253095
>>> surface_area_hemisphere(-1)
Traceback (most recent call last):
    ...
ValueError: surface_area_hemisphere() only accepts non-negative values
 - Function 'surface_area_cone' takes 2 arguments: radius, height.  Docstring: Calculate the Surface Area of a Cone.
Wikipedia reference: https://en.wikipedia.org/wiki/Cone
Formula: pi * r * (r + (h ** 2 + r ** 2) ** 0.5)

>>> surface_area_cone(10, 24)
1130.9733552923256
>>> surface_area_cone(6, 8)
301.59289474462014
>>> surface_area_cone(1.6, 2.6)
23.387862992395807
>>> surface_area_cone(0, 0)
0.0
>>> surface_area_cone(-1, -2)
Traceback (most recent call last):
    ...
ValueError: surface_area_cone() only accepts non-negative values
>>> surface_area_cone(1, -2)
Traceback (most recent call last):
    ...
ValueError: surface_area_cone() only accepts non-negative values
>>> surface_area_cone(-1, 2)
Traceback (most recent call last):
    ...
ValueError: surface_area_cone() only accepts non-negative values
 - Function 'surface_area_conical_frustum' takes 3 arguments: radius_1, radius_2, height.  Docstring: Calculate the Surface Area of a Conical Frustum.

>>> surface_area_conical_frustum(1, 2, 3)
45.511728065337266
>>> surface_area_conical_frustum(4, 5, 6)
300.7913575056268
>>> surface_area_conical_frustum(0, 0, 0)
0.0
>>> surface_area_conical_frustum(1.6, 2.6, 3.6)
78.57907060751548
>>> surface_area_conical_frustum(-1, 2, 3)
Traceback (most recent call last):
    ...
ValueError: surface_area_conical_frustum() only accepts non-negative values
>>> surface_area_conical_frustum(1, -2, 3)
Traceback (most recent call last):
    ...
ValueError: surface_area_conical_frustum() only accepts non-negative values
>>> surface_area_conical_frustum(1, 2, -3)
Traceback (most recent call last):
    ...
ValueError: surface_area_conical_frustum() only accepts non-negative values
 - Function 'surface_area_cylinder' takes 2 arguments: radius, height.  Docstring: Calculate the Surface Area of a Cylinder.
Wikipedia reference: https://en.wikipedia.org/wiki/Cylinder
Formula: 2 * pi * r * (h + r)

>>> surface_area_cylinder(7, 10)
747.6990515543707
>>> surface_area_cylinder(1.6, 2.6)
42.22300526424682
>>> surface_area_cylinder(0, 0)
0.0
>>> surface_area_cylinder(6, 8)
527.7875658030853
>>> surface_area_cylinder(-1, -2)
Traceback (most recent call last):
    ...
ValueError: surface_area_cylinder() only accepts non-negative values
>>> surface_area_cylinder(1, -2)
Traceback (most recent call last):
    ...
ValueError: surface_area_cylinder() only accepts non-negative values
>>> surface_area_cylinder(-1, 2)
Traceback (most recent call last):
    ...
ValueError: surface_area_cylinder() only accepts non-negative values
 - Function 'surface_area_torus' takes 2 arguments: torus_radius, tube_radius.  Docstring: Calculate the Area of a Torus.
Wikipedia reference: https://en.wikipedia.org/wiki/Torus
:return 4pi^2 * torus_radius * tube_radius
>>> surface_area_torus(1, 1)
39.47841760435743
>>> surface_area_torus(4, 3)
473.7410112522892
>>> surface_area_torus(3, 4)
Traceback (most recent call last):
    ...
ValueError: surface_area_torus() does not support spindle or self intersecting tori
>>> surface_area_torus(1.6, 1.6)
101.06474906715503
>>> surface_area_torus(0, 0)
0.0
>>> surface_area_torus(-1, 1)
Traceback (most recent call last):
    ...
ValueError: surface_area_torus() only accepts non-negative values
>>> surface_area_torus(1, -1)
Traceback (most recent call last):
    ...
ValueError: surface_area_torus() only accepts non-negative values
 - Function 'area_rectangle' takes 2 arguments: length, width.  Docstring: Calculate the area of a rectangle.

>>> area_rectangle(10, 20)
200
>>> area_rectangle(1.6, 2.6)
4.16
>>> area_rectangle(0, 0)
0
>>> area_rectangle(-1, -2)
Traceback (most recent call last):
    ...
ValueError: area_rectangle() only accepts non-negative values
>>> area_rectangle(1, -2)
Traceback (most recent call last):
    ...
ValueError: area_rectangle() only accepts non-negative values
>>> area_rectangle(-1, 2)
Traceback (most recent call last):
    ...
ValueError: area_rectangle() only accepts non-negative values
 - Function 'area_square' takes 1 arguments: side_length.  Docstring: Calculate the area of a square.

>>> area_square(10)
100
>>> area_square(0)
0
>>> area_square(1.6)
2.5600000000000005
>>> area_square(-1)
Traceback (most recent call last):
    ...
ValueError: area_square() only accepts non-negative values
 - Function 'area_triangle' takes 2 arguments: base, height.  Docstring: Calculate the area of a triangle given the base and height.

>>> area_triangle(10, 10)
50.0
>>> area_triangle(1.6, 2.6)
2.08
>>> area_triangle(0, 0)
0.0
>>> area_triangle(-1, -2)
Traceback (most recent call last):
    ...
ValueError: area_triangle() only accepts non-negative values
>>> area_triangle(1, -2)
Traceback (most recent call last):
    ...
ValueError: area_triangle() only accepts non-negative values
>>> area_triangle(-1, 2)
Traceback (most recent call last):
    ...
ValueError: area_triangle() only accepts non-negative values
 - Function 'area_triangle_three_sides' takes 3 arguments: side1, side2, side3.  Docstring: Calculate area of triangle when the length of 3 sides are known.
This function uses Heron's formula: https://en.wikipedia.org/wiki/Heron%27s_formula

>>> area_triangle_three_sides(5, 12, 13)
30.0
>>> area_triangle_three_sides(10, 11, 12)
51.521233486786784
>>> area_triangle_three_sides(0, 0, 0)
0.0
>>> area_triangle_three_sides(1.6, 2.6, 3.6)
1.8703742940919619
>>> area_triangle_three_sides(-1, -2, -1)
Traceback (most recent call last):
    ...
ValueError: area_triangle_three_sides() only accepts non-negative values
>>> area_triangle_three_sides(1, -2, 1)
Traceback (most recent call last):
    ...
ValueError: area_triangle_three_sides() only accepts non-negative values
>>> area_triangle_three_sides(2, 4, 7)
Traceback (most recent call last):
    ...
ValueError: Given three sides do not form a triangle
>>> area_triangle_three_sides(2, 7, 4)
Traceback (most recent call last):
    ...
ValueError: Given three sides do not form a triangle
>>> area_triangle_three_sides(7, 2, 4)
Traceback (most recent call last):
    ...
ValueError: Given three sides do not form a triangle
 - Function 'area_parallelogram' takes 2 arguments: base, height.  Docstring: Calculate the area of a parallelogram.

>>> area_parallelogram(10, 20)
200
>>> area_parallelogram(1.6, 2.6)
4.16
>>> area_parallelogram(0, 0)
0
>>> area_parallelogram(-1, -2)
Traceback (most recent call last):
    ...
ValueError: area_parallelogram() only accepts non-negative values
>>> area_parallelogram(1, -2)
Traceback (most recent call last):
    ...
ValueError: area_parallelogram() only accepts non-negative values
>>> area_parallelogram(-1, 2)
Traceback (most recent call last):
    ...
ValueError: area_parallelogram() only accepts non-negative values
 - Function 'area_trapezium' takes 3 arguments: base1, base2, height.  Docstring: Calculate the area of a trapezium.

>>> area_trapezium(10, 20, 30)
450.0
>>> area_trapezium(1.6, 2.6, 3.6)
7.5600000000000005
>>> area_trapezium(0, 0, 0)
0.0
>>> area_trapezium(-1, -2, -3)
Traceback (most recent call last):
    ...
ValueError: area_trapezium() only accepts non-negative values
>>> area_trapezium(-1, 2, 3)
Traceback (most recent call last):
    ...
ValueError: area_trapezium() only accepts non-negative values
>>> area_trapezium(1, -2, 3)
Traceback (most recent call last):
    ...
ValueError: area_trapezium() only accepts non-negative values
>>> area_trapezium(1, 2, -3)
Traceback (most recent call last):
    ...
ValueError: area_trapezium() only accepts non-negative values
>>> area_trapezium(-1, -2, 3)
Traceback (most recent call last):
    ...
ValueError: area_trapezium() only accepts non-negative values
>>> area_trapezium(1, -2, -3)
Traceback (most recent call last):
    ...
ValueError: area_trapezium() only accepts non-negative values
>>> area_trapezium(-1, 2, -3)
Traceback (most recent call last):
    ...
ValueError: area_trapezium() only accepts non-negative values
 - Function 'area_circle' takes 1 arguments: radius.  Docstring: Calculate the area of a circle.

>>> area_circle(20)
1256.6370614359173
>>> area_circle(1.6)
8.042477193189871
>>> area_circle(0)
0.0
>>> area_circle(-1)
Traceback (most recent call last):
    ...
ValueError: area_circle() only accepts non-negative values
 - Function 'area_ellipse' takes 2 arguments: radius_x, radius_y.  Docstring: Calculate the area of a ellipse.

>>> area_ellipse(10, 10)
314.1592653589793
>>> area_ellipse(10, 20)
628.3185307179587
>>> area_ellipse(0, 0)
0.0
>>> area_ellipse(1.6, 2.6)
13.06902543893354
>>> area_ellipse(-10, 20)
Traceback (most recent call last):
    ...
ValueError: area_ellipse() only accepts non-negative values
>>> area_ellipse(10, -20)
Traceback (most recent call last):
    ...
ValueError: area_ellipse() only accepts non-negative values
>>> area_ellipse(-10, -20)
Traceback (most recent call last):
    ...
ValueError: area_ellipse() only accepts non-negative values
 - Function 'area_rhombus' takes 2 arguments: diagonal_1, diagonal_2.  Docstring: Calculate the area of a rhombus.

>>> area_rhombus(10, 20)
100.0
>>> area_rhombus(1.6, 2.6)
2.08
>>> area_rhombus(0, 0)
0.0
>>> area_rhombus(-1, -2)
Traceback (most recent call last):
    ...
ValueError: area_rhombus() only accepts non-negative values
>>> area_rhombus(1, -2)
Traceback (most recent call last):
    ...
ValueError: area_rhombus() only accepts non-negative values
>>> area_rhombus(-1, 2)
Traceback (most recent call last):
    ...
ValueError: area_rhombus() only accepts non-negative values
 - Function 'area_reg_polygon' takes 2 arguments: sides, length.  Docstring: Calculate the area of a regular polygon.
Wikipedia reference: https://en.wikipedia.org/wiki/Polygon#Regular_polygons
Formula: (n*s^2*cot(pi/n))/4

>>> area_reg_polygon(3, 10)
43.301270189221945
>>> area_reg_polygon(4, 10)
100.00000000000001
>>> area_reg_polygon(0, 0)
Traceback (most recent call last):
    ...
ValueError: area_reg_polygon() only accepts integers greater than or equal to three as number of sides
>>> area_reg_polygon(-1, -2)
Traceback (most recent call last):
    ...
ValueError: area_reg_polygon() only accepts integers greater than or equal to three as number of sides
>>> area_reg_polygon(5, -2)
Traceback (most recent call last):
    ...
ValueError: area_reg_polygon() only accepts non-negative values as length of a side
>>> area_reg_polygon(-1, 2)
Traceback (most recent call last):
    ...
ValueError: area_reg_polygon() only accepts integers greater than or equal to three as number of sides

File: area_under_curve.py
 - Function 'trapezoidal_area' takes 4 arguments: fnc, x_start, x_end, steps.  Docstring: Treats curve as a collection of linear lines and sums the area of the
trapezium shape they form
:param fnc: a function which defines a curve
:param x_start: left end point to indicate the start of line segment
:param x_end: right end point to indicate end of line segment
:param steps: an accuracy gauge; more steps increases the accuracy
:return: a float representing the length of the curve

>>> def f(x):
...    return 5
>>> f"{trapezoidal_area(f, 12.0, 14.0, 1000):.3f}"
'10.000'
>>> def f(x):
...    return 9*x**2
>>> f"{trapezoidal_area(f, -4.0, 0, 10000):.4f}"
'192.0000'
>>> f"{trapezoidal_area(f, -4.0, 4.0, 10000):.4f}"
'384.0000'
 - Function 'f' takes 1 arguments: x.  No docstring available.

File: average_absolute_deviation.py
 - Function 'average_absolute_deviation' takes 1 arguments: nums.  Docstring: Return the average absolute deviation of a list of numbers.
Wiki: https://en.wikipedia.org/wiki/Average_absolute_deviation

>>> average_absolute_deviation([0])
0.0
>>> average_absolute_deviation([4, 1, 3, 2])
1.0
>>> average_absolute_deviation([2, 70, 6, 50, 20, 8, 4, 0])
20.0
>>> average_absolute_deviation([-20, 0, 30, 15])
16.25
>>> average_absolute_deviation([])
Traceback (most recent call last):
    ...
ValueError: List is empty

File: average_mean.py
 - Function 'mean' takes 1 arguments: nums.  Docstring: Find mean of a list of numbers.
Wiki: https://en.wikipedia.org/wiki/Mean

>>> mean([3, 6, 9, 12, 15, 18, 21])
12.0
>>> mean([5, 10, 15, 20, 25, 30, 35])
20.0
>>> mean([1, 2, 3, 4, 5, 6, 7, 8])
4.5
>>> mean([])
Traceback (most recent call last):
    ...
ValueError: List is empty

File: average_median.py
 - Function 'median' takes 1 arguments: nums.  Docstring: Find median of a list of numbers.
Wiki: https://en.wikipedia.org/wiki/Median

>>> median([0])
0
>>> median([4, 1, 3, 2])
2.5
>>> median([2, 70, 6, 50, 20, 8, 4])
8

Args:
    nums: List of nums

Returns:
    Median.
 - Function 'main' takes 0 arguments: .  No docstring available.

File: average_mode.py
 - Function 'mode' takes 1 arguments: input_list.  Docstring: This function returns the mode(Mode as in the measures of
central tendency) of the input data.

The input list may contain any Datastructure or any Datatype.

>>> mode([2, 3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 2, 2, 2])
[2]
>>> mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 2, 2, 2])
[2]
>>> mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 4, 2, 2, 4, 2])
[2, 4]
>>> mode(["x", "y", "y", "z"])
['y']
>>> mode(["x", "x" , "y", "y", "z"])
['x', 'y']

File: bailey_borwein_plouffe.py
 - Function 'bailey_borwein_plouffe' takes 2 arguments: digit_position, precision.  Docstring: Implement a popular pi-digit-extraction algorithm known as the
Bailey-Borwein-Plouffe (BBP) formula to calculate the nth hex digit of pi.
Wikipedia page:
https://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula
@param digit_position: a positive integer representing the position of the digit to
extract.
The digit immediately after the decimal point is located at position 1.
@param precision: number of terms in the second summation to calculate.
A higher number reduces the chance of an error but increases the runtime.
@return: a hexadecimal digit representing the digit at the nth position
in pi's decimal expansion.

>>> "".join(bailey_borwein_plouffe(i) for i in range(1, 11))
'243f6a8885'
>>> bailey_borwein_plouffe(5, 10000)
'6'
>>> bailey_borwein_plouffe(-10)
Traceback (most recent call last):
  ...
ValueError: Digit position must be a positive integer
>>> bailey_borwein_plouffe(0)
Traceback (most recent call last):
  ...
ValueError: Digit position must be a positive integer
>>> bailey_borwein_plouffe(1.7)
Traceback (most recent call last):
  ...
ValueError: Digit position must be a positive integer
>>> bailey_borwein_plouffe(2, -10)
Traceback (most recent call last):
  ...
ValueError: Precision must be a nonnegative integer
>>> bailey_borwein_plouffe(2, 1.6)
Traceback (most recent call last):
  ...
ValueError: Precision must be a nonnegative integer
 - Function '_subsum' takes 3 arguments: digit_pos_to_extract, denominator_addend, precision.  Docstring: Private helper function to implement the summation
functionality.
@param digit_pos_to_extract: digit position to extract
@param denominator_addend: added to denominator of fractions in the formula
@param precision: same as precision in main function
@return: floating-point number whose integer part is not important

File: base_neg2_conversion.py
 - Function 'decimal_to_negative_base_2' takes 1 arguments: num.  Docstring: This function returns the number negative base 2
    of the decimal number of the input data.

Args:
    int: The decimal number to convert.

Returns:
    int: The negative base 2 number.

Examples:
    >>> decimal_to_negative_base_2(0)
    0
    >>> decimal_to_negative_base_2(-19)
    111101
    >>> decimal_to_negative_base_2(4)
    100
    >>> decimal_to_negative_base_2(7)
    11011

File: basic_maths.py
 - Function 'prime_factors' takes 1 arguments: n.  Docstring: Find Prime Factors.
>>> prime_factors(100)
[2, 2, 5, 5]
>>> prime_factors(0)
Traceback (most recent call last):
    ...
ValueError: Only positive integers have prime factors
>>> prime_factors(-10)
Traceback (most recent call last):
    ...
ValueError: Only positive integers have prime factors
 - Function 'number_of_divisors' takes 1 arguments: n.  Docstring: Calculate Number of Divisors of an Integer.
>>> number_of_divisors(100)
9
>>> number_of_divisors(0)
Traceback (most recent call last):
    ...
ValueError: Only positive numbers are accepted
>>> number_of_divisors(-10)
Traceback (most recent call last):
    ...
ValueError: Only positive numbers are accepted
 - Function 'sum_of_divisors' takes 1 arguments: n.  Docstring: Calculate Sum of Divisors.
>>> sum_of_divisors(100)
217
>>> sum_of_divisors(0)
Traceback (most recent call last):
    ...
ValueError: Only positive numbers are accepted
>>> sum_of_divisors(-10)
Traceback (most recent call last):
    ...
ValueError: Only positive numbers are accepted
 - Function 'euler_phi' takes 1 arguments: n.  Docstring: Calculate Euler's Phi Function.
>>> euler_phi(100)
40
>>> euler_phi(0)
Traceback (most recent call last):
    ...
ValueError: Only positive numbers are accepted
>>> euler_phi(-10)
Traceback (most recent call last):
    ...
ValueError: Only positive numbers are accepted

File: binary_exponentiation.py
 - Function 'binary_exp_recursive' takes 2 arguments: base, exponent.  Docstring: Computes a^b recursively, where a is the base and b is the exponent

>>> binary_exp_recursive(3, 5)
243
>>> binary_exp_recursive(11, 13)
34522712143931
>>> binary_exp_recursive(-1, 3)
-1
>>> binary_exp_recursive(0, 5)
0
>>> binary_exp_recursive(3, 1)
3
>>> binary_exp_recursive(3, 0)
1
>>> binary_exp_recursive(1.5, 4)
5.0625
>>> binary_exp_recursive(3, -1)
Traceback (most recent call last):
    ...
ValueError: Exponent must be a non-negative integer
 - Function 'binary_exp_iterative' takes 2 arguments: base, exponent.  Docstring: Computes a^b iteratively, where a is the base and b is the exponent

>>> binary_exp_iterative(3, 5)
243
>>> binary_exp_iterative(11, 13)
34522712143931
>>> binary_exp_iterative(-1, 3)
-1
>>> binary_exp_iterative(0, 5)
0
>>> binary_exp_iterative(3, 1)
3
>>> binary_exp_iterative(3, 0)
1
>>> binary_exp_iterative(1.5, 4)
5.0625
>>> binary_exp_iterative(3, -1)
Traceback (most recent call last):
    ...
ValueError: Exponent must be a non-negative integer
 - Function 'binary_exp_mod_recursive' takes 3 arguments: base, exponent, modulus.  Docstring: Computes a^b % c recursively, where a is the base, b is the exponent, and c is the
modulus

>>> binary_exp_mod_recursive(3, 4, 5)
1
>>> binary_exp_mod_recursive(11, 13, 7)
4
>>> binary_exp_mod_recursive(1.5, 4, 3)
2.0625
>>> binary_exp_mod_recursive(7, -1, 10)
Traceback (most recent call last):
    ...
ValueError: Exponent must be a non-negative integer
>>> binary_exp_mod_recursive(7, 13, 0)
Traceback (most recent call last):
    ...
ValueError: Modulus must be a positive integer
 - Function 'binary_exp_mod_iterative' takes 3 arguments: base, exponent, modulus.  Docstring: Computes a^b % c iteratively, where a is the base, b is the exponent, and c is the
modulus

>>> binary_exp_mod_iterative(3, 4, 5)
1
>>> binary_exp_mod_iterative(11, 13, 7)
4
>>> binary_exp_mod_iterative(1.5, 4, 3)
2.0625
>>> binary_exp_mod_iterative(7, -1, 10)
Traceback (most recent call last):
    ...
ValueError: Exponent must be a non-negative integer
>>> binary_exp_mod_iterative(7, 13, 0)
Traceback (most recent call last):
    ...
ValueError: Modulus must be a positive integer

File: binary_multiplication.py
 - Function 'binary_multiply' takes 2 arguments: a, b.  Docstring: Multiply 'a' and 'b' using bitwise multiplication.

Parameters:
a (int): The first number.
b (int): The second number.

Returns:
int: a * b

Examples:
>>> binary_multiply(2, 3)
6
>>> binary_multiply(5, 0)
0
>>> binary_multiply(3, 4)
12
>>> binary_multiply(10, 5)
50
>>> binary_multiply(0, 5)
0
>>> binary_multiply(2, 1)
2
>>> binary_multiply(1, 10)
10
 - Function 'binary_mod_multiply' takes 3 arguments: a, b, modulus.  Docstring: Calculate (a * b) % c using binary multiplication and modular arithmetic.

Parameters:
a (int): The first number.
b (int): The second number.
modulus (int): The modulus.

Returns:
int: (a * b) % modulus.

Examples:
>>> binary_mod_multiply(2, 3, 5)
1
>>> binary_mod_multiply(5, 0, 7)
0
>>> binary_mod_multiply(3, 4, 6)
0
>>> binary_mod_multiply(10, 5, 13)
11
>>> binary_mod_multiply(2, 1, 5)
2
>>> binary_mod_multiply(1, 10, 3)
1

File: binomial_coefficient.py
 - Function 'binomial_coefficient' takes 2 arguments: n, r.  Docstring: Find binomial coefficient using Pascal's triangle.

Calculate C(n, r) using Pascal's triangle.

:param n: The total number of items.
:param r: The number of items to choose.
:return: The binomial coefficient C(n, r).

>>> binomial_coefficient(10, 5)
252
>>> binomial_coefficient(10, 0)
1
>>> binomial_coefficient(0, 10)
1
>>> binomial_coefficient(10, 10)
1
>>> binomial_coefficient(5, 2)
10
>>> binomial_coefficient(5, 6)
0
>>> binomial_coefficient(3, 5)
0
>>> binomial_coefficient(-2, 3)
Traceback (most recent call last):
    ...
ValueError: n and r must be non-negative integers
>>> binomial_coefficient(5, -1)
Traceback (most recent call last):
    ...
ValueError: n and r must be non-negative integers
>>> binomial_coefficient(10.1, 5)
Traceback (most recent call last):
    ...
TypeError: 'float' object cannot be interpreted as an integer
>>> binomial_coefficient(10, 5.1)
Traceback (most recent call last):
    ...
TypeError: 'float' object cannot be interpreted as an integer

File: binomial_distribution.py
 - Function 'binomial_distribution' takes 3 arguments: successes, trials, prob.  Docstring: Return probability of k successes out of n tries, with p probability for one
success

The function uses the factorial function in order to calculate the binomial
coefficient

>>> binomial_distribution(3, 5, 0.7)
0.30870000000000003
>>> binomial_distribution (2, 4, 0.5)
0.375

File: ceil.py
 - Function 'ceil' takes 1 arguments: x.  Docstring: Return the ceiling of x as an Integral.

:param x: the number
:return: the smallest integer >= x.

>>> import math
>>> all(ceil(n) == math.ceil(n) for n
...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000))
True

File: chebyshev_distance.py
 - Function 'chebyshev_distance' takes 2 arguments: point_a, point_b.  Docstring: This function calculates the Chebyshev distance (also known as the
Chessboard distance) between two n-dimensional points represented as lists.

https://en.wikipedia.org/wiki/Chebyshev_distance

>>> chebyshev_distance([1.0, 1.0], [2.0, 2.0])
1.0
>>> chebyshev_distance([1.0, 1.0, 9.0], [2.0, 2.0, -5.2])
14.2
>>> chebyshev_distance([1.0], [2.0, 2.0])
Traceback (most recent call last):
    ...
ValueError: Both points must have the same dimension.

File: check_polygon.py
 - Function 'check_polygon' takes 1 arguments: nums.  Docstring: Takes list of possible side lengths and determines whether a
two-dimensional polygon with such side lengths can exist.

Returns a boolean value for the < comparison
of the largest side length with sum of the rest.
Wiki: https://en.wikipedia.org/wiki/Triangle_inequality

>>> check_polygon([6, 10, 5])
True
>>> check_polygon([3, 7, 13, 2])
False
>>> check_polygon([1, 4.3, 5.2, 12.2])
False
>>> nums = [3, 7, 13, 2]
>>> _ = check_polygon(nums) #   Run function, do not show answer in output
>>> nums #  Check numbers are not reordered
[3, 7, 13, 2]
>>> check_polygon([])
Traceback (most recent call last):
    ...
ValueError: Monogons and Digons are not polygons in the Euclidean space
>>> check_polygon([-2, 5, 6])
Traceback (most recent call last):
    ...
ValueError: All values must be greater than 0

File: chinese_remainder_theorem.py
 - Function 'extended_euclid' takes 2 arguments: a, b.  Docstring: >>> extended_euclid(10, 6)
(-1, 2)

>>> extended_euclid(7, 5)
(-2, 3)
 - Function 'chinese_remainder_theorem' takes 4 arguments: n1, r1, n2, r2.  Docstring: >>> chinese_remainder_theorem(5,1,7,3)
31

Explanation : 31 is the smallest number such that
            (i)  When we divide it by 5, we get remainder 1
            (ii) When we divide it by 7, we get remainder 3

>>> chinese_remainder_theorem(6,1,4,3)
14
 - Function 'invert_modulo' takes 2 arguments: a, n.  Docstring: >>> invert_modulo(2, 5)
3

>>> invert_modulo(8,7)
1
 - Function 'chinese_remainder_theorem2' takes 4 arguments: n1, r1, n2, r2.  Docstring: >>> chinese_remainder_theorem2(5,1,7,3)
31

>>> chinese_remainder_theorem2(6,1,4,3)
14

File: chudnovsky_algorithm.py
 - Function 'pi' takes 1 arguments: precision.  Docstring: The Chudnovsky algorithm is a fast method for calculating the digits of PI,
based on Ramanujan's PI formulae.

https://en.wikipedia.org/wiki/Chudnovsky_algorithm

PI = constant_term / ((multinomial_term * linear_term) / exponential_term)
    where constant_term = 426880 * sqrt(10005)

The linear_term and the exponential_term can be defined iteratively as follows:
    L_k+1 = L_k + 545140134            where L_0 = 13591409
    X_k+1 = X_k * -262537412640768000  where X_0 = 1

The multinomial_term is defined as follows:
    6k! / ((3k)! * (k!) ^ 3)
        where k is the k_th iteration.

This algorithm correctly calculates around 14 digits of PI per iteration

>>> pi(10)
'3.14159265'
>>> pi(100)
'3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706'
>>> pi('hello')
Traceback (most recent call last):
    ...
TypeError: Undefined for non-integers
>>> pi(-1)
Traceback (most recent call last):
    ...
ValueError: Undefined for non-natural numbers

File: collatz_sequence.py
 - Function 'collatz_sequence' takes 1 arguments: n.  Docstring: Generate the Collatz sequence starting at n.
>>> tuple(collatz_sequence(2.1))
Traceback (most recent call last):
    ...
Exception: Sequence only defined for positive integers
>>> tuple(collatz_sequence(0))
Traceback (most recent call last):
    ...
Exception: Sequence only defined for positive integers
>>> tuple(collatz_sequence(4))
(4, 2, 1)
>>> tuple(collatz_sequence(11))
(11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1)
>>> tuple(collatz_sequence(31))     # doctest: +NORMALIZE_WHITESPACE
(31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137,
412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593,
1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425,
1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644,
1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732,
866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53,
160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1)
>>> tuple(collatz_sequence(43))     # doctest: +NORMALIZE_WHITESPACE
(43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26,
13, 40, 20, 10, 5, 16, 8, 4, 2, 1)
 - Function 'main' takes 0 arguments: .  No docstring available.

File: combinations.py
 - Function 'combinations' takes 2 arguments: n, k.  Docstring: Returns the number of different combinations of k length which can
be made from n values, where n >= k.

Examples:
>>> combinations(10,5)
252

>>> combinations(6,3)
20

>>> combinations(20,5)
15504

>>> combinations(52, 5)
2598960

>>> combinations(0, 0)
1

>>> combinations(-4, -5)
...
Traceback (most recent call last):
ValueError: Please enter positive integers for n and k where n >= k

File: continued_fraction.py
 - Function 'continued_fraction' takes 1 arguments: num.  Docstring: :param num:
Fraction of the number whose continued fractions to be found.
Use Fraction(str(number)) for more accurate results due to
float inaccuracies.

:return:
The continued fraction of rational number.
It is the all commas in the (n + 1)-tuple notation.

>>> continued_fraction(Fraction(2))
[2]
>>> continued_fraction(Fraction("3.245"))
[3, 4, 12, 4]
>>> continued_fraction(Fraction("2.25"))
[2, 4]
>>> continued_fraction(1/Fraction("2.25"))
[0, 2, 4]
>>> continued_fraction(Fraction("415/93"))
[4, 2, 6, 7]
>>> continued_fraction(Fraction(0))
[0]
>>> continued_fraction(Fraction(0.75))
[0, 1, 3]
>>> continued_fraction(Fraction("-2.25"))    # -2.25 = -3 + 0.75
[-3, 1, 3]

File: decimal_isolate.py
 - Function 'decimal_isolate' takes 2 arguments: number, digit_amount.  Docstring: Isolates the decimal part of a number.
If digitAmount > 0 round to that decimal place, else print the entire decimal.
>>> decimal_isolate(1.53, 0)
0.53
>>> decimal_isolate(35.345, 1)
0.3
>>> decimal_isolate(35.345, 2)
0.34
>>> decimal_isolate(35.345, 3)
0.345
>>> decimal_isolate(-14.789, 3)
-0.789
>>> decimal_isolate(0, 2)
0
>>> decimal_isolate(-14.123, 1)
-0.1
>>> decimal_isolate(-14.123, 2)
-0.12
>>> decimal_isolate(-14.123, 3)
-0.123

File: decimal_to_fraction.py
 - Function 'decimal_to_fraction' takes 1 arguments: decimal.  Docstring: Return a decimal number in its simplest fraction form
>>> decimal_to_fraction(2)
(2, 1)
>>> decimal_to_fraction(89.)
(89, 1)
>>> decimal_to_fraction("67")
(67, 1)
>>> decimal_to_fraction("45.0")
(45, 1)
>>> decimal_to_fraction(1.5)
(3, 2)
>>> decimal_to_fraction("6.25")
(25, 4)
>>> decimal_to_fraction("78td")
Traceback (most recent call last):
ValueError: Please enter a valid number

File: dodecahedron.py
 - Function 'dodecahedron_surface_area' takes 1 arguments: edge.  Docstring: Calculates the surface area of a regular dodecahedron
a = 3 * ((25 + 10 * (5** (1 / 2))) ** (1 / 2 )) * (e**2)
where:
a --> is the area of the dodecahedron
e --> is the length of the edge
reference-->"Dodecahedron" Study.com
<https://study.com/academy/lesson/dodecahedron-volume-surface-area-formulas.html>

:param edge: length of the edge of the dodecahedron
:type edge: float
:return: the surface area of the dodecahedron as a float


Tests:
>>> dodecahedron_surface_area(5)
516.1432201766901
>>> dodecahedron_surface_area(10)
2064.5728807067603
>>> dodecahedron_surface_area(-1)
Traceback (most recent call last):
  ...
ValueError: Length must be a positive.
 - Function 'dodecahedron_volume' takes 1 arguments: edge.  Docstring: Calculates the volume of a regular dodecahedron
v = ((15 + (7 * (5** (1 / 2)))) / 4) * (e**3)
where:
v --> is the volume of the dodecahedron
e --> is the length of the edge
reference-->"Dodecahedron" Study.com
<https://study.com/academy/lesson/dodecahedron-volume-surface-area-formulas.html>

:param edge: length of the edge of the dodecahedron
:type edge: float
:return: the volume of the dodecahedron as a float

Tests:
>>> dodecahedron_volume(5)
957.8898700780791
>>> dodecahedron_volume(10)
7663.118960624633
>>> dodecahedron_volume(-1)
Traceback (most recent call last):
  ...
ValueError: Length must be a positive.

File: double_factorial.py
 - Function 'double_factorial_recursive' takes 1 arguments: n.  Docstring: Compute double factorial using recursive method.
Recursion can be costly for large numbers.

To learn about the theory behind this algorithm:
https://en.wikipedia.org/wiki/Double_factorial

>>> from math import prod
>>> all(double_factorial_recursive(i) == prod(range(i, 0, -2)) for i in range(20))
True
>>> double_factorial_recursive(0.1)
Traceback (most recent call last):
    ...
ValueError: double_factorial_recursive() only accepts integral values
>>> double_factorial_recursive(-1)
Traceback (most recent call last):
    ...
ValueError: double_factorial_recursive() not defined for negative values
 - Function 'double_factorial_iterative' takes 1 arguments: num.  Docstring: Compute double factorial using iterative method.

To learn about the theory behind this algorithm:
https://en.wikipedia.org/wiki/Double_factorial

>>> from math import prod
>>> all(double_factorial_iterative(i) == prod(range(i, 0, -2)) for i in range(20))
True
>>> double_factorial_iterative(0.1)
Traceback (most recent call last):
    ...
ValueError: double_factorial_iterative() only accepts integral values
>>> double_factorial_iterative(-1)
Traceback (most recent call last):
    ...
ValueError: double_factorial_iterative() not defined for negative values

File: dual_number_automatic_differentiation.py
 - Function '__init__' takes 3 arguments: self, real, rank.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function 'reduce' takes 1 arguments: self.  No docstring available.
 - Function '__add__' takes 2 arguments: self, other.  No docstring available.
 - Function '__sub__' takes 2 arguments: self, other.  No docstring available.
 - Function '__mul__' takes 2 arguments: self, other.  No docstring available.
 - Function '__truediv__' takes 2 arguments: self, other.  No docstring available.
 - Function '__floordiv__' takes 2 arguments: self, other.  No docstring available.
 - Function '__pow__' takes 2 arguments: self, n.  No docstring available.
 - Function 'differentiate' takes 3 arguments: func, position, order.  Docstring: >>> differentiate(lambda x: x**2, 2, 2)
2
>>> differentiate(lambda x: x**2 * x**4, 9, 2)
196830
>>> differentiate(lambda y: 0.5 * (y + 3) ** 6, 3.5, 4)
7605.0
>>> differentiate(lambda y: y ** 2, 4, 3)
0
>>> differentiate(8, 8, 8)
Traceback (most recent call last):
    ...
ValueError: differentiate() requires a function as input for func
>>> differentiate(lambda x: x **2, "", 1)
Traceback (most recent call last):
    ...
ValueError: differentiate() requires a float as input for position
>>> differentiate(lambda x: x**2, 3, "")
Traceback (most recent call last):
    ...
ValueError: differentiate() requires an int as input for order
 - Function 'f' takes 1 arguments: y.  No docstring available.

File: entropy.py
 - Function 'calculate_prob' takes 1 arguments: text.  Docstring: This method takes path and two dict as argument
and than calculates entropy of them.
:param dict:
:param dict:
:return: Prints
1) Entropy of information based on 1 alphabet
2) Entropy of information based on couples of 2 alphabet
3) print Entropy of H(X n|Xn-1)

Text from random books. Also, random quotes.
>>> text = ("Behind Winston's back the voice "
...         "from the telescreen was still "
...         "babbling and the overfulfilment")
>>> calculate_prob(text)
4.0
6.0
2.0

>>> text = ("The Ministry of TruthMinitrue, in Newspeak [Newspeak was the official"
...         "face in elegant lettering, the three")
>>> calculate_prob(text)
4.0
5.0
1.0
>>> text = ("Had repulsive dashwoods suspicion sincerity but advantage now him. "
...         "Remark easily garret nor nay.  Civil those mrs enjoy shy fat merry. "
...         "You greatest jointure saw horrible. He private he on be imagine "
...         "suppose. Fertile beloved evident through no service elderly is. Blind "
...         "there if every no so at. Own neglected you preferred way sincerity "
...         "delivered his attempted. To of message cottage windows do besides "
...         "against uncivil.  Delightful unreserved impossible few estimating "
...         "men favourable see entreaties. She propriety immediate was improving. "
...         "He or entrance humoured likewise moderate. Much nor game son say "
...         "feel. Fat make met can must form into gate. Me we offending prevailed "
...         "discovery.")
>>> calculate_prob(text)
4.0
7.0
3.0
 - Function 'analyze_text' takes 1 arguments: text.  Docstring: Convert text input into two dicts of counts.
The first dictionary stores the frequency of single character strings.
The second dictionary stores the frequency of two character strings.
 - Function 'main' takes 0 arguments: .  No docstring available.

File: euclidean_distance.py
 - Function 'euclidean_distance' takes 2 arguments: vector_1, vector_2.  Docstring: Calculate the distance between the two endpoints of two vectors.
A vector is defined as a list, tuple, or numpy 1D array.
>>> euclidean_distance((0, 0), (2, 2))
2.8284271247461903
>>> euclidean_distance(np.array([0, 0, 0]), np.array([2, 2, 2]))
3.4641016151377544
>>> euclidean_distance(np.array([1, 2, 3, 4]), np.array([5, 6, 7, 8]))
8.0
>>> euclidean_distance([1, 2, 3, 4], [5, 6, 7, 8])
8.0
 - Function 'euclidean_distance_no_np' takes 2 arguments: vector_1, vector_2.  Docstring: Calculate the distance between the two endpoints of two vectors without numpy.
A vector is defined as a list, tuple, or numpy 1D array.
>>> euclidean_distance_no_np((0, 0), (2, 2))
2.8284271247461903
>>> euclidean_distance_no_np([1, 2, 3, 4], [5, 6, 7, 8])
8.0
 - Function 'benchmark' takes 0 arguments: .  Docstring: Benchmarks

File: eulers_totient.py
 - Function 'totient' takes 1 arguments: n.  Docstring: >>> n = 10
>>> totient_calculation = totient(n)
>>> for i in range(1, n):
...     print(f"{i} has {totient_calculation[i]} relative primes.")
1 has 0 relative primes.
2 has 1 relative primes.
3 has 2 relative primes.
4 has 2 relative primes.
5 has 4 relative primes.
6 has 2 relative primes.
7 has 6 relative primes.
8 has 4 relative primes.
9 has 6 relative primes.

File: euler_method.py
 - Function 'explicit_euler' takes 5 arguments: ode_func, y0, x0, step_size, x_end.  Docstring: Calculate numeric solution at each step to an ODE using Euler's Method

For reference to Euler's method refer to https://en.wikipedia.org/wiki/Euler_method.

Args:
    ode_func (Callable):  The ordinary differential equation
        as a function of x and y.
    y0 (float): The initial value for y.
    x0 (float): The initial value for x.
    step_size (float): The increment value for x.
    x_end (float): The final value of x to be calculated.

Returns:
    np.ndarray: Solution of y for every step in x.

>>> # the exact solution is math.exp(x)
>>> def f(x, y):
...     return y
>>> y0 = 1
>>> y = explicit_euler(f, y0, 0.0, 0.01, 5)
>>> y[-1]
144.77277243257308

File: euler_modified.py
 - Function 'euler_modified' takes 5 arguments: ode_func, y0, x0, step_size, x_end.  Docstring: Calculate solution at each step to an ODE using Euler's Modified Method
The Euler Method is straightforward to implement, but can't give accurate solutions.
So, some changes were proposed to improve accuracy.

https://en.wikipedia.org/wiki/Euler_method

Arguments:
ode_func -- The ode as a function of x and y
y0 -- the initial value for y
x0 -- the initial value for x
stepsize -- the increment value for x
x_end -- the end value for x

>>> # the exact solution is math.exp(x)
>>> def f1(x, y):
...     return -2*x*(y**2)
>>> y = euler_modified(f1, 1.0, 0.0, 0.2, 1.0)
>>> y[-1]
0.503338255442106
>>> import math
>>> def f2(x, y):
...     return -2*y + (x**3)*math.exp(-2*x)
>>> y = euler_modified(f2, 1.0, 0.0, 0.1, 0.3)
>>> y[-1]
0.5525976431951775

File: extended_euclidean_algorithm.py
 - Function 'extended_euclidean_algorithm' takes 2 arguments: a, b.  Docstring: Extended Euclidean Algorithm.

Finds 2 numbers a and b such that it satisfies
the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)

>>> extended_euclidean_algorithm(1, 24)
(1, 0)

>>> extended_euclidean_algorithm(8, 14)
(2, -1)

>>> extended_euclidean_algorithm(240, 46)
(-9, 47)

>>> extended_euclidean_algorithm(1, -4)
(1, 0)

>>> extended_euclidean_algorithm(-2, -4)
(-1, 0)

>>> extended_euclidean_algorithm(0, -4)
(0, -1)

>>> extended_euclidean_algorithm(2, 0)
(1, 0)
 - Function 'main' takes 0 arguments: .  Docstring: Call Extended Euclidean Algorithm.

File: factors.py
 - Function 'factors_of_a_number' takes 1 arguments: num.  Docstring: >>> factors_of_a_number(1)
[1]
>>> factors_of_a_number(5)
[1, 5]
>>> factors_of_a_number(24)
[1, 2, 3, 4, 6, 8, 12, 24]
>>> factors_of_a_number(-24)
[]

File: fast_inverse_sqrt.py
 - Function 'fast_inverse_sqrt' takes 1 arguments: number.  Docstring: Compute the fast inverse square root of a floating-point number using the famous
Quake III algorithm.

:param float number: Input number for which to calculate the inverse square root.
:return float: The fast inverse square root of the input number.

Example:
>>> fast_inverse_sqrt(10)
0.3156857923527257
>>> fast_inverse_sqrt(4)
0.49915357479239103
>>> fast_inverse_sqrt(4.1)
0.4932849504615651
>>> fast_inverse_sqrt(0)
Traceback (most recent call last):
    ...
ValueError: Input must be a positive number.
>>> fast_inverse_sqrt(-1)
Traceback (most recent call last):
    ...
ValueError: Input must be a positive number.
>>> from math import isclose, sqrt
>>> all(isclose(fast_inverse_sqrt(i), 1 / sqrt(i), rel_tol=0.00132)
...     for i in range(50, 60))
True

File: fermat_little_theorem.py
 - Function 'binary_exponentiation' takes 3 arguments: a, n, mod.  No docstring available.

File: find_max.py
 - Function 'find_max_iterative' takes 1 arguments: nums.  Docstring: >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):
...     find_max_iterative(nums) == max(nums)
True
True
True
True
>>> find_max_iterative([2, 4, 9, 7, 19, 94, 5])
94
>>> find_max_iterative([])
Traceback (most recent call last):
    ...
ValueError: find_max_iterative() arg is an empty sequence
 - Function 'find_max_recursive' takes 3 arguments: nums, left, right.  Docstring: find max value in list
:param nums: contains elements
:param left: index of first element
:param right: index of last element
:return: max in nums

>>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):
...     find_max_recursive(nums, 0, len(nums) - 1) == max(nums)
True
True
True
True
>>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
>>> find_max_recursive(nums, 0, len(nums) - 1) == max(nums)
True
>>> find_max_recursive([], 0, 0)
Traceback (most recent call last):
    ...
ValueError: find_max_recursive() arg is an empty sequence
>>> find_max_recursive(nums, 0, len(nums)) == max(nums)
Traceback (most recent call last):
    ...
IndexError: list index out of range
>>> find_max_recursive(nums, -len(nums), -1) == max(nums)
True
>>> find_max_recursive(nums, -len(nums) - 1, -1) == max(nums)
Traceback (most recent call last):
    ...
IndexError: list index out of range

File: find_min.py
 - Function 'find_min_iterative' takes 1 arguments: nums.  Docstring: Find Minimum Number in a List
:param nums: contains elements
:return: min number in list

>>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):
...     find_min_iterative(nums) == min(nums)
True
True
True
True
>>> find_min_iterative([0, 1, 2, 3, 4, 5, -3, 24, -56])
-56
>>> find_min_iterative([])
Traceback (most recent call last):
    ...
ValueError: find_min_iterative() arg is an empty sequence
 - Function 'find_min_recursive' takes 3 arguments: nums, left, right.  Docstring: find min value in list
:param nums: contains elements
:param left: index of first element
:param right: index of last element
:return: min in nums

>>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):
...     find_min_recursive(nums, 0, len(nums) - 1) == min(nums)
True
True
True
True
>>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
>>> find_min_recursive(nums, 0, len(nums) - 1) == min(nums)
True
>>> find_min_recursive([], 0, 0)
Traceback (most recent call last):
    ...
ValueError: find_min_recursive() arg is an empty sequence
>>> find_min_recursive(nums, 0, len(nums)) == min(nums)
Traceback (most recent call last):
    ...
IndexError: list index out of range
>>> find_min_recursive(nums, -len(nums), -1) == min(nums)
True
>>> find_min_recursive(nums, -len(nums) - 1, -1) == min(nums)
Traceback (most recent call last):
    ...
IndexError: list index out of range

File: floor.py
 - Function 'floor' takes 1 arguments: x.  Docstring: Return the floor of x as an Integral.
:param x: the number
:return: the largest integer <= x.
>>> import math
>>> all(floor(n) == math.floor(n) for n
...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000))
True

File: gamma.py
 - Function 'gamma_iterative' takes 1 arguments: num.  Docstring: Calculates the value of Gamma function of num
where num is either an integer (1, 2, 3..) or a half-integer (0.5, 1.5, 2.5 ...).

>>> gamma_iterative(-1)
Traceback (most recent call last):
    ...
ValueError: math domain error
>>> gamma_iterative(0)
Traceback (most recent call last):
    ...
ValueError: math domain error
>>> gamma_iterative(9)
40320.0
>>> from math import gamma as math_gamma
>>> all(.99999999 < gamma_iterative(i) / math_gamma(i) <= 1.000000001
...     for i in range(1, 50))
True
>>> gamma_iterative(-1)/math_gamma(-1) <= 1.000000001
Traceback (most recent call last):
    ...
ValueError: math domain error
>>> gamma_iterative(3.3) - math_gamma(3.3) <= 0.00000001
True
 - Function 'integrand' takes 2 arguments: x, z.  No docstring available.
 - Function 'gamma_recursive' takes 1 arguments: num.  Docstring: Calculates the value of Gamma function of num
where num is either an integer (1, 2, 3..) or a half-integer (0.5, 1.5, 2.5 ...).
Implemented using recursion
Examples:
>>> from math import isclose, gamma as math_gamma
>>> gamma_recursive(0.5)
1.7724538509055159
>>> gamma_recursive(1)
1.0
>>> gamma_recursive(2)
1.0
>>> gamma_recursive(3.5)
3.3233509704478426
>>> gamma_recursive(171.5)
9.483367566824795e+307
>>> all(isclose(gamma_recursive(num), math_gamma(num))
...     for num in (0.5, 2, 3.5, 171.5))
True
>>> gamma_recursive(0)
Traceback (most recent call last):
    ...
ValueError: math domain error
>>> gamma_recursive(-1.1)
Traceback (most recent call last):
    ...
ValueError: math domain error
>>> gamma_recursive(-4)
Traceback (most recent call last):
    ...
ValueError: math domain error
>>> gamma_recursive(172)
Traceback (most recent call last):
    ...
OverflowError: math range error
>>> gamma_recursive(1.1)
Traceback (most recent call last):
    ...
NotImplementedError: num must be an integer or a half-integer

File: gaussian.py
 - Function 'gaussian' takes 3 arguments: x, mu, sigma.  Docstring: >>> gaussian(1)
0.24197072451914337

>>> gaussian(24)
3.342714441794458e-126

>>> gaussian(1, 4, 2)
0.06475879783294587

>>> gaussian(1, 5, 3)
0.05467002489199788

Supports NumPy Arrays
Use numpy.meshgrid with this to generate gaussian blur on images.
>>> import numpy as np
>>> x = np.arange(15)
>>> gaussian(x)
array([3.98942280e-01, 2.41970725e-01, 5.39909665e-02, 4.43184841e-03,
       1.33830226e-04, 1.48671951e-06, 6.07588285e-09, 9.13472041e-12,
       5.05227108e-15, 1.02797736e-18, 7.69459863e-23, 2.11881925e-27,
       2.14638374e-32, 7.99882776e-38, 1.09660656e-43])

>>> gaussian(15)
5.530709549844416e-50

>>> gaussian([1,2, 'string'])
Traceback (most recent call last):
    ...
TypeError: unsupported operand type(s) for -: 'list' and 'float'

>>> gaussian('hello world')
Traceback (most recent call last):
    ...
TypeError: unsupported operand type(s) for -: 'str' and 'float'

>>> gaussian(10**234) # doctest: +IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
    ...
OverflowError: (34, 'Result too large')

>>> gaussian(10**-326)
0.3989422804014327

>>> gaussian(2523, mu=234234, sigma=3425)
0.0

File: gcd_of_n_numbers.py
 - Function 'get_factors' takes 3 arguments: number, factors, factor.  Docstring: this is a recursive function for get all factors of number
>>> get_factors(45)
Counter({3: 2, 5: 1})
>>> get_factors(2520)
Counter({2: 3, 3: 2, 5: 1, 7: 1})
>>> get_factors(23)
Counter({23: 1})
>>> get_factors(0)
Traceback (most recent call last):
    ...
TypeError: number must be integer and greater than zero
>>> get_factors(-1)
Traceback (most recent call last):
    ...
TypeError: number must be integer and greater than zero
>>> get_factors(1.5)
Traceback (most recent call last):
    ...
TypeError: number must be integer and greater than zero

factor can be all numbers from 2 to number that we check if number % factor == 0
if it is equal to zero, we check again with number // factor
else we increase factor by one
 - Function 'get_greatest_common_divisor' takes 0 arguments: .  Docstring: get gcd of n numbers:
>>> get_greatest_common_divisor(18, 45)
9
>>> get_greatest_common_divisor(23, 37)
1
>>> get_greatest_common_divisor(2520, 8350)
10
>>> get_greatest_common_divisor(-10, 20)
Traceback (most recent call last):
    ...
Exception: numbers must be integer and greater than zero
>>> get_greatest_common_divisor(1.5, 2)
Traceback (most recent call last):
    ...
Exception: numbers must be integer and greater than zero
>>> get_greatest_common_divisor(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
1
>>> get_greatest_common_divisor("1", 2, 3, 4, 5, 6, 7, 8, 9, 10)
Traceback (most recent call last):
    ...
Exception: numbers must be integer and greater than zero

File: germain_primes.py
 - Function 'is_germain_prime' takes 1 arguments: number.  Docstring: Checks if input number and 2*number + 1 are prime.

>>> is_germain_prime(3)
True
>>> is_germain_prime(11)
True
>>> is_germain_prime(4)
False
>>> is_germain_prime(23)
True
>>> is_germain_prime(13)
False
>>> is_germain_prime(20)
False
>>> is_germain_prime('abc')
Traceback (most recent call last):
    ...
TypeError: Input value must be a positive integer. Input value: abc
 - Function 'is_safe_prime' takes 1 arguments: number.  Docstring: Checks if input number and (number - 1)/2 are prime.
The smallest safe prime is 5, with the Germain prime is 2.

>>> is_safe_prime(5)
True
>>> is_safe_prime(11)
True
>>> is_safe_prime(1)
False
>>> is_safe_prime(2)
False
>>> is_safe_prime(3)
False
>>> is_safe_prime(47)
True
>>> is_safe_prime('abc')
Traceback (most recent call last):
    ...
TypeError: Input value must be a positive integer. Input value: abc

File: greatest_common_divisor.py
 - Function 'greatest_common_divisor' takes 2 arguments: a, b.  Docstring: Calculate Greatest Common Divisor (GCD).
>>> greatest_common_divisor(24, 40)
8
>>> greatest_common_divisor(1, 1)
1
>>> greatest_common_divisor(1, 800)
1
>>> greatest_common_divisor(11, 37)
1
>>> greatest_common_divisor(3, 5)
1
>>> greatest_common_divisor(16, 4)
4
>>> greatest_common_divisor(-3, 9)
3
>>> greatest_common_divisor(9, -3)
3
>>> greatest_common_divisor(3, -9)
3
>>> greatest_common_divisor(-3, -9)
3
 - Function 'gcd_by_iterative' takes 2 arguments: x, y.  Docstring: Below method is more memory efficient because it does not create additional
stack frames for recursive functions calls (as done in the above method).
>>> gcd_by_iterative(24, 40)
8
>>> greatest_common_divisor(24, 40) == gcd_by_iterative(24, 40)
True
>>> gcd_by_iterative(-3, -9)
3
>>> gcd_by_iterative(3, -9)
3
>>> gcd_by_iterative(1, -800)
1
>>> gcd_by_iterative(11, 37)
1
 - Function 'main' takes 0 arguments: .  Docstring: Call Greatest Common Divisor function.

File: hardy_ramanujanalgo.py
 - Function 'exact_prime_factor_count' takes 1 arguments: n.  Docstring: >>> exact_prime_factor_count(51242183)
3

File: integer_square_root.py
 - Function 'integer_square_root' takes 1 arguments: num.  Docstring: Returns the integer square root of a non-negative integer num.
Args:
    num: A non-negative integer.
Returns:
    The integer square root of num.
Raises:
    ValueError: If num is not an integer or is negative.
>>> [integer_square_root(i) for i in range(18)]
[0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4]
>>> integer_square_root(625)
25
>>> integer_square_root(2_147_483_647)
46340
>>> from math import isqrt
>>> all(integer_square_root(i) == isqrt(i) for i in range(20))
True
>>> integer_square_root(-1)
Traceback (most recent call last):
    ...
ValueError: num must be non-negative integer
>>> integer_square_root(1.5)
Traceback (most recent call last):
    ...
ValueError: num must be non-negative integer
>>> integer_square_root("0")
Traceback (most recent call last):
    ...
ValueError: num must be non-negative integer

File: interquartile_range.py
 - Function 'find_median' takes 1 arguments: nums.  Docstring: This is the implementation of the median.
:param nums: The list of numeric nums
:return: Median of the list
>>> find_median(nums=([1, 2, 2, 3, 4]))
2
>>> find_median(nums=([1, 2, 2, 3, 4, 4]))
2.5
>>> find_median(nums=([-1, 2, 0, 3, 4, -4]))
1.5
>>> find_median(nums=([1.1, 2.2, 2, 3.3, 4.4, 4]))
2.65
 - Function 'interquartile_range' takes 1 arguments: nums.  Docstring: Return the interquartile range for a list of numeric values.
:param nums: The list of numeric values.
:return: interquartile range

>>> interquartile_range(nums=[4, 1, 2, 3, 2])
2.0
>>> interquartile_range(nums = [-2, -7, -10, 9, 8, 4, -67, 45])
17.0
>>> interquartile_range(nums = [-2.1, -7.1, -10.1, 9.1, 8.1, 4.1, -67.1, 45.1])
17.2
>>> interquartile_range(nums = [0, 0, 0, 0, 0])
0.0
>>> interquartile_range(nums=[])
Traceback (most recent call last):
...
ValueError: The list is empty. Provide a non-empty list.

File: is_int_palindrome.py
 - Function 'is_int_palindrome' takes 1 arguments: num.  Docstring: Returns whether `num` is a palindrome or not
(see for reference https://en.wikipedia.org/wiki/Palindromic_number).

>>> is_int_palindrome(-121)
False
>>> is_int_palindrome(0)
True
>>> is_int_palindrome(10)
False
>>> is_int_palindrome(11)
True
>>> is_int_palindrome(101)
True
>>> is_int_palindrome(120)
False

File: is_ip_v4_address_valid.py
 - Function 'is_ip_v4_address_valid' takes 1 arguments: ip_v4_address.  Docstring: print "Valid IP address" If IP is valid.
or
print "Invalid IP address" If IP is invalid.

>>> is_ip_v4_address_valid("192.168.0.23")
True

>>> is_ip_v4_address_valid("192.255.15.8")
False

>>> is_ip_v4_address_valid("172.100.0.8")
True

>>> is_ip_v4_address_valid("254.255.0.255")
False

>>> is_ip_v4_address_valid("1.2.33333333.4")
False

>>> is_ip_v4_address_valid("1.2.-3.4")
False

>>> is_ip_v4_address_valid("1.2.3")
False

>>> is_ip_v4_address_valid("1.2.3.4.5")
False

>>> is_ip_v4_address_valid("1.2.A.4")
False

>>> is_ip_v4_address_valid("0.0.0.0")
True

>>> is_ip_v4_address_valid("1.2.3.")
False

File: is_square_free.py
 - Function 'is_square_free' takes 1 arguments: factors.  Docstring: # doctest: +NORMALIZE_WHITESPACE
This functions takes a list of prime factors as input.
returns True if the factors are square free.
>>> is_square_free([1, 1, 2, 3, 4])
False

These are wrong but should return some value
it simply checks for repetition in the numbers.
>>> is_square_free([1, 3, 4, 'sd', 0.0])
True

>>> is_square_free([1, 0.5, 2, 0.0])
True
>>> is_square_free([1, 2, 2, 5])
False
>>> is_square_free('asd')
True
>>> is_square_free(24)
Traceback (most recent call last):
    ...
TypeError: 'int' object is not iterable

File: jaccard_similarity.py
 - Function 'jaccard_similarity' takes 3 arguments: set_a, set_b, alternative_union.  Docstring: Finds the jaccard similarity between two sets.
Essentially, its intersection over union.

The alternative way to calculate this is to take union as sum of the
number of items in the two sets. This will lead to jaccard similarity
of a set with itself be 1/2 instead of 1. [MMDS 2nd Edition, Page 77]

Parameters:
    :set_a (set,list,tuple): A non-empty set/list
    :set_b (set,list,tuple): A non-empty set/list
    :alternativeUnion (boolean): If True, use sum of number of
    items as union

Output:
    (float) The jaccard similarity between the two sets.

Examples:
>>> set_a = {'a', 'b', 'c', 'd', 'e'}
>>> set_b = {'c', 'd', 'e', 'f', 'h', 'i'}
>>> jaccard_similarity(set_a, set_b)
0.375
>>> jaccard_similarity(set_a, set_a)
1.0
>>> jaccard_similarity(set_a, set_a, True)
0.5
>>> set_a = ['a', 'b', 'c', 'd', 'e']
>>> set_b = ('c', 'd', 'e', 'f', 'h', 'i')
>>> jaccard_similarity(set_a, set_b)
0.375
>>> set_a = ('c', 'd', 'e', 'f', 'h', 'i')
>>> set_b = ['a', 'b', 'c', 'd', 'e']
>>> jaccard_similarity(set_a, set_b)
0.375
>>> set_a = ('c', 'd', 'e', 'f', 'h', 'i')
>>> set_b = ['a', 'b', 'c', 'd']
>>> jaccard_similarity(set_a, set_b, True)
0.2
>>> set_a = {'a', 'b'}
>>> set_b = ['c', 'd']
>>> jaccard_similarity(set_a, set_b)
Traceback (most recent call last):
    ...
ValueError: Set a and b must either both be sets or be either a list or a tuple.

File: joint_probability_distribution.py
 - Function 'joint_probability_distribution' takes 4 arguments: x_values, y_values, x_probabilities, y_probabilities.  Docstring: >>> joint_distribution =  joint_probability_distribution(
...     [1, 2], [-2, 5, 8], [0.7, 0.3], [0.3, 0.5, 0.2]
... )
>>> from math import isclose
>>> isclose(joint_distribution.pop((1, 8)), 0.14)
True
>>> joint_distribution
{(1, -2): 0.21, (1, 5): 0.35, (2, -2): 0.09, (2, 5): 0.15, (2, 8): 0.06}
 - Function 'expectation' takes 2 arguments: values, probabilities.  Docstring: >>> from math import isclose
>>> isclose(expectation([1, 2], [0.7, 0.3]), 1.3)
True
 - Function 'variance' takes 2 arguments: values, probabilities.  Docstring: >>> from math import isclose
>>> isclose(variance([1,2],[0.7,0.3]), 0.21)
True
 - Function 'covariance' takes 4 arguments: x_values, y_values, x_probabilities, y_probabilities.  Docstring: >>> covariance([1, 2], [-2, 5, 8], [0.7, 0.3], [0.3, 0.5, 0.2])
-2.7755575615628914e-17
 - Function 'standard_deviation' takes 1 arguments: variance.  Docstring: >>> standard_deviation(0.21)
0.458257569495584

File: josephus_problem.py
 - Function 'josephus_recursive' takes 2 arguments: num_people, step_size.  Docstring: Solve the Josephus problem for num_people and a step_size recursively.

Args:
    num_people: A positive integer representing the number of people.
    step_size: A positive integer representing the step size for elimination.

Returns:
    The position of the last person remaining.

Raises:
    ValueError: If num_people or step_size is not a positive integer.

Examples:
    >>> josephus_recursive(7, 3)
    3
    >>> josephus_recursive(10, 2)
    4
    >>> josephus_recursive(0, 2)
    Traceback (most recent call last):
        ...
    ValueError: num_people or step_size is not a positive integer.
    >>> josephus_recursive(1.9, 2)
    Traceback (most recent call last):
        ...
    ValueError: num_people or step_size is not a positive integer.
    >>> josephus_recursive(-2, 2)
    Traceback (most recent call last):
        ...
    ValueError: num_people or step_size is not a positive integer.
    >>> josephus_recursive(7, 0)
    Traceback (most recent call last):
        ...
    ValueError: num_people or step_size is not a positive integer.
    >>> josephus_recursive(7, -2)
    Traceback (most recent call last):
        ...
    ValueError: num_people or step_size is not a positive integer.
    >>> josephus_recursive(1_000, 0.01)
    Traceback (most recent call last):
        ...
    ValueError: num_people or step_size is not a positive integer.
    >>> josephus_recursive("cat", "dog")
    Traceback (most recent call last):
        ...
    ValueError: num_people or step_size is not a positive integer.
 - Function 'find_winner' takes 2 arguments: num_people, step_size.  Docstring: Find the winner of the Josephus problem for num_people and a step_size.

Args:
    num_people (int): Number of people.
    step_size (int): Step size for elimination.

Returns:
    int: The position of the last person remaining (1-based index).

Examples:
    >>> find_winner(7, 3)
    4
    >>> find_winner(10, 2)
    5
 - Function 'josephus_iterative' takes 2 arguments: num_people, step_size.  Docstring: Solve the Josephus problem for num_people and a step_size iteratively.

Args:
    num_people (int): The number of people in the circle.
    step_size (int): The number of steps to take before eliminating someone.

Returns:
    int: The position of the last person standing.

Examples:
    >>> josephus_iterative(5, 2)
    3
    >>> josephus_iterative(7, 3)
    4

File: juggler_sequence.py
 - Function 'juggler_sequence' takes 1 arguments: number.  Docstring: >>> juggler_sequence(0)
Traceback (most recent call last):
    ...
ValueError: Input value of [number=0] must be a positive integer
>>> juggler_sequence(1)
[1]
>>> juggler_sequence(2)
[2, 1]
>>> juggler_sequence(3)
[3, 5, 11, 36, 6, 2, 1]
>>> juggler_sequence(5)
[5, 11, 36, 6, 2, 1]
>>> juggler_sequence(10)
[10, 3, 5, 11, 36, 6, 2, 1]
>>> juggler_sequence(25)
[25, 125, 1397, 52214, 228, 15, 58, 7, 18, 4, 2, 1]
>>> juggler_sequence(6.0)
Traceback (most recent call last):
    ...
TypeError: Input value of [number=6.0] must be an integer
>>> juggler_sequence(-1)
Traceback (most recent call last):
    ...
ValueError: Input value of [number=-1] must be a positive integer

File: karatsuba.py
 - Function 'karatsuba' takes 2 arguments: a, b.  Docstring: >>> karatsuba(15463, 23489) == 15463 * 23489
True
>>> karatsuba(3, 9) == 3 * 9
True
 - Function 'main' takes 0 arguments: .  No docstring available.

File: kth_lexicographic_permutation.py
 - Function 'kth_permutation' takes 2 arguments: k, n.  Docstring: Finds k'th lexicographic permutation (in increasing order) of
0,1,2,...n-1 in O(n^2) time.

Examples:
First permutation is always 0,1,2,...n
>>> kth_permutation(0,5)
[0, 1, 2, 3, 4]

The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],
[0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],
[1,2,3,0], [1,3,0,2]
>>> kth_permutation(10,4)
[1, 3, 0, 2]

File: largest_of_very_large_numbers.py
 - Function 'res' takes 2 arguments: x, y.  Docstring: Reduces large number to a more manageable number
>>> res(5, 7)
4.892790030352132
>>> res(0, 5)
0
>>> res(3, 0)
1
>>> res(-1, 5)
Traceback (most recent call last):
...
ValueError: math domain error

File: least_common_multiple.py
 - Function 'least_common_multiple_slow' takes 2 arguments: first_num, second_num.  Docstring: Find the least common multiple of two numbers.

Learn more: https://en.wikipedia.org/wiki/Least_common_multiple

>>> least_common_multiple_slow(5, 2)
10
>>> least_common_multiple_slow(12, 76)
228
 - Function 'least_common_multiple_fast' takes 2 arguments: first_num, second_num.  Docstring: Find the least common multiple of two numbers.
https://en.wikipedia.org/wiki/Least_common_multiple#Using_the_greatest_common_divisor
>>> least_common_multiple_fast(5,2)
10
>>> least_common_multiple_fast(12,76)
228
 - Function 'benchmark' takes 0 arguments: .  No docstring available.
 - Function 'test_lcm_function' takes 1 arguments: self.  No docstring available.

File: line_length.py
 - Function 'line_length' takes 4 arguments: fnc, x_start, x_end, steps.  Docstring: Approximates the arc length of a line segment by treating the curve as a
sequence of linear lines and summing their lengths
:param fnc: a function which defines a curve
:param x_start: left end point to indicate the start of line segment
:param x_end: right end point to indicate end of line segment
:param steps: an accuracy gauge; more steps increases accuracy
:return: a float representing the length of the curve

>>> def f(x):
...    return x
>>> f"{line_length(f, 0, 1, 10):.6f}"
'1.414214'

>>> def f(x):
...    return 1
>>> f"{line_length(f, -5.5, 4.5):.6f}"
'10.000000'

>>> def f(x):
...    return math.sin(5 * x) + math.cos(10 * x) + x * x/10
>>> f"{line_length(f, 0.0, 10.0, 10000):.6f}"
'69.534930'
 - Function 'f' takes 1 arguments: x.  No docstring available.

File: liouville_lambda.py
 - Function 'liouville_lambda' takes 1 arguments: number.  Docstring: This functions takes an integer number as input.
returns 1 if n has even number of prime factors and -1 otherwise.
>>> liouville_lambda(10)
1
>>> liouville_lambda(11)
-1
>>> liouville_lambda(0)
Traceback (most recent call last):
    ...
ValueError: Input must be a positive integer
>>> liouville_lambda(-1)
Traceback (most recent call last):
    ...
ValueError: Input must be a positive integer
>>> liouville_lambda(11.0)
Traceback (most recent call last):
    ...
TypeError: Input value of [number=11.0] must be an integer

File: lucas_lehmer_primality_test.py
 - Function 'lucas_lehmer_test' takes 1 arguments: p.  Docstring: >>> lucas_lehmer_test(p=7)
True

>>> lucas_lehmer_test(p=11)
False

# M_11 = 2^11 - 1 = 2047 = 23 * 89

File: lucas_series.py
 - Function 'recursive_lucas_number' takes 1 arguments: n_th_number.  Docstring: Returns the nth lucas number
>>> recursive_lucas_number(1)
1
>>> recursive_lucas_number(20)
15127
>>> recursive_lucas_number(0)
2
>>> recursive_lucas_number(25)
167761
>>> recursive_lucas_number(-1.5)
Traceback (most recent call last):
    ...
TypeError: recursive_lucas_number accepts only integer arguments.
 - Function 'dynamic_lucas_number' takes 1 arguments: n_th_number.  Docstring: Returns the nth lucas number
>>> dynamic_lucas_number(1)
1
>>> dynamic_lucas_number(20)
15127
>>> dynamic_lucas_number(0)
2
>>> dynamic_lucas_number(25)
167761
>>> dynamic_lucas_number(-1.5)
Traceback (most recent call last):
    ...
TypeError: dynamic_lucas_number accepts only integer arguments.

File: maclaurin_series.py
 - Function 'maclaurin_sin' takes 2 arguments: theta, accuracy.  Docstring: Finds the maclaurin approximation of sin

:param theta: the angle to which sin is found
:param accuracy: the degree of accuracy wanted minimum
:return: the value of sine in radians


>>> from math import isclose, sin
>>> all(isclose(maclaurin_sin(x, 50), sin(x)) for x in range(-25, 25))
True
>>> maclaurin_sin(10)
-0.5440211108893691
>>> maclaurin_sin(-10)
0.5440211108893704
>>> maclaurin_sin(10, 15)
-0.544021110889369
>>> maclaurin_sin(-10, 15)
0.5440211108893704
>>> maclaurin_sin("10")
Traceback (most recent call last):
    ...
ValueError: maclaurin_sin() requires either an int or float for theta
>>> maclaurin_sin(10, -30)
Traceback (most recent call last):
    ...
ValueError: maclaurin_sin() requires a positive int for accuracy
>>> maclaurin_sin(10, 30.5)
Traceback (most recent call last):
    ...
ValueError: maclaurin_sin() requires a positive int for accuracy
>>> maclaurin_sin(10, "30")
Traceback (most recent call last):
    ...
ValueError: maclaurin_sin() requires a positive int for accuracy
 - Function 'maclaurin_cos' takes 2 arguments: theta, accuracy.  Docstring: Finds the maclaurin approximation of cos

:param theta: the angle to which cos is found
:param accuracy: the degree of accuracy wanted
:return: the value of cosine in radians


>>> from math import isclose, cos
>>> all(isclose(maclaurin_cos(x, 50), cos(x)) for x in range(-25, 25))
True
>>> maclaurin_cos(5)
0.2836621854632268
>>> maclaurin_cos(-5)
0.2836621854632265
>>> maclaurin_cos(10, 15)
-0.8390715290764524
>>> maclaurin_cos(-10, 15)
-0.8390715290764521
>>> maclaurin_cos("10")
Traceback (most recent call last):
    ...
ValueError: maclaurin_cos() requires either an int or float for theta
>>> maclaurin_cos(10, -30)
Traceback (most recent call last):
    ...
ValueError: maclaurin_cos() requires a positive int for accuracy
>>> maclaurin_cos(10, 30.5)
Traceback (most recent call last):
    ...
ValueError: maclaurin_cos() requires a positive int for accuracy
>>> maclaurin_cos(10, "30")
Traceback (most recent call last):
    ...
ValueError: maclaurin_cos() requires a positive int for accuracy

File: manhattan_distance.py
 - Function 'manhattan_distance' takes 2 arguments: point_a, point_b.  Docstring: Expectts two list of numbers representing two points in the same
n-dimensional space

https://en.wikipedia.org/wiki/Taxicab_geometry

>>> manhattan_distance([1,1], [2,2])
2.0
>>> manhattan_distance([1.5,1.5], [2,2])
1.0
>>> manhattan_distance([1.5,1.5], [2.5,2])
1.5
>>> manhattan_distance([-3, -3, -3], [0, 0, 0])
9.0
>>> manhattan_distance([1,1], None)
Traceback (most recent call last):
    ...
ValueError: Missing an input
>>> manhattan_distance([1,1], [2, 2, 2])
Traceback (most recent call last):
    ...
ValueError: Both points must be in the same n-dimensional space
>>> manhattan_distance([1,"one"], [2, 2, 2])
Traceback (most recent call last):
    ...
TypeError: Expected a list of numbers as input, found str
>>> manhattan_distance(1, [2, 2, 2])
Traceback (most recent call last):
     ...
TypeError: Expected a list of numbers as input, found int
>>> manhattan_distance([1,1], "not_a_list")
Traceback (most recent call last):
     ...
TypeError: Expected a list of numbers as input, found str
 - Function '_validate_point' takes 1 arguments: point.  Docstring: >>> _validate_point(None)
Traceback (most recent call last):
     ...
ValueError: Missing an input
>>> _validate_point([1,"one"])
Traceback (most recent call last):
     ...
TypeError: Expected a list of numbers as input, found str
>>> _validate_point(1)
Traceback (most recent call last):
     ...
TypeError: Expected a list of numbers as input, found int
>>> _validate_point("not_a_list")
Traceback (most recent call last):
     ...
TypeError: Expected a list of numbers as input, found str
 - Function 'manhattan_distance_one_liner' takes 2 arguments: point_a, point_b.  Docstring: Version with one liner

>>> manhattan_distance_one_liner([1,1], [2,2])
2.0
>>> manhattan_distance_one_liner([1.5,1.5], [2,2])
1.0
>>> manhattan_distance_one_liner([1.5,1.5], [2.5,2])
1.5
>>> manhattan_distance_one_liner([-3, -3, -3], [0, 0, 0])
9.0
>>> manhattan_distance_one_liner([1,1], None)
Traceback (most recent call last):
     ...
ValueError: Missing an input
>>> manhattan_distance_one_liner([1,1], [2, 2, 2])
Traceback (most recent call last):
     ...
ValueError: Both points must be in the same n-dimensional space
>>> manhattan_distance_one_liner([1,"one"], [2, 2, 2])
Traceback (most recent call last):
     ...
TypeError: Expected a list of numbers as input, found str
>>> manhattan_distance_one_liner(1, [2, 2, 2])
Traceback (most recent call last):
     ...
TypeError: Expected a list of numbers as input, found int
>>> manhattan_distance_one_liner([1,1], "not_a_list")
Traceback (most recent call last):
     ...
TypeError: Expected a list of numbers as input, found str

File: matrix_exponentiation.py
 - Function '__init__' takes 2 arguments: self, arg.  No docstring available.
 - Function '__mul__' takes 2 arguments: self, b.  No docstring available.
 - Function 'modular_exponentiation' takes 2 arguments: a, b.  No docstring available.
 - Function 'fibonacci_with_matrix_exponentiation' takes 3 arguments: n, f1, f2.  No docstring available.
 - Function 'simple_fibonacci' takes 3 arguments: n, f1, f2.  No docstring available.
 - Function 'matrix_exponentiation_time' takes 0 arguments: .  No docstring available.
 - Function 'simple_fibonacci_time' takes 0 arguments: .  No docstring available.
 - Function 'main' takes 0 arguments: .  No docstring available.

File: max_sum_sliding_window.py
 - Function 'max_sum_in_array' takes 2 arguments: array, k.  Docstring: Returns the maximum sum of k consecutive elements
>>> arr = [1, 4, 2, 10, 2, 3, 1, 0, 20]
>>> k = 4
>>> max_sum_in_array(arr, k)
24
>>> k = 10
>>> max_sum_in_array(arr,k)
Traceback (most recent call last):
    ...
ValueError: Invalid Input
>>> arr = [1, 4, 2, 10, 2, 13, 1, 0, 2]
>>> k = 4
>>> max_sum_in_array(arr, k)
27

File: minkowski_distance.py
 - Function 'minkowski_distance' takes 3 arguments: point_a, point_b, order.  Docstring: This function calculates the Minkowski distance for a given order between
two n-dimensional points represented as lists. For the case of order = 1,
the Minkowski distance degenerates to the Manhattan distance. For
order = 2, the usual Euclidean distance is obtained.

https://en.wikipedia.org/wiki/Minkowski_distance

Note: due to floating point calculation errors the output of this
function may be inaccurate.

>>> minkowski_distance([1.0, 1.0], [2.0, 2.0], 1)
2.0
>>> minkowski_distance([1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], 2)
8.0
>>> import numpy as np
>>> np.isclose(5.0, minkowski_distance([5.0], [0.0], 3))
True
>>> minkowski_distance([1.0], [2.0], -1)
Traceback (most recent call last):
    ...
ValueError: The order must be greater than or equal to 1.
>>> minkowski_distance([1.0], [1.0, 2.0], 1)
Traceback (most recent call last):
    ...
ValueError: Both points must have the same dimension.

File: mobius_function.py
 - Function 'mobius' takes 1 arguments: n.  Docstring: Mobius function
>>> mobius(24)
0
>>> mobius(-1)
1
>>> mobius('asd')
Traceback (most recent call last):
    ...
TypeError: '<=' not supported between instances of 'int' and 'str'
>>> mobius(10**400)
0
>>> mobius(10**-400)
1
>>> mobius(-1424)
1
>>> mobius([1, '2', 2.0])
Traceback (most recent call last):
    ...
TypeError: '<=' not supported between instances of 'int' and 'list'

File: modular_division.py
 - Function 'modular_division' takes 3 arguments: a, b, n.  Docstring: Modular Division :
An efficient algorithm for dividing b by a modulo n.

GCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )

Given three integers a, b, and n, such that gcd(a,n)=1 and n>1, the algorithm should
return an integer x such that 0xn-1, and  b/a=x(modn) (that is, b=ax(modn)).

Theorem:
a has a multiplicative inverse modulo n iff gcd(a,n) = 1


This find x = b*a^(-1) mod n
Uses ExtendedEuclid to find the inverse of a

>>> modular_division(4,8,5)
2

>>> modular_division(3,8,5)
1

>>> modular_division(4, 11, 5)
4
 - Function 'invert_modulo' takes 2 arguments: a, n.  Docstring: This function find the inverses of a i.e., a^(-1)

>>> invert_modulo(2, 5)
3

>>> invert_modulo(8,7)
1
 - Function 'modular_division2' takes 3 arguments: a, b, n.  Docstring: This function used the above inversion of a to find x = (b*a^(-1))mod n

>>> modular_division2(4,8,5)
2

>>> modular_division2(3,8,5)
1

>>> modular_division2(4, 11, 5)
4
 - Function 'extended_gcd' takes 2 arguments: a, b.  Docstring: Extended Euclid's Algorithm : If d divides a and b and d = a*x + b*y for integers x
and y, then d = gcd(a,b)
>>> extended_gcd(10, 6)
(2, -1, 2)

>>> extended_gcd(7, 5)
(1, -2, 3)

** extended_gcd function is used when d = gcd(a,b) is required in output
 - Function 'extended_euclid' takes 2 arguments: a, b.  Docstring: Extended Euclid
>>> extended_euclid(10, 6)
(-1, 2)

>>> extended_euclid(7, 5)
(-2, 3)
 - Function 'greatest_common_divisor' takes 2 arguments: a, b.  Docstring: Euclid's Lemma :  d divides a and b, if and only if d divides a-b and b
Euclid's Algorithm

>>> greatest_common_divisor(7,5)
1

Note : In number theory, two integers a and b are said to be relatively prime,
    mutually prime, or co-prime if the only positive integer (factor) that divides
    both of them is 1  i.e., gcd(a,b) = 1.

>>> greatest_common_divisor(121, 11)
11

File: modular_exponential.py
 - Function 'modular_exponential' takes 3 arguments: base, power, mod.  Docstring: >>> modular_exponential(5, 0, 10)
1
>>> modular_exponential(2, 8, 7)
4
>>> modular_exponential(3, -2, 9)
-1
 - Function 'main' takes 0 arguments: .  Docstring: Call Modular Exponential Function.

File: monte_carlo.py
 - Function 'pi_estimator' takes 1 arguments: iterations.  Docstring: An implementation of the Monte Carlo method used to find pi.
1. Draw a 2x2 square centred at (0,0).
2. Inscribe a circle within the square.
3. For each iteration, place a dot anywhere in the square.
   a. Record the number of dots within the circle.
4. After all the dots are placed, divide the dots in the circle by the total.
5. Multiply this value by 4 to get your estimate of pi.
6. Print the estimated and numpy value of pi
 - Function 'is_in_circle' takes 2 arguments: x, y.  No docstring available.
 - Function 'area_under_curve_estimator' takes 4 arguments: iterations, function_to_integrate, min_value, max_value.  Docstring: An implementation of the Monte Carlo method to find area under
   a single variable non-negative real-valued continuous function,
   say f(x), where x lies within a continuous bounded interval,
   say [min_value, max_value], where min_value and max_value are
   finite numbers
1. Let x be a uniformly distributed random variable between min_value to
   max_value
2. Expected value of f(x) =
   (integrate f(x) from min_value to max_value)/(max_value - min_value)
3. Finding expected value of f(x):
    a. Repeatedly draw x from uniform distribution
    b. Evaluate f(x) at each of the drawn x values
    c. Expected value = average of the function evaluations
4. Estimated value of integral = Expected value * (max_value - min_value)
5. Returns estimated value
 - Function 'area_under_line_estimator_check' takes 3 arguments: iterations, min_value, max_value.  Docstring: Checks estimation error for area_under_curve_estimator function
for f(x) = x where x lies within min_value to max_value
1. Calls "area_under_curve_estimator" function
2. Compares with the expected value
3. Prints estimated, expected and error value
 - Function 'identity_function' takes 1 arguments: x.  Docstring: Represents identity function
>>> [function_to_integrate(x) for x in [-2.0, -1.0, 0.0, 1.0, 2.0]]
[-2.0, -1.0, 0.0, 1.0, 2.0]
 - Function 'pi_estimator_using_area_under_curve' takes 1 arguments: iterations.  Docstring: Area under curve y = sqrt(4 - x^2) where x lies in 0 to 2 is equal to pi
 - Function 'function_to_integrate' takes 1 arguments: x.  Docstring: Represents semi-circle with radius 2
>>> [function_to_integrate(x) for x in [-2.0, 0.0, 2.0]]
[0.0, 2.0, 0.0]

File: monte_carlo_dice.py
 - Function '__init__' takes 1 arguments: self.  Docstring: Initialize a six sided dice
 - Function 'roll' takes 1 arguments: self.  No docstring available.
 - Function 'throw_dice' takes 2 arguments: num_throws, num_dice.  Docstring: Return probability list of all possible sums when throwing dice.

>>> random.seed(0)
>>> throw_dice(10, 1)
[10.0, 0.0, 30.0, 50.0, 10.0, 0.0]
>>> throw_dice(100, 1)
[19.0, 17.0, 17.0, 11.0, 23.0, 13.0]
>>> throw_dice(1000, 1)
[18.8, 15.5, 16.3, 17.6, 14.2, 17.6]
>>> throw_dice(10000, 1)
[16.35, 16.89, 16.93, 16.6, 16.52, 16.71]
>>> throw_dice(10000, 2)
[2.74, 5.6, 7.99, 11.26, 13.92, 16.7, 14.44, 10.63, 8.05, 5.92, 2.75]

File: number_of_digits.py
 - Function 'num_digits' takes 1 arguments: n.  Docstring: Find the number of digits in a number.

>>> num_digits(12345)
5
>>> num_digits(123)
3
>>> num_digits(0)
1
>>> num_digits(-1)
1
>>> num_digits(-123456)
6
>>> num_digits('123')  # Raises a TypeError for non-integer input
Traceback (most recent call last):
    ...
TypeError: Input must be an integer
 - Function 'num_digits_fast' takes 1 arguments: n.  Docstring: Find the number of digits in a number.
abs() is used as logarithm for negative numbers is not defined.

>>> num_digits_fast(12345)
5
>>> num_digits_fast(123)
3
>>> num_digits_fast(0)
1
>>> num_digits_fast(-1)
1
>>> num_digits_fast(-123456)
6
>>> num_digits('123')  # Raises a TypeError for non-integer input
Traceback (most recent call last):
    ...
TypeError: Input must be an integer
 - Function 'num_digits_faster' takes 1 arguments: n.  Docstring: Find the number of digits in a number.
abs() is used for negative numbers

>>> num_digits_faster(12345)
5
>>> num_digits_faster(123)
3
>>> num_digits_faster(0)
1
>>> num_digits_faster(-1)
1
>>> num_digits_faster(-123456)
6
>>> num_digits('123')  # Raises a TypeError for non-integer input
Traceback (most recent call last):
    ...
TypeError: Input must be an integer
 - Function 'benchmark' takes 0 arguments: .  Docstring: Benchmark multiple functions, with three different length int values.
 - Function 'benchmark_a_function' takes 2 arguments: func, value.  No docstring available.

File: odd_sieve.py
 - Function 'odd_sieve' takes 1 arguments: num.  Docstring: Returns the prime numbers < `num`. The prime numbers are calculated using an
odd sieve implementation of the Sieve of Eratosthenes algorithm
(see for reference https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes).

>>> odd_sieve(2)
[]
>>> odd_sieve(3)
[2]
>>> odd_sieve(10)
[2, 3, 5, 7]
>>> odd_sieve(20)
[2, 3, 5, 7, 11, 13, 17, 19]

File: perfect_cube.py
 - Function 'perfect_cube' takes 1 arguments: n.  Docstring: Check if a number is a perfect cube or not.

>>> perfect_cube(27)
True
>>> perfect_cube(4)
False
 - Function 'perfect_cube_binary_search' takes 1 arguments: n.  Docstring: Check if a number is a perfect cube or not using binary search.
Time complexity : O(Log(n))
Space complexity: O(1)

>>> perfect_cube_binary_search(27)
True
>>> perfect_cube_binary_search(64)
True
>>> perfect_cube_binary_search(4)
False
>>> perfect_cube_binary_search("a")
Traceback (most recent call last):
    ...
TypeError: perfect_cube_binary_search() only accepts integers
>>> perfect_cube_binary_search(0.1)
Traceback (most recent call last):
    ...
TypeError: perfect_cube_binary_search() only accepts integers

File: perfect_number.py
 - Function 'perfect' takes 1 arguments: number.  Docstring: Check if a number is a perfect number.

A perfect number is a positive integer that is equal to the sum of its proper
divisors (excluding itself).

Args:
    number: The number to be checked.

Returns:
    True if the number is a perfect number, False otherwise.

Start from 1 because dividing by 0 will raise ZeroDivisionError.
A number at most can be divisible by the half of the number except the number
itself. For example, 6 is at most can be divisible by 3 except by 6 itself.

Examples:
>>> perfect(27)
False
>>> perfect(28)
True
>>> perfect(29)
False
>>> perfect(6)
True
>>> perfect(12)
False
>>> perfect(496)
True
>>> perfect(8128)
True
>>> perfect(0)
False
>>> perfect(-1)
False
>>> perfect(12.34)
Traceback (most recent call last):
  ...
ValueError: number must be an integer
>>> perfect("Hello")
Traceback (most recent call last):
  ...
ValueError: number must be an integer

File: perfect_square.py
 - Function 'perfect_square' takes 1 arguments: num.  Docstring: Check if a number is perfect square number or not
:param num: the number to be checked
:return: True if number is square number, otherwise False

>>> perfect_square(9)
True
>>> perfect_square(16)
True
>>> perfect_square(1)
True
>>> perfect_square(0)
True
>>> perfect_square(10)
False
 - Function 'perfect_square_binary_search' takes 1 arguments: n.  Docstring: Check if a number is perfect square using binary search.
Time complexity : O(Log(n))
Space complexity: O(1)

>>> perfect_square_binary_search(9)
True
>>> perfect_square_binary_search(16)
True
>>> perfect_square_binary_search(1)
True
>>> perfect_square_binary_search(0)
True
>>> perfect_square_binary_search(10)
False
>>> perfect_square_binary_search(-1)
False
>>> perfect_square_binary_search(1.1)
False
>>> perfect_square_binary_search("a")
Traceback (most recent call last):
    ...
TypeError: '<=' not supported between instances of 'int' and 'str'
>>> perfect_square_binary_search(None)
Traceback (most recent call last):
    ...
TypeError: '<=' not supported between instances of 'int' and 'NoneType'
>>> perfect_square_binary_search([])
Traceback (most recent call last):
    ...
TypeError: '<=' not supported between instances of 'int' and 'list'

File: persistence.py
 - Function 'multiplicative_persistence' takes 1 arguments: num.  Docstring: Return the persistence of a given number.

https://en.wikipedia.org/wiki/Persistence_of_a_number

>>> multiplicative_persistence(217)
2
>>> multiplicative_persistence(-1)
Traceback (most recent call last):
    ...
ValueError: multiplicative_persistence() does not accept negative values
>>> multiplicative_persistence("long number")
Traceback (most recent call last):
    ...
ValueError: multiplicative_persistence() only accepts integral values
 - Function 'additive_persistence' takes 1 arguments: num.  Docstring: Return the persistence of a given number.

https://en.wikipedia.org/wiki/Persistence_of_a_number

>>> additive_persistence(199)
3
>>> additive_persistence(-1)
Traceback (most recent call last):
    ...
ValueError: additive_persistence() does not accept negative values
>>> additive_persistence("long number")
Traceback (most recent call last):
    ...
ValueError: additive_persistence() only accepts integral values

File: pi_generator.py
 - Function 'calculate_pi' takes 1 arguments: limit.  Docstring: https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80
Leibniz Formula for Pi

The Leibniz formula is the special case arctan(1) = pi / 4.
Leibniz's formula converges extremely slowly: it exhibits sublinear convergence.

Convergence (https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80#Convergence)

We cannot try to prove against an interrupted, uncompleted generation.
https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80#Unusual_behaviour
The errors can in fact be predicted, but those calculations also approach infinity
for accuracy.

Our output will be a string so that we can definitely store all digits.

>>> import math
>>> float(calculate_pi(15)) == math.pi
True

Since we cannot predict errors or interrupt any infinite alternating series
generation since they approach infinity, or interrupt any alternating series, we'll
need math.isclose()

>>> math.isclose(float(calculate_pi(50)), math.pi)
True
>>> math.isclose(float(calculate_pi(100)), math.pi)
True

Since math.pi contains only 16 digits, here are some tests with known values:

>>> calculate_pi(50)
'3.14159265358979323846264338327950288419716939937510'
>>> calculate_pi(80)
'3.14159265358979323846264338327950288419716939937510582097494459230781640628620899'
 - Function 'main' takes 0 arguments: .  No docstring available.

File: pi_monte_carlo_estimation.py
 - Function '__init__' takes 3 arguments: self, x, y.  No docstring available.
 - Function 'is_in_unit_circle' takes 1 arguments: self.  Docstring: True, if the point lies in the unit circle
False, otherwise
 - Function 'random_unit_square' takes 1 arguments: cls.  Docstring: Generates a point randomly drawn from the unit square [0, 1) x [0, 1).
 - Function 'estimate_pi' takes 1 arguments: number_of_simulations.  Docstring: Generates an estimate of the mathematical constant PI.
See https://en.wikipedia.org/wiki/Monte_Carlo_method#Overview

The estimate is generated by Monte Carlo simulations. Let U be uniformly drawn from
the unit square [0, 1) x [0, 1). The probability that U lies in the unit circle is:

    P[U in unit circle] = 1/4 PI

and therefore

    PI = 4 * P[U in unit circle]

We can get an estimate of the probability P[U in unit circle].
See https://en.wikipedia.org/wiki/Empirical_probability by:

    1. Draw a point uniformly from the unit square.
    2. Repeat the first step n times and count the number of points in the unit
        circle, which is called m.
    3. An estimate of P[U in unit circle] is m/n

File: points_are_collinear_3d.py
 - Function 'create_vector' takes 2 arguments: end_point1, end_point2.  Docstring: Pass two points to get the vector from them in the form (x, y, z).

>>> create_vector((0, 0, 0), (1, 1, 1))
(1, 1, 1)
>>> create_vector((45, 70, 24), (47, 32, 1))
(2, -38, -23)
>>> create_vector((-14, -1, -8), (-7, 6, 4))
(7, 7, 12)
 - Function 'get_3d_vectors_cross' takes 2 arguments: ab, ac.  Docstring: Get the cross of the two vectors AB and AC.

I used determinant of 2x2 to get the determinant of the 3x3 matrix in the process.

Read More:
    https://en.wikipedia.org/wiki/Cross_product
    https://en.wikipedia.org/wiki/Determinant

>>> get_3d_vectors_cross((3, 4, 7), (4, 9, 2))
(-55, 22, 11)
>>> get_3d_vectors_cross((1, 1, 1), (1, 1, 1))
(0, 0, 0)
>>> get_3d_vectors_cross((-4, 3, 0), (3, -9, -12))
(-36, -48, 27)
>>> get_3d_vectors_cross((17.67, 4.7, 6.78), (-9.5, 4.78, -19.33))
(-123.2594, 277.15110000000004, 129.11260000000001)
 - Function 'is_zero_vector' takes 2 arguments: vector, accuracy.  Docstring: Check if vector is equal to (0, 0, 0) or not.

Since the algorithm is very accurate, we will never get a zero vector,
so we need to round the vector axis,
because we want a result that is either True or False.
In other applications, we can return a float that represents the collinearity ratio.

>>> is_zero_vector((0, 0, 0), accuracy=10)
True
>>> is_zero_vector((15, 74, 32), accuracy=10)
False
>>> is_zero_vector((-15, -74, -32), accuracy=10)
False
 - Function 'are_collinear' takes 4 arguments: a, b, c, accuracy.  Docstring: Check if three points are collinear or not.

1- Create two vectors AB and AC.
2- Get the cross vector of the two vectors.
3- Calculate the length of the cross vector.
4- If the length is zero then the points are collinear, else they are not.

The use of the accuracy parameter is explained in is_zero_vector docstring.

>>> are_collinear((4.802293498137402, 3.536233125455244, 0),
...               (-2.186788107953106, -9.24561398001649, 7.141509524846482),
...               (1.530169574640268, -2.447927606600034, 3.343487096469054))
True
>>> are_collinear((-6, -2, 6),
...               (6.200213806439997, -4.930157614926678, -4.482371908289856),
...               (-4.085171149525941, -2.459889509029438, 4.354787180795383))
True
>>> are_collinear((2.399001826862445, -2.452009976680793, 4.464656666157666),
...               (-3.682816335934376, 5.753788986533145, 9.490993909044244),
...               (1.962903518985307, 3.741415730125627, 7))
False
>>> are_collinear((1.875375340689544, -7.268426006071538, 7.358196269835993),
...               (-3.546599383667157, -4.630005261513976, 3.208784032924246),
...               (-2.564606140206386, 3.937845170672183, 7))
False

File: pollard_rho.py
 - Function 'pollard_rho' takes 4 arguments: num, seed, step, attempts.  Docstring: Use Pollard's Rho algorithm to return a nontrivial factor of ``num``.
The returned factor may be composite and require further factorization.
If the algorithm will return None if it fails to find a factor within
the specified number of attempts or within the specified number of steps.
If ``num`` is prime, this algorithm is guaranteed to return None.
https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm

>>> pollard_rho(18446744073709551617)
274177
>>> pollard_rho(97546105601219326301)
9876543191
>>> pollard_rho(100)
2
>>> pollard_rho(17)
>>> pollard_rho(17**3)
17
>>> pollard_rho(17**3, attempts=1)
>>> pollard_rho(3*5*7)
21
>>> pollard_rho(1)
Traceback (most recent call last):
    ...
ValueError: The input value cannot be less than 2
 - Function 'rand_fn' takes 3 arguments: value, step, modulus.  Docstring: Returns a pseudorandom value modulo ``modulus`` based on the
input ``value`` and attempt-specific ``step`` size.

>>> rand_fn(0, 0, 0)
Traceback (most recent call last):
    ...
ZeroDivisionError: integer division or modulo by zero
>>> rand_fn(1, 2, 3)
0
>>> rand_fn(0, 10, 7)
3
>>> rand_fn(1234, 1, 17)
16

File: polynomial_evaluation.py
 - Function 'evaluate_poly' takes 2 arguments: poly, x.  Docstring: Evaluate a polynomial f(x) at specified point x and return the value.

Arguments:
poly -- the coefficients of a polynomial as an iterable in order of
        ascending degree
x -- the point at which to evaluate the polynomial

>>> evaluate_poly((0.0, 0.0, 5.0, 9.3, 7.0), 10.0)
79800.0
 - Function 'horner' takes 2 arguments: poly, x.  Docstring: Evaluate a polynomial at specified point using Horner's method.

In terms of computational complexity, Horner's method is an efficient method
of evaluating a polynomial. It avoids the use of expensive exponentiation,
and instead uses only multiplication and addition to evaluate the polynomial
in O(n), where n is the degree of the polynomial.

https://en.wikipedia.org/wiki/Horner's_method

Arguments:
poly -- the coefficients of a polynomial as an iterable in order of
        ascending degree
x -- the point at which to evaluate the polynomial

>>> horner((0.0, 0.0, 5.0, 9.3, 7.0), 10.0)
79800.0

File: power_using_recursion.py
 - Function 'power' takes 2 arguments: base, exponent.  Docstring: Calculate the power of a base raised to an exponent.

>>> power(3, 4)
81
>>> power(2, 0)
1
>>> all(power(base, exponent) == pow(base, exponent)
...     for base in range(-10, 10) for exponent in range(10))
True
>>> power('a', 1)
'a'
>>> power('a', 2)
Traceback (most recent call last):
    ...
TypeError: can't multiply sequence by non-int of type 'str'
>>> power('a', 'b')
Traceback (most recent call last):
    ...
TypeError: unsupported operand type(s) for -: 'str' and 'int'
>>> power(2, -1)
Traceback (most recent call last):
    ...
RecursionError: maximum recursion depth exceeded

File: primelib.py
 - Function 'is_prime' takes 1 arguments: number.  Docstring: input: positive integer 'number'
returns true if 'number' is prime otherwise false.

>>> is_prime(3)
True
>>> is_prime(10)
False
>>> is_prime(97)
True
>>> is_prime(9991)
False
>>> is_prime(-1)
Traceback (most recent call last):
    ...
AssertionError: 'number' must been an int and positive
>>> is_prime("test")
Traceback (most recent call last):
    ...
AssertionError: 'number' must been an int and positive
 - Function 'sieve_er' takes 1 arguments: n.  Docstring: input: positive integer 'N' > 2
returns a list of prime numbers from 2 up to N.

This function implements the algorithm called
sieve of erathostenes.

>>> sieve_er(8)
[2, 3, 5, 7]
>>> sieve_er(-1)
Traceback (most recent call last):
    ...
AssertionError: 'N' must been an int and > 2
>>> sieve_er("test")
Traceback (most recent call last):
    ...
AssertionError: 'N' must been an int and > 2
 - Function 'get_prime_numbers' takes 1 arguments: n.  Docstring: input: positive integer 'N' > 2
returns a list of prime numbers from 2 up to N (inclusive)
This function is more efficient as function 'sieveEr(...)'

>>> get_prime_numbers(8)
[2, 3, 5, 7]
>>> get_prime_numbers(-1)
Traceback (most recent call last):
    ...
AssertionError: 'N' must been an int and > 2
>>> get_prime_numbers("test")
Traceback (most recent call last):
    ...
AssertionError: 'N' must been an int and > 2
 - Function 'prime_factorization' takes 1 arguments: number.  Docstring: input: positive integer 'number'
returns a list of the prime number factors of 'number'

>>> prime_factorization(0)
[0]
>>> prime_factorization(8)
[2, 2, 2]
>>> prime_factorization(287)
[7, 41]
>>> prime_factorization(-1)
Traceback (most recent call last):
    ...
AssertionError: 'number' must been an int and >= 0
>>> prime_factorization("test")
Traceback (most recent call last):
    ...
AssertionError: 'number' must been an int and >= 0
 - Function 'greatest_prime_factor' takes 1 arguments: number.  Docstring: input: positive integer 'number' >= 0
returns the greatest prime number factor of 'number'

>>> greatest_prime_factor(0)
0
>>> greatest_prime_factor(8)
2
>>> greatest_prime_factor(287)
41
>>> greatest_prime_factor(-1)
Traceback (most recent call last):
    ...
AssertionError: 'number' must been an int and >= 0
>>> greatest_prime_factor("test")
Traceback (most recent call last):
    ...
AssertionError: 'number' must been an int and >= 0
 - Function 'smallest_prime_factor' takes 1 arguments: number.  Docstring: input: integer 'number' >= 0
returns the smallest prime number factor of 'number'

>>> smallest_prime_factor(0)
0
>>> smallest_prime_factor(8)
2
>>> smallest_prime_factor(287)
7
>>> smallest_prime_factor(-1)
Traceback (most recent call last):
    ...
AssertionError: 'number' must been an int and >= 0
>>> smallest_prime_factor("test")
Traceback (most recent call last):
    ...
AssertionError: 'number' must been an int and >= 0
 - Function 'is_even' takes 1 arguments: number.  Docstring: input: integer 'number'
returns true if 'number' is even, otherwise false.

>>> is_even(0)
True
>>> is_even(8)
True
>>> is_even(287)
False
>>> is_even(-1)
False
>>> is_even("test")
Traceback (most recent call last):
    ...
AssertionError: 'number' must been an int
 - Function 'is_odd' takes 1 arguments: number.  Docstring: input: integer 'number'
returns true if 'number' is odd, otherwise false.

>>> is_odd(0)
False
>>> is_odd(8)
False
>>> is_odd(287)
True
>>> is_odd(-1)
True
>>> is_odd("test")
Traceback (most recent call last):
    ...
AssertionError: 'number' must been an int
 - Function 'goldbach' takes 1 arguments: number.  Docstring: Goldbach's assumption
input: a even positive integer 'number' > 2
returns a list of two prime numbers whose sum is equal to 'number'

>>> goldbach(8)
[3, 5]
>>> goldbach(824)
[3, 821]
>>> goldbach(0)
Traceback (most recent call last):
    ...
AssertionError: 'number' must been an int, even and > 2
>>> goldbach(-1)
Traceback (most recent call last):
    ...
AssertionError: 'number' must been an int, even and > 2
>>> goldbach("test")
Traceback (most recent call last):
    ...
AssertionError: 'number' must been an int, even and > 2
 - Function 'kg_v' takes 2 arguments: number1, number2.  Docstring: Least common multiple
input: two positive integer 'number1' and 'number2'
returns the least common multiple of 'number1' and 'number2'

>>> kg_v(8,10)
40
>>> kg_v(824,67)
55208
>>> kg_v(1, 10)
10
>>> kg_v(0)
Traceback (most recent call last):
    ...
TypeError: kg_v() missing 1 required positional argument: 'number2'
>>> kg_v(10,-1)
Traceback (most recent call last):
    ...
AssertionError: 'number1' and 'number2' must been positive integer.
>>> kg_v("test","test2")
Traceback (most recent call last):
    ...
AssertionError: 'number1' and 'number2' must been positive integer.
 - Function 'get_prime' takes 1 arguments: n.  Docstring: Gets the n-th prime number.
input: positive integer 'n' >= 0
returns the n-th prime number, beginning at index 0

>>> get_prime(0)
2
>>> get_prime(8)
23
>>> get_prime(824)
6337
>>> get_prime(-1)
Traceback (most recent call last):
    ...
AssertionError: 'number' must been a positive int
>>> get_prime("test")
Traceback (most recent call last):
    ...
AssertionError: 'number' must been a positive int
 - Function 'get_primes_between' takes 2 arguments: p_number_1, p_number_2.  Docstring: input: prime numbers 'pNumber1' and 'pNumber2'
        pNumber1 < pNumber2
returns a list of all prime numbers between 'pNumber1' (exclusive)
        and 'pNumber2' (exclusive)

>>> get_primes_between(3, 67)
[5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]
>>> get_primes_between(0)
Traceback (most recent call last):
    ...
TypeError: get_primes_between() missing 1 required positional argument: 'p_number_2'
>>> get_primes_between(0, 1)
Traceback (most recent call last):
    ...
AssertionError: The arguments must been prime numbers and 'pNumber1' < 'pNumber2'
>>> get_primes_between(-1, 3)
Traceback (most recent call last):
    ...
AssertionError: 'number' must been an int and positive
>>> get_primes_between("test","test")
Traceback (most recent call last):
    ...
AssertionError: 'number' must been an int and positive
 - Function 'get_divisors' takes 1 arguments: n.  Docstring: input: positive integer 'n' >= 1
returns all divisors of n (inclusive 1 and 'n')

>>> get_divisors(8)
[1, 2, 4, 8]
>>> get_divisors(824)
[1, 2, 4, 8, 103, 206, 412, 824]
>>> get_divisors(-1)
Traceback (most recent call last):
    ...
AssertionError: 'n' must been int and >= 1
>>> get_divisors("test")
Traceback (most recent call last):
    ...
AssertionError: 'n' must been int and >= 1
 - Function 'is_perfect_number' takes 1 arguments: number.  Docstring: input: positive integer 'number' > 1
returns true if 'number' is a perfect number otherwise false.

>>> is_perfect_number(28)
True
>>> is_perfect_number(824)
False
>>> is_perfect_number(-1)
Traceback (most recent call last):
    ...
AssertionError: 'number' must been an int and >= 1
>>> is_perfect_number("test")
Traceback (most recent call last):
    ...
AssertionError: 'number' must been an int and >= 1
 - Function 'simplify_fraction' takes 2 arguments: numerator, denominator.  Docstring: input: two integer 'numerator' and 'denominator'
assumes: 'denominator' != 0
returns: a tuple with simplify numerator and denominator.

>>> simplify_fraction(10, 20)
(1, 2)
>>> simplify_fraction(10, -1)
(10, -1)
>>> simplify_fraction("test","test")
Traceback (most recent call last):
    ...
AssertionError: The arguments must been from type int and 'denominator' != 0
 - Function 'factorial' takes 1 arguments: n.  Docstring: input: positive integer 'n'
returns the factorial of 'n' (n!)

>>> factorial(0)
1
>>> factorial(20)
2432902008176640000
>>> factorial(-1)
Traceback (most recent call last):
    ...
AssertionError: 'n' must been a int and >= 0
>>> factorial("test")
Traceback (most recent call last):
    ...
AssertionError: 'n' must been a int and >= 0
 - Function 'fib' takes 1 arguments: n.  Docstring: input: positive integer 'n'
returns the n-th fibonacci term , indexing by 0

>>> fib(0)
1
>>> fib(5)
8
>>> fib(20)
10946
>>> fib(99)
354224848179261915075
>>> fib(-1)
Traceback (most recent call last):
...
AssertionError: 'n' must been an int and >= 0
>>> fib("test")
Traceback (most recent call last):
...
AssertionError: 'n' must been an int and >= 0

File: prime_check.py
 - Function 'is_prime' takes 1 arguments: number.  Docstring: Checks to see if a number is a prime in O(sqrt(n)).

A number is prime if it has exactly two factors: 1 and itself.

>>> is_prime(0)
False
>>> is_prime(1)
False
>>> is_prime(2)
True
>>> is_prime(3)
True
>>> is_prime(27)
False
>>> is_prime(87)
False
>>> is_prime(563)
True
>>> is_prime(2999)
True
>>> is_prime(67483)
False
>>> is_prime(16.1)
Traceback (most recent call last):
    ...
ValueError: is_prime() only accepts positive integers
>>> is_prime(-4)
Traceback (most recent call last):
    ...
ValueError: is_prime() only accepts positive integers
 - Function 'test_primes' takes 1 arguments: self.  No docstring available.
 - Function 'test_not_primes' takes 1 arguments: self.  No docstring available.

File: prime_factors.py
 - Function 'prime_factors' takes 1 arguments: n.  Docstring: Returns prime factors of n as a list.

>>> prime_factors(0)
[]
>>> prime_factors(100)
[2, 2, 5, 5]
>>> prime_factors(2560)
[2, 2, 2, 2, 2, 2, 2, 2, 2, 5]
>>> prime_factors(10**-2)
[]
>>> prime_factors(0.02)
[]
>>> x = prime_factors(10**241) # doctest: +NORMALIZE_WHITESPACE
>>> x == [2]*241 + [5]*241
True
>>> prime_factors(10**-354)
[]
>>> prime_factors('hello')
Traceback (most recent call last):
    ...
TypeError: '<=' not supported between instances of 'int' and 'str'
>>> prime_factors([1,2,'hello'])
Traceback (most recent call last):
    ...
TypeError: '<=' not supported between instances of 'int' and 'list'

File: prime_sieve_eratosthenes.py
 - Function 'prime_sieve_eratosthenes' takes 1 arguments: num.  Docstring: Print the prime numbers up to n

>>> prime_sieve_eratosthenes(10)
[2, 3, 5, 7]
>>> prime_sieve_eratosthenes(20)
[2, 3, 5, 7, 11, 13, 17, 19]
>>> prime_sieve_eratosthenes(2)
[2]
>>> prime_sieve_eratosthenes(1)
[]
>>> prime_sieve_eratosthenes(-1)
Traceback (most recent call last):
...
ValueError: Input must be a positive integer

File: print_multiplication_table.py
 - Function 'multiplication_table' takes 2 arguments: number, number_of_terms.  Docstring: Prints the multiplication table of a given number till the given number of terms

>>> print(multiplication_table(3, 5))
3 * 1 = 3
3 * 2 = 6
3 * 3 = 9
3 * 4 = 12
3 * 5 = 15

>>> print(multiplication_table(-4, 6))
-4 * 1 = -4
-4 * 2 = -8
-4 * 3 = -12
-4 * 4 = -16
-4 * 5 = -20
-4 * 6 = -24

File: pythagoras.py
 - Function '__init__' takes 4 arguments: self, x, y, z.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function 'distance' takes 2 arguments: a, b.  Docstring: >>> point1 = Point(2, -1, 7)
>>> point2 = Point(1, -3, 5)
>>> print(f"Distance from {point1} to {point2} is {distance(point1, point2)}")
Distance from Point(2, -1, 7) to Point(1, -3, 5) is 3.0

File: qr_decomposition.py
 - Function 'qr_householder' takes 1 arguments: a.  Docstring: Return a QR-decomposition of the matrix A using Householder reflection.

The QR-decomposition decomposes the matrix A of shape (m, n) into an
orthogonal matrix Q of shape (m, m) and an upper triangular matrix R of
shape (m, n).  Note that the matrix A does not have to be square.  This
method of decomposing A uses the Householder reflection, which is
numerically stable and of complexity O(n^3).

https://en.wikipedia.org/wiki/QR_decomposition#Using_Householder_reflections

Arguments:
A -- a numpy.ndarray of shape (m, n)

Note: several optimizations can be made for numeric efficiency, but this is
intended to demonstrate how it would be represented in a mathematics
textbook.  In cases where efficiency is particularly important, an optimized
version from BLAS should be used.

>>> A = np.array([[12, -51, 4], [6, 167, -68], [-4, 24, -41]], dtype=float)
>>> Q, R = qr_householder(A)

>>> # check that the decomposition is correct
>>> np.allclose(Q@R, A)
True

>>> # check that Q is orthogonal
>>> np.allclose(Q@Q.T, np.eye(A.shape[0]))
True
>>> np.allclose(Q.T@Q, np.eye(A.shape[0]))
True

>>> # check that R is upper triangular
>>> np.allclose(np.triu(R), R)
True

File: quadratic_equations_complex_numbers.py
 - Function 'quadratic_roots' takes 3 arguments: a, b, c.  Docstring: Given the numerical coefficients a, b and c,
calculates the roots for any quadratic equation of the form ax^2 + bx + c

>>> quadratic_roots(a=1, b=3, c=-4)
(1.0, -4.0)
>>> quadratic_roots(5, 6, 1)
(-0.2, -1.0)
>>> quadratic_roots(1, -6, 25)
((3+4j), (3-4j))
 - Function 'main' takes 0 arguments: .  No docstring available.

File: radians.py
 - Function 'radians' takes 1 arguments: degree.  Docstring: Converts the given angle from degrees to radians
https://en.wikipedia.org/wiki/Radian

>>> radians(180)
3.141592653589793
>>> radians(92)
1.6057029118347832
>>> radians(274)
4.782202150464463
>>> radians(109.82)
1.9167205845401725

>>> from math import radians as math_radians
>>> all(abs(radians(i) - math_radians(i)) <= 1e-8 for i in range(-2, 361))
True

File: radix2_fft.py
 - Function '__init__' takes 3 arguments: self, poly_a, poly_b.  No docstring available.
 - Function '__dft' takes 2 arguments: self, which.  No docstring available.
 - Function '__multiply' takes 1 arguments: self.  No docstring available.
 - Function '__str__' takes 1 arguments: self.  No docstring available.

File: remove_digit.py
 - Function 'remove_digit' takes 1 arguments: num.  Docstring: returns the biggest possible result
that can be achieved by removing
one digit from the given number

>>> remove_digit(152)
52
>>> remove_digit(6385)
685
>>> remove_digit(-11)
1
>>> remove_digit(2222222)
222222
>>> remove_digit("2222222")
Traceback (most recent call last):
TypeError: only integers accepted as input
>>> remove_digit("string input")
Traceback (most recent call last):
TypeError: only integers accepted as input

File: segmented_sieve.py
 - Function 'sieve' takes 1 arguments: n.  Docstring: Segmented Sieve.

Examples:
>>> sieve(8)
[2, 3, 5, 7]

>>> sieve(27)
[2, 3, 5, 7, 11, 13, 17, 19, 23]

>>> sieve(0)
Traceback (most recent call last):
    ...
ValueError: Number 0 must instead be a positive integer

>>> sieve(-1)
Traceback (most recent call last):
    ...
ValueError: Number -1 must instead be a positive integer

>>> sieve(22.2)
Traceback (most recent call last):
    ...
ValueError: Number 22.2 must instead be a positive integer

File: sieve_of_eratosthenes.py
 - Function 'prime_sieve' takes 1 arguments: num.  Docstring: Returns a list with all prime numbers up to n.

>>> prime_sieve(50)
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
>>> prime_sieve(25)
[2, 3, 5, 7, 11, 13, 17, 19, 23]
>>> prime_sieve(10)
[2, 3, 5, 7]
>>> prime_sieve(9)
[2, 3, 5, 7]
>>> prime_sieve(2)
[2]
>>> prime_sieve(1)
[]

File: sigmoid.py
 - Function 'sigmoid' takes 1 arguments: vector.  Docstring: Implements the sigmoid function

Parameters:
    vector (np.array): A  numpy array of shape (1,n)
    consisting of real values

Returns:
    sigmoid_vec (np.array): The input numpy array, after applying
    sigmoid.

Examples:
>>> sigmoid(np.array([-1.0, 1.0, 2.0]))
array([0.26894142, 0.73105858, 0.88079708])

>>> sigmoid(np.array([0.0]))
array([0.5])

File: signum.py
 - Function 'signum' takes 1 arguments: num.  Docstring: Applies signum function on the number

Custom test cases:
>>> signum(-10)
-1
>>> signum(10)
1
>>> signum(0)
0
>>> signum(-20.5)
-1
>>> signum(20.5)
1
>>> signum(-1e-6)
-1
>>> signum(1e-6)
1
>>> signum("Hello")
Traceback (most recent call last):
    ...
TypeError: '<' not supported between instances of 'str' and 'int'
>>> signum([])
Traceback (most recent call last):
    ...
TypeError: '<' not supported between instances of 'list' and 'int'
 - Function 'test_signum' takes 0 arguments: .  Docstring: Tests the signum function
>>> test_signum()

File: simultaneous_linear_equation_solver.py
 - Function 'simplify' takes 1 arguments: current_set.  Docstring: >>> simplify([[1, 2, 3], [4, 5, 6]])
[[1.0, 2.0, 3.0], [0.0, 0.75, 1.5]]
>>> simplify([[5, 2, 5], [5, 1, 10]])
[[1.0, 0.4, 1.0], [0.0, 0.2, -1.0]]
 - Function 'solve_simultaneous' takes 1 arguments: equations.  Docstring: >>> solve_simultaneous([[1, 2, 3],[4, 5, 6]])
[-1.0, 2.0]
>>> solve_simultaneous([[0, -3, 1, 7],[3, 2, -1, 11],[5, 1, -2, 12]])
[6.4, 1.2, 10.6]
>>> solve_simultaneous([])
Traceback (most recent call last):
    ...
IndexError: solve_simultaneous() requires n lists of length n+1
>>> solve_simultaneous([[1, 2, 3],[1, 2]])
Traceback (most recent call last):
    ...
IndexError: solve_simultaneous() requires n lists of length n+1
>>> solve_simultaneous([[1, 2, 3],["a", 7, 8]])
Traceback (most recent call last):
    ...
ValueError: solve_simultaneous() requires lists of integers
>>> solve_simultaneous([[0, 2, 3],[4, 0, 6]])
Traceback (most recent call last):
    ...
ValueError: solve_simultaneous() requires at least 1 full equation

File: sin.py
 - Function 'sin' takes 3 arguments: angle_in_degrees, accuracy, rounded_values_count.  Docstring: Implement sin function.

>>> sin(0.0)
0.0
>>> sin(90.0)
1.0
>>> sin(180.0)
0.0
>>> sin(270.0)
-1.0
>>> sin(0.68)
0.0118679603
>>> sin(1.97)
0.0343762121
>>> sin(64.0)
0.8987940463
>>> sin(9999.0)
-0.9876883406
>>> sin(-689.0)
0.5150380749
>>> sin(89.7)
0.9999862922

File: sock_merchant.py
 - Function 'sock_merchant' takes 1 arguments: colors.  Docstring: >>> sock_merchant([10, 20, 20, 10, 10, 30, 50, 10, 20])
3
>>> sock_merchant([1, 1, 3, 3])
2

File: softmax.py
 - Function 'softmax' takes 1 arguments: vector.  Docstring: Implements the softmax function

Parameters:
    vector (np.array,list,tuple): A  numpy array of shape (1,n)
    consisting of real values or a similar list,tuple


Returns:
    softmax_vec (np.array): The input numpy array  after applying
    softmax.

The softmax vector adds up to one. We need to ceil to mitigate for
precision
>>> np.ceil(np.sum(softmax([1,2,3,4])))
1.0

>>> vec = np.array([5,5])
>>> softmax(vec)
array([0.5, 0.5])

>>> softmax([0])
array([1.])

File: solovay_strassen_primality_test.py
 - Function 'jacobi_symbol' takes 2 arguments: random_a, number.  Docstring: Calculate the Jacobi symbol. The Jacobi symbol is a generalization
of the Legendre symbol, which can be used to simplify computations involving
quadratic residues. The Jacobi symbol is used in primality tests, like the
Solovay-Strassen test, because it helps determine if an integer is a
quadratic residue modulo a given modulus, providing valuable information
about the number's potential primality or compositeness.

Parameters:
    random_a: A randomly chosen integer from 2 to n-2 (inclusive)
    number: The number that is tested for primality

Returns:
    jacobi_symbol: The Jacobi symbol is a mathematical function
    used to determine whether an integer is a quadratic residue modulo
    another integer (usually prime) or not.

>>> jacobi_symbol(2, 13)
-1
>>> jacobi_symbol(5, 19)
1
>>> jacobi_symbol(7, 14)
0
 - Function 'solovay_strassen' takes 2 arguments: number, iterations.  Docstring: Check whether the input number is prime or not using
the Solovay-Strassen Primality test

Parameters:
    number: The number that is tested for primality
    iterations: The number of times that the test is run
    which effects the accuracy

Returns:
    result: True if number is probably prime and false
    if not

>>> random.seed(10)
>>> solovay_strassen(13, 5)
True
>>> solovay_strassen(9, 10)
False
>>> solovay_strassen(17, 15)
True

File: spearman_rank_correlation_coefficient.py
 - Function 'assign_ranks' takes 1 arguments: data.  Docstring: Assigns ranks to elements in the array.

:param data: List of floats.
:return: List of ints representing the ranks.

Example:
>>> assign_ranks([3.2, 1.5, 4.0, 2.7, 5.1])
[3, 1, 4, 2, 5]

>>> assign_ranks([10.5, 8.1, 12.4, 9.3, 11.0])
[3, 1, 5, 2, 4]
 - Function 'calculate_spearman_rank_correlation' takes 2 arguments: variable_1, variable_2.  Docstring: Calculates Spearman's rank correlation coefficient.

:param variable_1: List of floats representing the first variable.
:param variable_2: List of floats representing the second variable.
:return: Spearman's rank correlation coefficient.

Example Usage:

>>> x = [1, 2, 3, 4, 5]
>>> y = [5, 4, 3, 2, 1]
>>> calculate_spearman_rank_correlation(x, y)
-1.0

>>> x = [1, 2, 3, 4, 5]
>>> y = [2, 4, 6, 8, 10]
>>> calculate_spearman_rank_correlation(x, y)
1.0

>>> x = [1, 2, 3, 4, 5]
>>> y = [5, 1, 2, 9, 5]
>>> calculate_spearman_rank_correlation(x, y)
0.6

File: sumset.py
 - Function 'sumset' takes 2 arguments: set_a, set_b.  Docstring: :param first set: a set of numbers
:param second set: a set of numbers
:return: the nth number in Sylvester's sequence

>>> sumset({1, 2, 3}, {4, 5, 6})
{5, 6, 7, 8, 9}

>>> sumset({1, 2, 3}, {4, 5, 6, 7})
{5, 6, 7, 8, 9, 10}

>>> sumset({1, 2, 3, 4}, 3)
Traceback (most recent call last):
...
AssertionError: The input value of [set_b=3] is not a set

File: sum_of_arithmetic_series.py
 - Function 'sum_of_series' takes 3 arguments: first_term, common_diff, num_of_terms.  Docstring: Find the sum of n terms in an arithmetic progression.

>>> sum_of_series(1, 1, 10)
55.0
>>> sum_of_series(1, 10, 100)
49600.0
 - Function 'main' takes 0 arguments: .  No docstring available.

File: sum_of_digits.py
 - Function 'sum_of_digits' takes 1 arguments: n.  Docstring: Find the sum of digits of a number.
>>> sum_of_digits(12345)
15
>>> sum_of_digits(123)
6
>>> sum_of_digits(-123)
6
>>> sum_of_digits(0)
0
 - Function 'sum_of_digits_recursion' takes 1 arguments: n.  Docstring: Find the sum of digits of a number using recursion
>>> sum_of_digits_recursion(12345)
15
>>> sum_of_digits_recursion(123)
6
>>> sum_of_digits_recursion(-123)
6
>>> sum_of_digits_recursion(0)
0
 - Function 'sum_of_digits_compact' takes 1 arguments: n.  Docstring: Find the sum of digits of a number
>>> sum_of_digits_compact(12345)
15
>>> sum_of_digits_compact(123)
6
>>> sum_of_digits_compact(-123)
6
>>> sum_of_digits_compact(0)
0
 - Function 'benchmark' takes 0 arguments: .  Docstring: Benchmark multiple functions, with three different length int values.
 - Function 'benchmark_a_function' takes 2 arguments: func, value.  No docstring available.

File: sum_of_geometric_progression.py
 - Function 'sum_of_geometric_progression' takes 3 arguments: first_term, common_ratio, num_of_terms.  Docstring: "
Return the sum of n terms in a geometric progression.
>>> sum_of_geometric_progression(1, 2, 10)
1023.0
>>> sum_of_geometric_progression(1, 10, 5)
11111.0
>>> sum_of_geometric_progression(0, 2, 10)
0.0
>>> sum_of_geometric_progression(1, 0, 10)
1.0
>>> sum_of_geometric_progression(1, 2, 0)
-0.0
>>> sum_of_geometric_progression(-1, 2, 10)
-1023.0
>>> sum_of_geometric_progression(1, -2, 10)
-341.0
>>> sum_of_geometric_progression(1, 2, -10)
-0.9990234375

File: sum_of_harmonic_series.py
 - Function 'sum_of_harmonic_progression' takes 3 arguments: first_term, common_difference, number_of_terms.  Docstring: https://en.wikipedia.org/wiki/Harmonic_progression_(mathematics)

Find the sum of n terms in an harmonic progression.  The calculation starts with the
first_term and loops adding the common difference of Arithmetic Progression by which
the given Harmonic Progression is linked.

>>> sum_of_harmonic_progression(1 / 2, 2, 2)
0.75
>>> sum_of_harmonic_progression(1 / 5, 5, 5)
0.45666666666666667

File: sylvester_sequence.py
 - Function 'sylvester' takes 1 arguments: number.  Docstring: :param number: nth number to calculate in the sequence
:return: the nth number in Sylvester's sequence

>>> sylvester(8)
113423713055421844361000443

>>> sylvester(-1)
Traceback (most recent call last):
    ...
ValueError: The input value of [n=-1] has to be > 0

>>> sylvester(8.0)
Traceback (most recent call last):
    ...
AssertionError: The input value of [n=8.0] is not an integer

File: tanh.py
 - Function 'tangent_hyperbolic' takes 1 arguments: vector.  Docstring:     Implements the tanh function

    Parameters:
        vector: np.ndarray

    Returns:
        tanh (np.array): The input numpy array after applying tanh.

    mathematically (e^x - e^(-x))/(e^x + e^(-x)) can be written as (2/(1+e^(-2x))-1

Examples:
    >>> tangent_hyperbolic(np.array([1,5,6,-0.67]))
    array([ 0.76159416,  0.9999092 ,  0.99998771, -0.58497988])

    >>> tangent_hyperbolic(np.array([8,10,2,-0.98,13]))
    array([ 0.99999977,  1.        ,  0.96402758, -0.7530659 ,  1.        ])

File: test_prime_check.py

File: three_sum.py
 - Function 'three_sum' takes 1 arguments: nums.  Docstring: Find all unique triplets in a sorted array of integers that sum up to zero.

Args:
    nums: A sorted list of integers.

Returns:
    A list of lists containing unique triplets that sum up to zero.

>>> three_sum([-1, 0, 1, 2, -1, -4])
[[-1, -1, 2], [-1, 0, 1]]
>>> three_sum([1, 2, 3, 4])
[]

File: trapezoidal_rule.py
 - Function 'method_1' takes 2 arguments: boundary, steps.  No docstring available.
 - Function 'make_points' takes 3 arguments: a, b, h.  No docstring available.
 - Function 'f' takes 1 arguments: x.  No docstring available.
 - Function 'main' takes 0 arguments: .  No docstring available.

File: triplet_sum.py
 - Function 'make_dataset' takes 0 arguments: .  No docstring available.
 - Function 'triplet_sum1' takes 2 arguments: arr, target.  Docstring: Returns a triplet in the array with sum equal to target,
else (0, 0, 0).
>>> triplet_sum1([13, 29, 7, 23, 5], 35)
(5, 7, 23)
>>> triplet_sum1([37, 9, 19, 50, 44], 65)
(9, 19, 37)
>>> arr = [6, 47, 27, 1, 15]
>>> target = 11
>>> triplet_sum1(arr, target)
(0, 0, 0)
 - Function 'triplet_sum2' takes 2 arguments: arr, target.  Docstring: Returns a triplet in the array with sum equal to target,
else (0, 0, 0).
>>> triplet_sum2([13, 29, 7, 23, 5], 35)
(5, 7, 23)
>>> triplet_sum2([37, 9, 19, 50, 44], 65)
(9, 19, 37)
>>> arr = [6, 47, 27, 1, 15]
>>> target = 11
>>> triplet_sum2(arr, target)
(0, 0, 0)
 - Function 'solution_times' takes 0 arguments: .  No docstring available.

File: twin_prime.py
 - Function 'twin_prime' takes 1 arguments: number.  Docstring: # doctest: +NORMALIZE_WHITESPACE
This functions takes an integer number as input.
returns n+2 if n and n+2 are prime numbers and -1 otherwise.
>>> twin_prime(3)
5
>>> twin_prime(4)
-1
>>> twin_prime(5)
7
>>> twin_prime(17)
19
>>> twin_prime(0)
-1
>>> twin_prime(6.0)
Traceback (most recent call last):
    ...
TypeError: Input value of [number=6.0] must be an integer

File: two_pointer.py
 - Function 'two_pointer' takes 2 arguments: nums, target.  Docstring: >>> two_pointer([2, 7, 11, 15], 9)
[0, 1]
>>> two_pointer([2, 7, 11, 15], 17)
[0, 3]
>>> two_pointer([2, 7, 11, 15], 18)
[1, 2]
>>> two_pointer([2, 7, 11, 15], 26)
[2, 3]
>>> two_pointer([1, 3, 3], 6)
[1, 2]
>>> two_pointer([2, 7, 11, 15], 8)
[]
>>> two_pointer([3 * i for i in range(10)], 19)
[]
>>> two_pointer([1, 2, 3], 6)
[]

File: two_sum.py
 - Function 'two_sum' takes 2 arguments: nums, target.  Docstring: >>> two_sum([2, 7, 11, 15], 9)
[0, 1]
>>> two_sum([15, 2, 11, 7], 13)
[1, 2]
>>> two_sum([2, 7, 11, 15], 17)
[0, 3]
>>> two_sum([7, 15, 11, 2], 18)
[0, 2]
>>> two_sum([2, 7, 11, 15], 26)
[2, 3]
>>> two_sum([2, 7, 11, 15], 8)
[]
>>> two_sum([3 * i for i in range(10)], 19)
[]

File: volume.py
 - Function 'vol_cube' takes 1 arguments: side_length.  Docstring: Calculate the Volume of a Cube.
>>> vol_cube(1)
1.0
>>> vol_cube(3)
27.0
>>> vol_cube(0)
0.0
>>> vol_cube(1.6)
4.096000000000001
>>> vol_cube(-1)
Traceback (most recent call last):
    ...
ValueError: vol_cube() only accepts non-negative values
 - Function 'vol_spherical_cap' takes 2 arguments: height, radius.  Docstring: Calculate the volume of the spherical cap.
>>> vol_spherical_cap(1, 2)
5.235987755982988
>>> vol_spherical_cap(1.6, 2.6)
16.621119532592402
>>> vol_spherical_cap(0, 0)
0.0
>>> vol_spherical_cap(-1, 2)
Traceback (most recent call last):
    ...
ValueError: vol_spherical_cap() only accepts non-negative values
>>> vol_spherical_cap(1, -2)
Traceback (most recent call last):
    ...
ValueError: vol_spherical_cap() only accepts non-negative values
 - Function 'vol_spheres_intersect' takes 3 arguments: radius_1, radius_2, centers_distance.  Docstring: Calculate the volume of the intersection of two spheres.
The intersection is composed by two spherical caps and therefore its volume is the
sum of the volumes of the spherical caps. First, it calculates the heights (h1, h2)
of the spherical caps, then the two volumes and it returns the sum.
The height formulas are
h1 = (radius_1 - radius_2 + centers_distance)
   * (radius_1 + radius_2 - centers_distance)
   / (2 * centers_distance)
h2 = (radius_2 - radius_1 + centers_distance)
   * (radius_2 + radius_1 - centers_distance)
   / (2 * centers_distance)
if centers_distance is 0 then it returns the volume of the smallers sphere
:return vol_spherical_cap(h1, radius_2) + vol_spherical_cap(h2, radius_1)
>>> vol_spheres_intersect(2, 2, 1)
21.205750411731103
>>> vol_spheres_intersect(2.6, 2.6, 1.6)
40.71504079052372
>>> vol_spheres_intersect(0, 0, 0)
0.0
>>> vol_spheres_intersect(-2, 2, 1)
Traceback (most recent call last):
    ...
ValueError: vol_spheres_intersect() only accepts non-negative values
>>> vol_spheres_intersect(2, -2, 1)
Traceback (most recent call last):
    ...
ValueError: vol_spheres_intersect() only accepts non-negative values
>>> vol_spheres_intersect(2, 2, -1)
Traceback (most recent call last):
    ...
ValueError: vol_spheres_intersect() only accepts non-negative values
 - Function 'vol_spheres_union' takes 3 arguments: radius_1, radius_2, centers_distance.  Docstring: Calculate the volume of the union of two spheres that possibly intersect.
It is the sum of sphere A and sphere B minus their intersection.
First, it calculates the volumes (v1, v2) of the spheres,
then the volume of the intersection (i) and it returns the sum v1+v2-i.
If centers_distance is 0 then it returns the volume of the larger sphere
:return vol_sphere(radius_1) + vol_sphere(radius_2)
            - vol_spheres_intersect(radius_1, radius_2, centers_distance)

>>> vol_spheres_union(2, 2, 1)
45.814892864851146
>>> vol_spheres_union(1.56, 2.2, 1.4)
48.77802773671288
>>> vol_spheres_union(0, 2, 1)
Traceback (most recent call last):
    ...
ValueError: vol_spheres_union() only accepts non-negative values, non-zero radius
>>> vol_spheres_union('1.56', '2.2', '1.4')
Traceback (most recent call last):
    ...
TypeError: '<=' not supported between instances of 'str' and 'int'
>>> vol_spheres_union(1, None, 1)
Traceback (most recent call last):
    ...
TypeError: '<=' not supported between instances of 'NoneType' and 'int'
 - Function 'vol_cuboid' takes 3 arguments: width, height, length.  Docstring: Calculate the Volume of a Cuboid.
:return multiple of width, length and height
>>> vol_cuboid(1, 1, 1)
1.0
>>> vol_cuboid(1, 2, 3)
6.0
>>> vol_cuboid(1.6, 2.6, 3.6)
14.976
>>> vol_cuboid(0, 0, 0)
0.0
>>> vol_cuboid(-1, 2, 3)
Traceback (most recent call last):
    ...
ValueError: vol_cuboid() only accepts non-negative values
>>> vol_cuboid(1, -2, 3)
Traceback (most recent call last):
    ...
ValueError: vol_cuboid() only accepts non-negative values
>>> vol_cuboid(1, 2, -3)
Traceback (most recent call last):
    ...
ValueError: vol_cuboid() only accepts non-negative values
 - Function 'vol_cone' takes 2 arguments: area_of_base, height.  Docstring: Calculate the Volume of a Cone.
Wikipedia reference: https://en.wikipedia.org/wiki/Cone
:return (1/3) * area_of_base * height
>>> vol_cone(10, 3)
10.0
>>> vol_cone(1, 1)
0.3333333333333333
>>> vol_cone(1.6, 1.6)
0.8533333333333335
>>> vol_cone(0, 0)
0.0
>>> vol_cone(-1, 1)
Traceback (most recent call last):
    ...
ValueError: vol_cone() only accepts non-negative values
>>> vol_cone(1, -1)
Traceback (most recent call last):
    ...
ValueError: vol_cone() only accepts non-negative values
 - Function 'vol_right_circ_cone' takes 2 arguments: radius, height.  Docstring: Calculate the Volume of a Right Circular Cone.
Wikipedia reference: https://en.wikipedia.org/wiki/Cone
:return (1/3) * pi * radius^2 * height
>>> vol_right_circ_cone(2, 3)
12.566370614359172
>>> vol_right_circ_cone(0, 0)
0.0
>>> vol_right_circ_cone(1.6, 1.6)
4.289321169701265
>>> vol_right_circ_cone(-1, 1)
Traceback (most recent call last):
    ...
ValueError: vol_right_circ_cone() only accepts non-negative values
>>> vol_right_circ_cone(1, -1)
Traceback (most recent call last):
    ...
ValueError: vol_right_circ_cone() only accepts non-negative values
 - Function 'vol_prism' takes 2 arguments: area_of_base, height.  Docstring: Calculate the Volume of a Prism.
Wikipedia reference: https://en.wikipedia.org/wiki/Prism_(geometry)
:return V = Bh
>>> vol_prism(10, 2)
20.0
>>> vol_prism(11, 1)
11.0
>>> vol_prism(1.6, 1.6)
2.5600000000000005
>>> vol_prism(0, 0)
0.0
>>> vol_prism(-1, 1)
Traceback (most recent call last):
    ...
ValueError: vol_prism() only accepts non-negative values
>>> vol_prism(1, -1)
Traceback (most recent call last):
    ...
ValueError: vol_prism() only accepts non-negative values
 - Function 'vol_pyramid' takes 2 arguments: area_of_base, height.  Docstring: Calculate the Volume of a Pyramid.
Wikipedia reference: https://en.wikipedia.org/wiki/Pyramid_(geometry)
:return  (1/3) * Bh
>>> vol_pyramid(10, 3)
10.0
>>> vol_pyramid(1.5, 3)
1.5
>>> vol_pyramid(1.6, 1.6)
0.8533333333333335
>>> vol_pyramid(0, 0)
0.0
>>> vol_pyramid(-1, 1)
Traceback (most recent call last):
    ...
ValueError: vol_pyramid() only accepts non-negative values
>>> vol_pyramid(1, -1)
Traceback (most recent call last):
    ...
ValueError: vol_pyramid() only accepts non-negative values
 - Function 'vol_sphere' takes 1 arguments: radius.  Docstring: Calculate the Volume of a Sphere.
Wikipedia reference: https://en.wikipedia.org/wiki/Sphere
:return (4/3) * pi * r^3
>>> vol_sphere(5)
523.5987755982989
>>> vol_sphere(1)
4.1887902047863905
>>> vol_sphere(1.6)
17.15728467880506
>>> vol_sphere(0)
0.0
>>> vol_sphere(-1)
Traceback (most recent call last):
    ...
ValueError: vol_sphere() only accepts non-negative values
 - Function 'vol_hemisphere' takes 1 arguments: radius.  Docstring: Calculate the volume of a hemisphere
Wikipedia reference: https://en.wikipedia.org/wiki/Hemisphere
Other references: https://www.cuemath.com/geometry/hemisphere
:return 2/3 * pi * radius^3
>>> vol_hemisphere(1)
2.0943951023931953
>>> vol_hemisphere(7)
718.377520120866
>>> vol_hemisphere(1.6)
8.57864233940253
>>> vol_hemisphere(0)
0.0
>>> vol_hemisphere(-1)
Traceback (most recent call last):
    ...
ValueError: vol_hemisphere() only accepts non-negative values
 - Function 'vol_circular_cylinder' takes 2 arguments: radius, height.  Docstring: Calculate the Volume of a Circular Cylinder.
Wikipedia reference: https://en.wikipedia.org/wiki/Cylinder
:return pi * radius^2 * height
>>> vol_circular_cylinder(1, 1)
3.141592653589793
>>> vol_circular_cylinder(4, 3)
150.79644737231007
>>> vol_circular_cylinder(1.6, 1.6)
12.867963509103795
>>> vol_circular_cylinder(0, 0)
0.0
>>> vol_circular_cylinder(-1, 1)
Traceback (most recent call last):
    ...
ValueError: vol_circular_cylinder() only accepts non-negative values
>>> vol_circular_cylinder(1, -1)
Traceback (most recent call last):
    ...
ValueError: vol_circular_cylinder() only accepts non-negative values
 - Function 'vol_hollow_circular_cylinder' takes 3 arguments: inner_radius, outer_radius, height.  Docstring: Calculate the Volume of a Hollow Circular Cylinder.
>>> vol_hollow_circular_cylinder(1, 2, 3)
28.274333882308138
>>> vol_hollow_circular_cylinder(1.6, 2.6, 3.6)
47.50088092227767
>>> vol_hollow_circular_cylinder(-1, 2, 3)
Traceback (most recent call last):
    ...
ValueError: vol_hollow_circular_cylinder() only accepts non-negative values
>>> vol_hollow_circular_cylinder(1, -2, 3)
Traceback (most recent call last):
    ...
ValueError: vol_hollow_circular_cylinder() only accepts non-negative values
>>> vol_hollow_circular_cylinder(1, 2, -3)
Traceback (most recent call last):
    ...
ValueError: vol_hollow_circular_cylinder() only accepts non-negative values
>>> vol_hollow_circular_cylinder(2, 1, 3)
Traceback (most recent call last):
    ...
ValueError: outer_radius must be greater than inner_radius
>>> vol_hollow_circular_cylinder(0, 0, 0)
Traceback (most recent call last):
    ...
ValueError: outer_radius must be greater than inner_radius
 - Function 'vol_conical_frustum' takes 3 arguments: height, radius_1, radius_2.  Docstring: Calculate the Volume of a Conical Frustum.
Wikipedia reference: https://en.wikipedia.org/wiki/Frustum

>>> vol_conical_frustum(45, 7, 28)
48490.482608158454
>>> vol_conical_frustum(1, 1, 2)
7.330382858376184
>>> vol_conical_frustum(1.6, 2.6, 3.6)
48.7240076620753
>>> vol_conical_frustum(0, 0, 0)
0.0
>>> vol_conical_frustum(-2, 2, 1)
Traceback (most recent call last):
    ...
ValueError: vol_conical_frustum() only accepts non-negative values
>>> vol_conical_frustum(2, -2, 1)
Traceback (most recent call last):
    ...
ValueError: vol_conical_frustum() only accepts non-negative values
>>> vol_conical_frustum(2, 2, -1)
Traceback (most recent call last):
    ...
ValueError: vol_conical_frustum() only accepts non-negative values
 - Function 'vol_torus' takes 2 arguments: torus_radius, tube_radius.  Docstring: Calculate the Volume of a Torus.
Wikipedia reference: https://en.wikipedia.org/wiki/Torus
:return 2pi^2 * torus_radius * tube_radius^2
>>> vol_torus(1, 1)
19.739208802178716
>>> vol_torus(4, 3)
710.6115168784338
>>> vol_torus(3, 4)
947.4820225045784
>>> vol_torus(1.6, 1.6)
80.85179925372404
>>> vol_torus(0, 0)
0.0
>>> vol_torus(-1, 1)
Traceback (most recent call last):
    ...
ValueError: vol_torus() only accepts non-negative values
>>> vol_torus(1, -1)
Traceback (most recent call last):
    ...
ValueError: vol_torus() only accepts non-negative values
 - Function 'vol_icosahedron' takes 1 arguments: tri_side.  Docstring: Calculate the Volume of an Icosahedron.
Wikipedia reference: https://en.wikipedia.org/wiki/Regular_icosahedron

>>> from math import isclose
>>> isclose(vol_icosahedron(2.5), 34.088984228514256)
True
>>> isclose(vol_icosahedron(10), 2181.694990624912374)
True
>>> isclose(vol_icosahedron(5), 272.711873828114047)
True
>>> isclose(vol_icosahedron(3.49), 92.740688412033628)
True
>>> vol_icosahedron(0)
0.0
>>> vol_icosahedron(-1)
Traceback (most recent call last):
    ...
ValueError: vol_icosahedron() only accepts non-negative values
>>> vol_icosahedron(-0.2)
Traceback (most recent call last):
    ...
ValueError: vol_icosahedron() only accepts non-negative values
 - Function 'main' takes 0 arguments: .  Docstring: Print the Results of Various Volume Calculations.

File: zellers_congruence.py
 - Function 'zeller' takes 1 arguments: date_input.  Docstring: Zellers Congruence Algorithm
Find the day of the week for nearly any Gregorian or Julian calendar date

>>> zeller('01-31-2010')
'Your date 01-31-2010, is a Sunday!'

Validate out of range month
>>> zeller('13-31-2010')
Traceback (most recent call last):
    ...
ValueError: Month must be between 1 - 12
>>> zeller('.2-31-2010')
Traceback (most recent call last):
    ...
ValueError: invalid literal for int() with base 10: '.2'

Validate out of range date:
>>> zeller('01-33-2010')
Traceback (most recent call last):
    ...
ValueError: Date must be between 1 - 31
>>> zeller('01-.4-2010')
Traceback (most recent call last):
    ...
ValueError: invalid literal for int() with base 10: '.4'

Validate second separator:
>>> zeller('01-31*2010')
Traceback (most recent call last):
    ...
ValueError: Date separator must be '-' or '/'

Validate first separator:
>>> zeller('01^31-2010')
Traceback (most recent call last):
    ...
ValueError: Date separator must be '-' or '/'

Validate out of range year:
>>> zeller('01-31-8999')
Traceback (most recent call last):
    ...
ValueError: Year out of range. There has to be some sort of limit...right?

Test null input:
>>> zeller()
Traceback (most recent call last):
    ...
TypeError: zeller() missing 1 required positional argument: 'date_input'

Test length of date_input:
>>> zeller('')
Traceback (most recent call last):
    ...
ValueError: Must be 10 characters long
>>> zeller('01-31-19082939')
Traceback (most recent call last):
    ...
ValueError: Must be 10 characters long

File: adams_bashforth.py
 - Function '__post_init__' takes 1 arguments: self.  No docstring available.
 - Function 'step_2' takes 1 arguments: self.  Docstring: >>> def f(x, y):
...     return x
>>> AdamsBashforth(f, [0, 0.2], [0, 0], 0.2, 1).step_2()
array([0.  , 0.  , 0.06, 0.16, 0.3 , 0.48])

>>> AdamsBashforth(f, [0, 0.2, 0.4], [0, 0, 0.04], 0.2, 1).step_2()
Traceback (most recent call last):
    ...
ValueError: Insufficient initial points information.
 - Function 'step_3' takes 1 arguments: self.  Docstring: >>> def f(x, y):
...     return x + y
>>> y = AdamsBashforth(f, [0, 0.2, 0.4], [0, 0, 0.04], 0.2, 1).step_3()
>>> y[3]
0.15533333333333332

>>> AdamsBashforth(f, [0, 0.2], [0, 0], 0.2, 1).step_3()
Traceback (most recent call last):
    ...
ValueError: Insufficient initial points information.
 - Function 'step_4' takes 1 arguments: self.  Docstring: >>> def f(x,y):
...     return x + y
>>> y = AdamsBashforth(
...    f, [0, 0.2, 0.4, 0.6], [0, 0, 0.04, 0.128], 0.2, 1).step_4()
>>> y[4]
0.30699999999999994
>>> y[5]
0.5771083333333333

>>> AdamsBashforth(f, [0, 0.2, 0.4], [0, 0, 0.04], 0.2, 1).step_4()
Traceback (most recent call last):
    ...
ValueError: Insufficient initial points information.
 - Function 'step_5' takes 1 arguments: self.  Docstring: >>> def f(x,y):
...     return x + y
>>> y = AdamsBashforth(
...     f, [0, 0.2, 0.4, 0.6, 0.8], [0, 0.02140, 0.02140, 0.22211, 0.42536],
...     0.2, 1).step_5()
>>> y[-1]
0.05436839444444452

>>> AdamsBashforth(f, [0, 0.2, 0.4], [0, 0, 0.04], 0.2, 1).step_5()
Traceback (most recent call last):
    ...
ValueError: Insufficient initial points information.

File: bisection.py
 - Function 'bisection' takes 3 arguments: function, a, b.  Docstring: finds where function becomes 0 in [a,b] using bolzano
>>> bisection(lambda x: x ** 3 - 1, -5, 5)
1.0000000149011612
>>> bisection(lambda x: x ** 3 - 1, 2, 1000)
Traceback (most recent call last):
    ...
ValueError: could not find root in given interval.
>>> bisection(lambda x: x ** 2 - 4 * x + 3, 0, 2)
1.0
>>> bisection(lambda x: x ** 2 - 4 * x + 3, 2, 4)
3.0
>>> bisection(lambda x: x ** 2 - 4 * x + 3, 4, 1000)
Traceback (most recent call last):
    ...
ValueError: could not find root in given interval.
 - Function 'f' takes 1 arguments: x.  No docstring available.

File: bisection_2.py
 - Function 'equation' takes 1 arguments: x.  Docstring: >>> equation(5)
-15
>>> equation(0)
10
>>> equation(-5)
-15
>>> equation(0.1)
9.99
>>> equation(-0.1)
9.99
 - Function 'bisection' takes 2 arguments: a, b.  Docstring: >>> bisection(-2, 5)
3.1611328125
>>> bisection(0, 6)
3.158203125
>>> bisection(2, 3)
Traceback (most recent call last):
    ...
ValueError: Wrong space!

File: integration_by_simpson_approx.py
 - Function 'f' takes 1 arguments: x.  No docstring available.
 - Function 'simpson_integration' takes 4 arguments: function, a, b, precision.  Docstring: Args:
    function : the function which's integration is desired
    a : the lower limit of integration
    b : upper limit of integration
    precision : precision of the result,error required default is 4

Returns:
    result : the value of the approximated integration of function in range a to b

Raises:
    AssertionError: function is not callable
    AssertionError: a is not float or integer
    AssertionError: function should return float or integer
    AssertionError: b is not float or integer
    AssertionError: precision is not positive integer

>>> simpson_integration(lambda x : x*x,1,2,3)
2.333

>>> simpson_integration(lambda x : x*x,'wrong_input',2,3)
Traceback (most recent call last):
    ...
AssertionError: a should be float or integer your input : wrong_input

>>> simpson_integration(lambda x : x*x,1,'wrong_input',3)
Traceback (most recent call last):
    ...
AssertionError: b should be float or integer your input : wrong_input

>>> simpson_integration(lambda x : x*x,1,2,'wrong_input')
Traceback (most recent call last):
    ...
AssertionError: precision should be positive integer your input : wrong_input
>>> simpson_integration('wrong_input',2,3,4)
Traceback (most recent call last):
    ...
AssertionError: the function(object) passed should be callable your input : ...

>>> simpson_integration(lambda x : x*x,3.45,3.2,1)
-2.8

>>> simpson_integration(lambda x : x*x,3.45,3.2,0)
Traceback (most recent call last):
    ...
AssertionError: precision should be positive integer your input : 0

>>> simpson_integration(lambda x : x*x,3.45,3.2,-1)
Traceback (most recent call last):
    ...
AssertionError: precision should be positive integer your input : -1

File: intersection.py
 - Function 'intersection' takes 3 arguments: function, x0, x1.  Docstring: function is the f we want to find its root
x0 and x1 are two random starting points
>>> intersection(lambda x: x ** 3 - 1, -5, 5)
0.9999999999954654
>>> intersection(lambda x: x ** 3 - 1, 5, 5)
Traceback (most recent call last):
    ...
ZeroDivisionError: float division by zero, could not find root
>>> intersection(lambda x: x ** 3 - 1, 100, 200)
1.0000000000003888
>>> intersection(lambda x: x ** 2 - 4 * x + 3, 0, 2)
0.9999999998088019
>>> intersection(lambda x: x ** 2 - 4 * x + 3, 2, 4)
2.9999999998088023
>>> intersection(lambda x: x ** 2 - 4 * x + 3, 4, 1000)
3.0000000001786042
>>> intersection(math.sin, -math.pi, math.pi)
0.0
>>> intersection(math.cos, -math.pi, math.pi)
Traceback (most recent call last):
    ...
ZeroDivisionError: float division by zero, could not find root
 - Function 'f' takes 1 arguments: x.  No docstring available.

File: nevilles_method.py
 - Function 'neville_interpolate' takes 3 arguments: x_points, y_points, x0.  Docstring:    Interpolate and evaluate a polynomial using Neville's method.
   Arguments:
       x_points, y_points: Iterables of x and corresponding y points through
        which the polynomial passes.
       x0: The value of x to evaluate the polynomial for.
   Return Value: A list of the approximated value and the Neville iterations
       table respectively.
>>> import pprint
>>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 5)[0]
10.0
>>> pprint.pprint(neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[1])
[[0, 6, 0, 0, 0],
 [0, 7, 0, 0, 0],
 [0, 8, 104.0, 0, 0],
 [0, 9, 104.0, 104.0, 0],
 [0, 11, 104.0, 104.0, 104.0]]
>>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), 99)[0]
104.0
>>> neville_interpolate((1,2,3,4,6), (6,7,8,9,11), '')
Traceback (most recent call last):
    ...
TypeError: unsupported operand type(s) for -: 'str' and 'int'

File: newton_forward_interpolation.py
 - Function 'ucal' takes 2 arguments: u, p.  Docstring: >>> ucal(1, 2)
0
>>> ucal(1.1, 2)
0.11000000000000011
>>> ucal(1.2, 2)
0.23999999999999994
 - Function 'main' takes 0 arguments: .  No docstring available.

File: newton_raphson.py
 - Function 'calc_derivative' takes 3 arguments: f, x, delta_x.  Docstring: Approximate the derivative of a function f(x) at a point x using the finite
difference method

>>> import math
>>> tolerance = 1e-5
>>> derivative = calc_derivative(lambda x: x**2, 2)
>>> math.isclose(derivative, 4, abs_tol=tolerance)
True
>>> derivative = calc_derivative(math.sin, 0)
>>> math.isclose(derivative, 1, abs_tol=tolerance)
True
 - Function 'newton_raphson' takes 6 arguments: f, x0, max_iter, step, max_error, log_steps.  Docstring: Find a root of the given function f using the Newton-Raphson method.

:param f: A real-valued single-variable function
:param x0: Initial guess
:param max_iter: Maximum number of iterations
:param step: Step size of x, used to approximate f'(x)
:param max_error: Maximum approximation error
:param log_steps: bool denoting whether to log intermediate steps

:return: A tuple containing the approximation, the error, and the intermediate
    steps. If log_steps is False, then an empty list is returned for the third
    element of the tuple.

:raises ZeroDivisionError: The derivative approaches 0.
:raises ArithmeticError: No solution exists, or the solution isn't found before the
    iteration limit is reached.

>>> import math
>>> tolerance = 1e-15
>>> root, *_ = newton_raphson(lambda x: x**2 - 5*x + 2, 0.4, max_error=tolerance)
>>> math.isclose(root, (5 - math.sqrt(17)) / 2, abs_tol=tolerance)
True
>>> root, *_ = newton_raphson(lambda x: math.log(x) - 1, 2, max_error=tolerance)
>>> math.isclose(root, math.e, abs_tol=tolerance)
True
>>> root, *_ = newton_raphson(math.sin, 1, max_error=tolerance)
>>> math.isclose(root, 0, abs_tol=tolerance)
True
>>> newton_raphson(math.cos, 0)
Traceback (most recent call last):
...
ZeroDivisionError: No converging solution found, zero derivative
>>> newton_raphson(lambda x: x**2 + 1, 2)
Traceback (most recent call last):
...
ArithmeticError: No converging solution found, iteration limit reached
 - Function 'f_derivative' takes 1 arguments: x.  No docstring available.
 - Function 'func' takes 1 arguments: x.  No docstring available.

File: numerical_integration.py
 - Function 'trapezoidal_area' takes 4 arguments: fnc, x_start, x_end, steps.  Docstring: Treats curve as a collection of linear lines and sums the area of the
trapezium shape they form
:param fnc: a function which defines a curve
:param x_start: left end point to indicate the start of line segment
:param x_end: right end point to indicate end of line segment
:param steps: an accuracy gauge; more steps increases the accuracy
:return: a float representing the length of the curve

>>> def f(x):
...    return 5
>>> '%.3f' % trapezoidal_area(f, 12.0, 14.0, 1000)
'10.000'

>>> def f(x):
...    return 9*x**2
>>> '%.4f' % trapezoidal_area(f, -4.0, 0, 10000)
'192.0000'

>>> '%.4f' % trapezoidal_area(f, -4.0, 4.0, 10000)
'384.0000'
 - Function 'f' takes 1 arguments: x.  No docstring available.

File: proper_fractions.py
 - Function 'proper_fractions' takes 1 arguments: denominator.  Docstring: this algorithm returns a list of proper fractions, in the
range between 0 and 1, which can be formed with the given denominator
https://en.wikipedia.org/wiki/Fraction#Proper_and_improper_fractions

>>> proper_fractions(10)
['1/10', '3/10', '7/10', '9/10']
>>> proper_fractions(5)
['1/5', '2/5', '3/5', '4/5']
>>> proper_fractions(-15)
Traceback (most recent call last):
    ...
ValueError: The Denominator Cannot be less than 0
>>> proper_fractions(0)
[]
>>> proper_fractions(1.2)
Traceback (most recent call last):
    ...
ValueError: The Denominator must be an integer

File: runge_kutta.py
 - Function 'runge_kutta' takes 5 arguments: f, y0, x0, h, x_end.  Docstring: Calculate the numeric solution at each step to the ODE f(x, y) using RK4

https://en.wikipedia.org/wiki/Runge-Kutta_methods

Arguments:
f -- The ode as a function of x and y
y0 -- the initial value for y
x0 -- the initial value for x
h -- the stepsize
x_end -- the end value for x

>>> # the exact solution is math.exp(x)
>>> def f(x, y):
...     return y
>>> y0 = 1
>>> y = runge_kutta(f, y0, 0.0, 0.01, 5)
>>> y[-1]
148.41315904125113

File: runge_kutta_fehlberg_45.py
 - Function 'runge_kutta_fehlberg_45' takes 5 arguments: func, x_initial, y_initial, step_size, x_final.  Docstring: Solve an Ordinary Differential Equations using Runge-Kutta-Fehlberg Method (rkf45)
of order 5.

https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta%E2%80%93Fehlberg_method

args:
func: An ordinary differential equation (ODE) as function of x and y.
x_initial: The initial value of x.
y_initial: The initial value of y.
step_size: The increment value of x.
x_final: The final value of x.

Returns:
    Solution of y at each nodal point

# exact value of y[1] is tan(0.2) = 0.2027100937470787
>>> def f(x, y):
...     return 1 + y**2
>>> y = runge_kutta_fehlberg_45(f, 0, 0, 0.2, 1)
>>> y[1]
0.2027100937470787
>>> def f(x,y):
...     return x
>>> y = runge_kutta_fehlberg_45(f, -1, 0, 0.2, 0)
>>> y[1]
-0.18000000000000002
>>> y = runge_kutta_fehlberg_45(5, 0, 0, 0.1, 1)
Traceback (most recent call last):
    ...
TypeError: 'int' object is not callable
>>> def f(x, y):
...     return x + y
>>> y = runge_kutta_fehlberg_45(f, 0, 0, 0.2, -1)
Traceback (most recent call last):
    ...
ValueError: The final value of x must be greater than initial value of x.
>>> def f(x, y):
...     return x
>>> y = runge_kutta_fehlberg_45(f, -1, 0, -0.2, 0)
Traceback (most recent call last):
    ...
ValueError: Step size must be positive.

File: runge_kutta_gills.py
 - Function 'runge_kutta_gills' takes 5 arguments: func, x_initial, y_initial, step_size, x_final.  Docstring: Solve an Ordinary Differential Equations using Runge-Kutta-Gills Method of order 4.

args:
func: An ordinary differential equation (ODE) as function of x and y.
x_initial: The initial value of x.
y_initial: The initial value of y.
step_size: The increment value of x.
x_final: The final value of x.

Returns:
    Solution of y at each nodal point

>>> def f(x, y):
...     return (x-y)/2
>>> y = runge_kutta_gills(f, 0, 3, 0.2, 5)
>>> y[-1]
3.4104259225717537

>>> def f(x,y):
...     return x
>>> y = runge_kutta_gills(f, -1, 0, 0.2, 0)
>>> y
array([ 0.  , -0.18, -0.32, -0.42, -0.48, -0.5 ])

>>> def f(x, y):
...     return x + y
>>> y = runge_kutta_gills(f, 0, 0, 0.2, -1)
Traceback (most recent call last):
    ...
ValueError: The final value of x must be greater than initial value of x.

>>> def f(x, y):
...     return x
>>> y = runge_kutta_gills(f, -1, 0, -0.2, 0)
Traceback (most recent call last):
    ...
ValueError: Step size must be positive.

File: secant_method.py
 - Function 'f' takes 1 arguments: x.  Docstring: >>> f(5)
39.98652410600183
 - Function 'secant_method' takes 3 arguments: lower_bound, upper_bound, repeats.  Docstring: >>> secant_method(1, 3, 2)
0.2139409276214589

File: simpson_rule.py
 - Function 'method_2' takes 2 arguments: boundary, steps.  Docstring: Calculate the definite integral of a function using Simpson's Rule.
:param boundary: A list containing the lower and upper bounds of integration.
:param steps: The number of steps or resolution for the integration.
:return: The approximate integral value.

>>> round(method_2([0, 2, 4], 10), 10)
2.6666666667
>>> round(method_2([2, 0], 10), 10)
-0.2666666667
>>> round(method_2([-2, -1], 10), 10)
2.172
>>> round(method_2([0, 1], 10), 10)
0.3333333333
>>> round(method_2([0, 2], 10), 10)
2.6666666667
>>> round(method_2([0, 2], 100), 10)
2.5621226667
>>> round(method_2([0, 1], 1000), 10)
0.3320026653
>>> round(method_2([0, 2], 0), 10)
Traceback (most recent call last):
    ...
ZeroDivisionError: Number of steps must be greater than zero
>>> round(method_2([0, 2], -10), 10)
Traceback (most recent call last):
    ...
ZeroDivisionError: Number of steps must be greater than zero
 - Function 'make_points' takes 3 arguments: a, b, h.  No docstring available.
 - Function 'f' takes 1 arguments: x.  No docstring available.
 - Function 'main' takes 0 arguments: .  No docstring available.

File: square_root.py
 - Function 'fx' takes 2 arguments: x, a.  No docstring available.
 - Function 'fx_derivative' takes 1 arguments: x.  No docstring available.
 - Function 'get_initial_point' takes 1 arguments: a.  No docstring available.
 - Function 'square_root_iterative' takes 3 arguments: a, max_iter, tolerance.  Docstring: Square root approximated using Newton's method.
https://en.wikipedia.org/wiki/Newton%27s_method

>>> all(abs(square_root_iterative(i) - math.sqrt(i)) <= 1e-14 for i in range(500))
True

>>> square_root_iterative(-1)
Traceback (most recent call last):
    ...
ValueError: math domain error

>>> square_root_iterative(4)
2.0

>>> square_root_iterative(3.2)
1.788854381999832

>>> square_root_iterative(140)
11.832159566199232

File: single_indeterminate_operations.py
 - Function '__init__' takes 3 arguments: self, degree, coefficients.  Docstring: The coefficients should be in order of degree, from smallest to largest.
>>> p = Polynomial(2, [1, 2, 3])
>>> p = Polynomial(2, [1, 2, 3, 4])
Traceback (most recent call last):
...
ValueError: The number of coefficients should be equal to the degree + 1.
 - Function '__add__' takes 2 arguments: self, polynomial_2.  Docstring: Polynomial addition
>>> p = Polynomial(2, [1, 2, 3])
>>> q = Polynomial(2, [1, 2, 3])
>>> p + q
6x^2 + 4x + 2
 - Function '__sub__' takes 2 arguments: self, polynomial_2.  Docstring: Polynomial subtraction
>>> p = Polynomial(2, [1, 2, 4])
>>> q = Polynomial(2, [1, 2, 3])
>>> p - q
1x^2
 - Function '__neg__' takes 1 arguments: self.  Docstring: Polynomial negation
>>> p = Polynomial(2, [1, 2, 3])
>>> -p
 - 3x^2 - 2x - 1
 - Function '__mul__' takes 2 arguments: self, polynomial_2.  Docstring: Polynomial multiplication
>>> p = Polynomial(2, [1, 2, 3])
>>> q = Polynomial(2, [1, 2, 3])
>>> p * q
9x^4 + 12x^3 + 10x^2 + 4x + 1
 - Function 'evaluate' takes 2 arguments: self, substitution.  Docstring: Evaluates the polynomial at x.
>>> p = Polynomial(2, [1, 2, 3])
>>> p.evaluate(2)
17
 - Function '__str__' takes 1 arguments: self.  Docstring: >>> p = Polynomial(2, [1, 2, 3])
>>> print(p)
3x^2 + 2x + 1
 - Function '__repr__' takes 1 arguments: self.  Docstring: >>> p = Polynomial(2, [1, 2, 3])
>>> p
3x^2 + 2x + 1
 - Function 'derivative' takes 1 arguments: self.  Docstring: Returns the derivative of the polynomial.
>>> p = Polynomial(2, [1, 2, 3])
>>> p.derivative()
6x + 2
 - Function 'integral' takes 2 arguments: self, constant.  Docstring: Returns the integral of the polynomial.
>>> p = Polynomial(2, [1, 2, 3])
>>> p.integral()
1.0x^3 + 1.0x^2 + 1.0x
 - Function '__eq__' takes 2 arguments: self, polynomial_2.  Docstring: Checks if two polynomials are equal.
>>> p = Polynomial(2, [1, 2, 3])
>>> q = Polynomial(2, [1, 2, 3])
>>> p == q
True
 - Function '__ne__' takes 2 arguments: self, polynomial_2.  Docstring: Checks if two polynomials are not equal.
>>> p = Polynomial(2, [1, 2, 3])
>>> q = Polynomial(2, [1, 2, 3])
>>> p != q
False

File: arithmetic.py
 - Function 'is_arithmetic_series' takes 1 arguments: series.  Docstring: checking whether the input series is arithmetic series or not
>>> is_arithmetic_series([2, 4, 6])
True
>>> is_arithmetic_series([3, 6, 12, 24])
False
>>> is_arithmetic_series([1, 2, 3])
True
>>> is_arithmetic_series(4)
Traceback (most recent call last):
    ...
ValueError: Input series is not valid, valid series - [2, 4, 6]
>>> is_arithmetic_series([])
Traceback (most recent call last):
    ...
ValueError: Input list must be a non empty list
 - Function 'arithmetic_mean' takes 1 arguments: series.  Docstring: return the arithmetic mean of series

>>> arithmetic_mean([2, 4, 6])
4.0
>>> arithmetic_mean([3, 6, 9, 12])
7.5
>>> arithmetic_mean(4)
Traceback (most recent call last):
    ...
ValueError: Input series is not valid, valid series - [2, 4, 6]
>>> arithmetic_mean([4, 8, 1])
4.333333333333333
>>> arithmetic_mean([1, 2, 3])
2.0
>>> arithmetic_mean([])
Traceback (most recent call last):
    ...
ValueError: Input list must be a non empty list

File: geometric.py
 - Function 'is_geometric_series' takes 1 arguments: series.  Docstring: checking whether the input series is geometric series or not
>>> is_geometric_series([2, 4, 8])
True
>>> is_geometric_series([3, 6, 12, 24])
True
>>> is_geometric_series([1, 2, 3])
False
>>> is_geometric_series([0, 0, 3])
False
>>> is_geometric_series([])
Traceback (most recent call last):
    ...
ValueError: Input list must be a non empty list
>>> is_geometric_series(4)
Traceback (most recent call last):
    ...
ValueError: Input series is not valid, valid series - [2, 4, 8]
 - Function 'geometric_mean' takes 1 arguments: series.  Docstring: return the geometric mean of series

>>> geometric_mean([2, 4, 8])
3.9999999999999996
>>> geometric_mean([3, 6, 12, 24])
8.48528137423857
>>> geometric_mean([4, 8, 16])
7.999999999999999
>>> geometric_mean(4)
Traceback (most recent call last):
    ...
ValueError: Input series is not valid, valid series - [2, 4, 8]
>>> geometric_mean([1, 2, 3])
1.8171205928321397
>>> geometric_mean([0, 2, 3])
0.0
>>> geometric_mean([])
Traceback (most recent call last):
    ...
ValueError: Input list must be a non empty list

File: geometric_series.py
 - Function 'geometric_series' takes 3 arguments: nth_term, start_term_a, common_ratio_r.  Docstring: Pure Python implementation of Geometric Series algorithm

:param nth_term: The last term (nth term of Geometric Series)
:param start_term_a : The first term of Geometric Series
:param common_ratio_r : The common ratio between all the terms
:return: The Geometric Series starting from first term a and multiple of common
    ration with first term with increase in power till last term (nth term)
Examples:
>>> geometric_series(4, 2, 2)
[2, 4.0, 8.0, 16.0]
>>> geometric_series(4.0, 2.0, 2.0)
[2.0, 4.0, 8.0, 16.0]
>>> geometric_series(4.1, 2.1, 2.1)
[2.1, 4.41, 9.261000000000001, 19.448100000000004]
>>> geometric_series(4, 2, -2)
[2, -4.0, 8.0, -16.0]
>>> geometric_series(4, -2, 2)
[-2, -4.0, -8.0, -16.0]
>>> geometric_series(-4, 2, 2)
[]
>>> geometric_series(0, 100, 500)
[]
>>> geometric_series(1, 1, 1)
[1]
>>> geometric_series(0, 0, 0)
[]

File: harmonic.py
 - Function 'is_harmonic_series' takes 1 arguments: series.  Docstring: checking whether the input series is arithmetic series or not
>>> is_harmonic_series([ 1, 2/3, 1/2, 2/5, 1/3])
True
>>> is_harmonic_series([ 1, 2/3, 2/5, 1/3])
False
>>> is_harmonic_series([1, 2, 3])
False
>>> is_harmonic_series([1/2, 1/3, 1/4])
True
>>> is_harmonic_series([2/5, 2/10, 2/15, 2/20, 2/25])
True
>>> is_harmonic_series(4)
Traceback (most recent call last):
    ...
ValueError: Input series is not valid, valid series - [1, 2/3, 2]
>>> is_harmonic_series([])
Traceback (most recent call last):
    ...
ValueError: Input list must be a non empty list
>>> is_harmonic_series([0])
Traceback (most recent call last):
    ...
ValueError: Input series cannot have 0 as an element
>>> is_harmonic_series([1,2,0,6])
Traceback (most recent call last):
    ...
ValueError: Input series cannot have 0 as an element
 - Function 'harmonic_mean' takes 1 arguments: series.  Docstring: return the harmonic mean of series

>>> harmonic_mean([1, 4, 4])
2.0
>>> harmonic_mean([3, 6, 9, 12])
5.759999999999999
>>> harmonic_mean(4)
Traceback (most recent call last):
    ...
ValueError: Input series is not valid, valid series - [2, 4, 6]
>>> harmonic_mean([1, 2, 3])
1.6363636363636365
>>> harmonic_mean([])
Traceback (most recent call last):
    ...
ValueError: Input list must be a non empty list

File: harmonic_series.py
 - Function 'harmonic_series' takes 1 arguments: n_term.  Docstring: Pure Python implementation of Harmonic Series algorithm

:param n_term: The last (nth) term of Harmonic Series
:return: The Harmonic Series starting from 1 to last (nth) term

Examples:
>>> harmonic_series(5)
['1', '1/2', '1/3', '1/4', '1/5']
>>> harmonic_series(5.0)
['1', '1/2', '1/3', '1/4', '1/5']
>>> harmonic_series(5.1)
['1', '1/2', '1/3', '1/4', '1/5']
>>> harmonic_series(-5)
[]
>>> harmonic_series(0)
[]
>>> harmonic_series(1)
['1']

File: hexagonal_numbers.py
 - Function 'hexagonal_numbers' takes 1 arguments: length.  Docstring: :param len: max number of elements
:type len: int
:return: Hexagonal numbers as a list

Tests:
>>> hexagonal_numbers(10)
[0, 1, 6, 15, 28, 45, 66, 91, 120, 153]
>>> hexagonal_numbers(5)
[0, 1, 6, 15, 28]
>>> hexagonal_numbers(0)
Traceback (most recent call last):
  ...
ValueError: Length must be a positive integer.

File: p_series.py
 - Function 'p_series' takes 2 arguments: nth_term, power.  Docstring: Pure Python implementation of P-Series algorithm
:return: The P-Series starting from 1 to last (nth) term
Examples:
>>> p_series(5, 2)
['1', '1 / 4', '1 / 9', '1 / 16', '1 / 25']
>>> p_series(-5, 2)
[]
>>> p_series(5, -2)
['1', '1 / 0.25', '1 / 0.1111111111111111', '1 / 0.0625', '1 / 0.04']
>>> p_series("", 1000)
['']
>>> p_series(0, 0)
[]
>>> p_series(1, 1)
['1']

File: armstrong_numbers.py
 - Function 'armstrong_number' takes 1 arguments: n.  Docstring: Return True if n is an Armstrong number or False if it is not.

>>> all(armstrong_number(n) for n in PASSING)
True
>>> any(armstrong_number(n) for n in FAILING)
False
 - Function 'pluperfect_number' takes 1 arguments: n.  Docstring: Return True if n is a pluperfect number or False if it is not

>>> all(armstrong_number(n) for n in PASSING)
True
>>> any(armstrong_number(n) for n in FAILING)
False
 - Function 'narcissistic_number' takes 1 arguments: n.  Docstring: Return True if n is a narcissistic number or False if it is not.

>>> all(armstrong_number(n) for n in PASSING)
True
>>> any(armstrong_number(n) for n in FAILING)
False
 - Function 'main' takes 0 arguments: .  Docstring: Request that user input an integer and tell them if it is Armstrong number.

File: automorphic_number.py
 - Function 'is_automorphic_number' takes 1 arguments: number.  Docstring: # doctest: +NORMALIZE_WHITESPACE
This functions takes an integer number as input.
returns True if the number is automorphic.
>>> is_automorphic_number(-1)
False
>>> is_automorphic_number(0)
True
>>> is_automorphic_number(5)
True
>>> is_automorphic_number(6)
True
>>> is_automorphic_number(7)
False
>>> is_automorphic_number(25)
True
>>> is_automorphic_number(259918212890625)
True
>>> is_automorphic_number(259918212890636)
False
>>> is_automorphic_number(740081787109376)
True
>>> is_automorphic_number(5.0)
Traceback (most recent call last):
    ...
TypeError: Input value of [number=5.0] must be an integer

File: bell_numbers.py
 - Function 'bell_numbers' takes 1 arguments: max_set_length.  Docstring: Calculate Bell numbers for the sets of lengths from 0 to max_set_length.
In other words, calculate first (max_set_length + 1) Bell numbers.

Args:
    max_set_length (int): The maximum length of the sets for which
    Bell numbers are calculated.

Returns:
    list: A list of Bell numbers for sets of lengths from 0 to max_set_length.

Examples:
>>> bell_numbers(0)
[1]
>>> bell_numbers(1)
[1, 1]
>>> bell_numbers(5)
[1, 1, 2, 5, 15, 52]
 - Function '_binomial_coefficient' takes 2 arguments: total_elements, elements_to_choose.  Docstring: Calculate the binomial coefficient C(total_elements, elements_to_choose)

Args:
    total_elements (int): The total number of elements.
    elements_to_choose (int): The number of elements to choose.

Returns:
    int: The binomial coefficient C(total_elements, elements_to_choose).

Examples:
>>> _binomial_coefficient(5, 2)
10
>>> _binomial_coefficient(6, 3)
20

File: carmichael_number.py
 - Function 'power' takes 3 arguments: x, y, mod.  Docstring: Examples:
>>> power(2, 15, 3)
2
>>> power(5, 1, 30)
5
 - Function 'is_carmichael_number' takes 1 arguments: n.  Docstring: Examples:
>>> is_carmichael_number(4)
False
>>> is_carmichael_number(561)
True
>>> is_carmichael_number(562)
False
>>> is_carmichael_number(900)
False
>>> is_carmichael_number(1105)
True
>>> is_carmichael_number(8911)
True
>>> is_carmichael_number(5.1)
Traceback (most recent call last):
     ...
ValueError: Number 5.1 must instead be a positive integer

>>> is_carmichael_number(-7)
Traceback (most recent call last):
     ...
ValueError: Number -7 must instead be a positive integer

>>> is_carmichael_number(0)
Traceback (most recent call last):
     ...
ValueError: Number 0 must instead be a positive integer

File: catalan_number.py
 - Function 'catalan' takes 1 arguments: number.  Docstring: :param number: nth catalan number to calculate
:return: the nth catalan number
Note: A catalan number is only defined for positive integers

>>> catalan(5)
14
>>> catalan(0)
Traceback (most recent call last):
    ...
ValueError: Input value of [number=0] must be > 0
>>> catalan(-1)
Traceback (most recent call last):
    ...
ValueError: Input value of [number=-1] must be > 0
>>> catalan(5.0)
Traceback (most recent call last):
    ...
TypeError: Input value of [number=5.0] must be an integer

File: hamming_numbers.py
 - Function 'hamming' takes 1 arguments: n_element.  Docstring: This function creates an ordered list of n length as requested, and afterwards
returns the last value of the list. It must be given a positive integer.

:param n_element: The number of elements on the list
:return: The nth element of the list

>>> hamming(5)
[1, 2, 3, 4, 5]
>>> hamming(10)
[1, 2, 3, 4, 5, 6, 8, 9, 10, 12]
>>> hamming(15)
[1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24]

File: happy_number.py
 - Function 'is_happy_number' takes 1 arguments: number.  Docstring: A happy number is a number which eventually reaches 1 when replaced by the sum of
the square of each digit.

:param number: The number to check for happiness.
:return: True if the number is a happy number, False otherwise.

>>> is_happy_number(19)
True
>>> is_happy_number(2)
False
>>> is_happy_number(23)
True
>>> is_happy_number(1)
True
>>> is_happy_number(0)
Traceback (most recent call last):
    ...
ValueError: number=0 must be a positive integer
>>> is_happy_number(-19)
Traceback (most recent call last):
    ...
ValueError: number=-19 must be a positive integer
>>> is_happy_number(19.1)
Traceback (most recent call last):
    ...
ValueError: number=19.1 must be a positive integer
>>> is_happy_number("happy")
Traceback (most recent call last):
    ...
ValueError: number='happy' must be a positive integer

File: harshad_numbers.py
 - Function 'int_to_base' takes 2 arguments: number, base.  Docstring: Convert a given positive decimal integer to base 'base'.
Where 'base' ranges from 2 to 36.

Examples:
>>> int_to_base(23, 2)
'10111'
>>> int_to_base(58, 5)
'213'
>>> int_to_base(167, 16)
'A7'
>>> # bases below 2 and beyond 36 will error
>>> int_to_base(98, 1)
Traceback (most recent call last):
    ...
ValueError: 'base' must be between 2 and 36 inclusive
>>> int_to_base(98, 37)
Traceback (most recent call last):
    ...
ValueError: 'base' must be between 2 and 36 inclusive
 - Function 'sum_of_digits' takes 2 arguments: num, base.  Docstring: Calculate the sum of digit values in a positive integer
converted to the given 'base'.
Where 'base' ranges from 2 to 36.

Examples:
>>> sum_of_digits(103, 12)
'13'
>>> sum_of_digits(1275, 4)
'30'
>>> sum_of_digits(6645, 2)
'1001'
>>> # bases below 2 and beyond 36 will error
>>> sum_of_digits(543, 1)
Traceback (most recent call last):
    ...
ValueError: 'base' must be between 2 and 36 inclusive
>>> sum_of_digits(543, 37)
Traceback (most recent call last):
    ...
ValueError: 'base' must be between 2 and 36 inclusive
 - Function 'harshad_numbers_in_base' takes 2 arguments: limit, base.  Docstring: Finds all Harshad numbers smaller than num in base 'base'.
Where 'base' ranges from 2 to 36.

Examples:
>>> harshad_numbers_in_base(15, 2)
['1', '10', '100', '110', '1000', '1010', '1100']
>>> harshad_numbers_in_base(12, 34)
['1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B']
>>> harshad_numbers_in_base(12, 4)
['1', '2', '3', '10', '12', '20', '21']
>>> # bases below 2 and beyond 36 will error
>>> harshad_numbers_in_base(234, 37)
Traceback (most recent call last):
    ...
ValueError: 'base' must be between 2 and 36 inclusive
>>> harshad_numbers_in_base(234, 1)
Traceback (most recent call last):
    ...
ValueError: 'base' must be between 2 and 36 inclusive
 - Function 'is_harshad_number_in_base' takes 2 arguments: num, base.  Docstring: Determines whether n in base 'base' is a harshad number.
Where 'base' ranges from 2 to 36.

Examples:
>>> is_harshad_number_in_base(18, 10)
True
>>> is_harshad_number_in_base(21, 10)
True
>>> is_harshad_number_in_base(-21, 5)
False
>>> # bases below 2 and beyond 36 will error
>>> is_harshad_number_in_base(45, 37)
Traceback (most recent call last):
    ...
ValueError: 'base' must be between 2 and 36 inclusive
>>> is_harshad_number_in_base(45, 1)
Traceback (most recent call last):
    ...
ValueError: 'base' must be between 2 and 36 inclusive

File: hexagonal_number.py
 - Function 'hexagonal' takes 1 arguments: number.  Docstring: :param number: nth hexagonal number to calculate
:return: the nth hexagonal number
Note: A hexagonal number is only defined for positive integers
>>> hexagonal(4)
28
>>> hexagonal(11)
231
>>> hexagonal(22)
946
>>> hexagonal(0)
Traceback (most recent call last):
    ...
ValueError: Input must be a positive integer
>>> hexagonal(-1)
Traceback (most recent call last):
    ...
ValueError: Input must be a positive integer
>>> hexagonal(11.0)
Traceback (most recent call last):
    ...
TypeError: Input value of [number=11.0] must be an integer

File: krishnamurthy_number.py
 - Function 'factorial' takes 1 arguments: digit.  Docstring: >>> factorial(3)
6
>>> factorial(0)
1
>>> factorial(5)
120
 - Function 'krishnamurthy' takes 1 arguments: number.  Docstring: >>> krishnamurthy(145)
True
>>> krishnamurthy(240)
False
>>> krishnamurthy(1)
True

File: polygonal_numbers.py
 - Function 'polygonal_num' takes 2 arguments: num, sides.  Docstring: Returns the `num`th `sides`-gonal number. It is assumed that `num` >= 0 and
`sides` >= 3 (see for reference https://en.wikipedia.org/wiki/Polygonal_number).

>>> polygonal_num(0, 3)
0
>>> polygonal_num(3, 3)
6
>>> polygonal_num(5, 4)
25
>>> polygonal_num(2, 5)
5
>>> polygonal_num(-1, 0)
Traceback (most recent call last):
    ...
ValueError: Invalid input: num must be >= 0 and sides must be >= 3.
>>> polygonal_num(0, 2)
Traceback (most recent call last):
    ...
ValueError: Invalid input: num must be >= 0 and sides must be >= 3.

File: pronic_number.py
 - Function 'is_pronic' takes 1 arguments: number.  Docstring: # doctest: +NORMALIZE_WHITESPACE
This functions takes an integer number as input.
returns True if the number is pronic.
>>> is_pronic(-1)
False
>>> is_pronic(0)
True
>>> is_pronic(2)
True
>>> is_pronic(5)
False
>>> is_pronic(6)
True
>>> is_pronic(8)
False
>>> is_pronic(30)
True
>>> is_pronic(32)
False
>>> is_pronic(2147441940)
True
>>> is_pronic(9223372033963249500)
True
>>> is_pronic(6.0)
Traceback (most recent call last):
    ...
TypeError: Input value of [number=6.0] must be an integer

File: proth_number.py
 - Function 'proth' takes 1 arguments: number.  Docstring: :param number: nth number to calculate in the sequence
:return: the nth number in Proth number
Note: indexing starts at 1 i.e. proth(1) gives the first Proth number of 3
>>> proth(6)
25
>>> proth(0)
Traceback (most recent call last):
    ...
ValueError: Input value of [number=0] must be > 0
>>> proth(-1)
Traceback (most recent call last):
    ...
ValueError: Input value of [number=-1] must be > 0
>>> proth(6.0)
Traceback (most recent call last):
    ...
TypeError: Input value of [number=6.0] must be an integer

File: triangular_numbers.py
 - Function 'triangular_number' takes 1 arguments: position.  Docstring: Generate the triangular number at the specified position.

Args:
    position (int): The position of the triangular number to generate.

Returns:
    int: The triangular number at the specified position.

Raises:
    ValueError: If `position` is negative.

Examples:
>>> triangular_number(1)
1
>>> triangular_number(3)
6
>>> triangular_number(-1)
Traceback (most recent call last):
    ...
ValueError: param `position` must be non-negative

File: ugly_numbers.py
 - Function 'ugly_numbers' takes 1 arguments: n.  Docstring: Returns the nth ugly number.
>>> ugly_numbers(100)
1536
>>> ugly_numbers(0)
1
>>> ugly_numbers(20)
36
>>> ugly_numbers(-5)
1
>>> ugly_numbers(-5.5)
Traceback (most recent call last):
    ...
TypeError: 'float' object cannot be interpreted as an integer

File: weird_number.py
 - Function 'factors' takes 1 arguments: number.  Docstring: >>> factors(12)
[1, 2, 3, 4, 6]
>>> factors(1)
[1]
>>> factors(100)
[1, 2, 4, 5, 10, 20, 25, 50]

# >>> factors(-12)
# [1, 2, 3, 4, 6]
 - Function 'abundant' takes 1 arguments: n.  Docstring: >>> abundant(0)
True
>>> abundant(1)
False
>>> abundant(12)
True
>>> abundant(13)
False
>>> abundant(20)
True

# >>> abundant(-12)
# True
 - Function 'semi_perfect' takes 1 arguments: number.  Docstring: >>> semi_perfect(0)
True
>>> semi_perfect(1)
True
>>> semi_perfect(12)
True
>>> semi_perfect(13)
False

# >>> semi_perfect(-12)
# True
 - Function 'weird' takes 1 arguments: number.  Docstring: >>> weird(0)
False
>>> weird(70)
True
>>> weird(77)
False

File: binary_search_matrix.py
 - Function 'binary_search' takes 4 arguments: array, lower_bound, upper_bound, value.  Docstring: This function carries out Binary search on a 1d array and
return -1 if it do not exist
array: A 1d sorted array
value : the value meant to be searched
>>> matrix = [1, 4, 7, 11, 15]
>>> binary_search(matrix, 0, len(matrix) - 1, 1)
0
>>> binary_search(matrix, 0, len(matrix) - 1, 23)
-1
 - Function 'mat_bin_search' takes 2 arguments: value, matrix.  Docstring: This function loops over a 2d matrix and calls binarySearch on
the selected 1d array and returns [-1, -1] is it do not exist
value : value meant to be searched
matrix = a sorted 2d matrix
>>> matrix = [[1, 4, 7, 11, 15],
...           [2, 5, 8, 12, 19],
...           [3, 6, 9, 16, 22],
...           [10, 13, 14, 17, 24],
...           [18, 21, 23, 26, 30]]
>>> target = 1
>>> mat_bin_search(target, matrix)
[0, 0]
>>> target = 34
>>> mat_bin_search(target, matrix)
[-1, -1]

File: count_islands_in_matrix.py
 - Function '__init__' takes 4 arguments: self, row, col, graph.  No docstring available.
 - Function 'is_safe' takes 4 arguments: self, i, j, visited.  No docstring available.
 - Function 'diffs' takes 4 arguments: self, i, j, visited.  No docstring available.
 - Function 'count_islands' takes 1 arguments: self.  No docstring available.

File: count_negative_numbers_in_sorted_matrix.py
 - Function 'generate_large_matrix' takes 0 arguments: .  Docstring: >>> generate_large_matrix() # doctest: +ELLIPSIS
[[1000, ..., -999], [999, ..., -1001], ..., [2, ..., -1998]]
 - Function 'validate_grid' takes 1 arguments: grid.  Docstring: Validate that the rows and columns of the grid is sorted in decreasing order.
>>> for grid in test_grids:
...     validate_grid(grid)
 - Function 'find_negative_index' takes 1 arguments: array.  Docstring: Find the smallest negative index

>>> find_negative_index([0,0,0,0])
4
>>> find_negative_index([4,3,2,-1])
3
>>> find_negative_index([1,0,-1,-10])
2
>>> find_negative_index([0,0,0,-1])
3
>>> find_negative_index([11,8,7,-3,-5,-9])
3
>>> find_negative_index([-1,-1,-2,-3])
0
>>> find_negative_index([5,1,0])
3
>>> find_negative_index([-5,-5,-5])
0
>>> find_negative_index([0])
1
>>> find_negative_index([])
0
 - Function 'count_negatives_binary_search' takes 1 arguments: grid.  Docstring: An O(m logn) solution that uses binary search in order to find the boundary between
positive and negative numbers

>>> [count_negatives_binary_search(grid) for grid in test_grids]
[8, 0, 0, 3, 1498500]
 - Function 'count_negatives_brute_force' takes 1 arguments: grid.  Docstring: This solution is O(n^2) because it iterates through every column and row.

>>> [count_negatives_brute_force(grid) for grid in test_grids]
[8, 0, 0, 3, 1498500]
 - Function 'count_negatives_brute_force_with_break' takes 1 arguments: grid.  Docstring: Similar to the brute force solution above but uses break in order to reduce the
number of iterations.

>>> [count_negatives_brute_force_with_break(grid) for grid in test_grids]
[8, 0, 0, 3, 1498500]
 - Function 'benchmark' takes 0 arguments: .  Docstring: Benchmark our functions next to each other

File: count_paths.py
 - Function 'depth_first_search' takes 4 arguments: grid, row, col, visit.  Docstring: Recursive Backtracking Depth First Search Algorithm

Starting from top left of a matrix, count the number of
paths that can reach the bottom right of a matrix.
1 represents a block (inaccessible)
0 represents a valid space (accessible)

0  0  0  0
1  1  0  0
0  0  0  1
0  1  0  0
>>> grid = [[0, 0, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]
>>> depth_first_search(grid, 0, 0, set())
2

0  0  0  0  0
0  1  1  1  0
0  1  1  1  0
0  0  0  0  0
>>> grid = [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]
>>> depth_first_search(grid, 0, 0, set())
2

File: cramers_rule_2x2.py
 - Function 'cramers_rule_2x2' takes 2 arguments: equation1, equation2.  Docstring: Solves the system of linear equation in 2 variables.
:param: equation1: list of 3 numbers
:param: equation2: list of 3 numbers
:return: String of result
input format : [a1, b1, d1], [a2, b2, d2]
determinant = [[a1, b1], [a2, b2]]
determinant_x = [[d1, b1], [d2, b2]]
determinant_y = [[a1, d1], [a2, d2]]

>>> cramers_rule_2x2([2, 3, 0], [5, 1, 0])
(0.0, 0.0)
>>> cramers_rule_2x2([0, 4, 50], [2, 0, 26])
(13.0, 12.5)
>>> cramers_rule_2x2([11, 2, 30], [1, 0, 4])
(4.0, -7.0)
>>> cramers_rule_2x2([4, 7, 1], [1, 2, 0])
(2.0, -1.0)

>>> cramers_rule_2x2([1, 2, 3], [2, 4, 6])
Traceback (most recent call last):
    ...
ValueError: Infinite solutions. (Consistent system)
>>> cramers_rule_2x2([1, 2, 3], [2, 4, 7])
Traceback (most recent call last):
    ...
ValueError: No solution. (Inconsistent system)
>>> cramers_rule_2x2([1, 2, 3], [11, 22])
Traceback (most recent call last):
    ...
ValueError: Please enter a valid equation.
>>> cramers_rule_2x2([0, 1, 6], [0, 0, 3])
Traceback (most recent call last):
    ...
ValueError: No solution. (Inconsistent system)
>>> cramers_rule_2x2([0, 0, 6], [0, 0, 3])
Traceback (most recent call last):
    ...
ValueError: Both a & b of two equations can't be zero.
>>> cramers_rule_2x2([1, 2, 3], [1, 2, 3])
Traceback (most recent call last):
    ...
ValueError: Infinite solutions. (Consistent system)
>>> cramers_rule_2x2([0, 4, 50], [0, 3, 99])
Traceback (most recent call last):
    ...
ValueError: No solution. (Inconsistent system)

File: inverse_of_matrix.py
 - Function 'inverse_of_matrix' takes 1 arguments: matrix.  Docstring: A matrix multiplied with its inverse gives the identity matrix.
This function finds the inverse of a 2x2 and 3x3 matrix.
If the determinant of a matrix is 0, its inverse does not exist.

Sources for fixing inaccurate float arithmetic:
https://stackoverflow.com/questions/6563058/how-do-i-use-accurate-float-arithmetic-in-python
https://docs.python.org/3/library/decimal.html

Doctests for 2x2
>>> inverse_of_matrix([[2, 5], [2, 0]])
[[0.0, 0.5], [0.2, -0.2]]
>>> inverse_of_matrix([[2.5, 5], [1, 2]])
Traceback (most recent call last):
    ...
ValueError: This matrix has no inverse.
>>> inverse_of_matrix([[12, -16], [-9, 0]])
[[0.0, -0.1111111111111111], [-0.0625, -0.08333333333333333]]
>>> inverse_of_matrix([[12, 3], [16, 8]])
[[0.16666666666666666, -0.0625], [-0.3333333333333333, 0.25]]
>>> inverse_of_matrix([[10, 5], [3, 2.5]])
[[0.25, -0.5], [-0.3, 1.0]]

Doctests for 3x3
>>> inverse_of_matrix([[2, 5, 7], [2, 0, 1], [1, 2, 3]])
[[2.0, 5.0, -4.0], [1.0, 1.0, -1.0], [-5.0, -12.0, 10.0]]
>>> inverse_of_matrix([[1, 2, 2], [1, 2, 2], [3, 2, -1]])
Traceback (most recent call last):
    ...
ValueError: This matrix has no inverse.

>>> inverse_of_matrix([[],[]])
Traceback (most recent call last):
    ...
ValueError: Please provide a matrix of size 2x2 or 3x3.

>>> inverse_of_matrix([[1, 2], [3, 4], [5, 6]])
Traceback (most recent call last):
    ...
ValueError: Please provide a matrix of size 2x2 or 3x3.

>>> inverse_of_matrix([[1, 2, 1], [0,3, 4]])
Traceback (most recent call last):
    ...
ValueError: Please provide a matrix of size 2x2 or 3x3.

>>> inverse_of_matrix([[1, 2, 3], [7, 8, 9], [7, 8, 9]])
Traceback (most recent call last):
    ...
ValueError: This matrix has no inverse.

>>> inverse_of_matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
[[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]

File: largest_square_area_in_matrix.py
 - Function 'largest_square_area_in_matrix_top_down_approch' takes 3 arguments: rows, cols, mat.  Docstring: Function updates the largest_square_area[0], if recursive call found
square with maximum area.

We aren't using dp_array here, so the time complexity would be exponential.

>>> largest_square_area_in_matrix_top_down_approch(2, 2, [[1,1], [1,1]])
2
>>> largest_square_area_in_matrix_top_down_approch(2, 2, [[0,0], [0,0]])
0
 - Function 'update_area_of_max_square' takes 2 arguments: row, col.  No docstring available.
 - Function 'largest_square_area_in_matrix_top_down_approch_with_dp' takes 3 arguments: rows, cols, mat.  Docstring: Function updates the largest_square_area[0], if recursive call found
square with maximum area.

We are using dp_array here, so the time complexity would be O(N^2).

>>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[1,1], [1,1]])
2
>>> largest_square_area_in_matrix_top_down_approch_with_dp(2, 2, [[0,0], [0,0]])
0
 - Function 'update_area_of_max_square_using_dp_array' takes 3 arguments: row, col, dp_array.  No docstring available.
 - Function 'largest_square_area_in_matrix_bottom_up' takes 3 arguments: rows, cols, mat.  Docstring: Function updates the largest_square_area, using bottom up approach.

>>> largest_square_area_in_matrix_bottom_up(2, 2, [[1,1], [1,1]])
2
>>> largest_square_area_in_matrix_bottom_up(2, 2, [[0,0], [0,0]])
0
 - Function 'largest_square_area_in_matrix_bottom_up_space_optimization' takes 3 arguments: rows, cols, mat.  Docstring: Function updates the largest_square_area, using bottom up
approach. with space optimization.

>>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[1,1], [1,1]])
2
>>> largest_square_area_in_matrix_bottom_up_space_optimization(2, 2, [[0,0], [0,0]])
0

File: matrix_class.py
 - Function '__init__' takes 2 arguments: self, rows.  No docstring available.
 - Function 'columns' takes 1 arguments: self.  No docstring available.
 - Function 'num_rows' takes 1 arguments: self.  No docstring available.
 - Function 'num_columns' takes 1 arguments: self.  No docstring available.
 - Function 'order' takes 1 arguments: self.  No docstring available.
 - Function 'is_square' takes 1 arguments: self.  No docstring available.
 - Function 'identity' takes 1 arguments: self.  No docstring available.
 - Function 'determinant' takes 1 arguments: self.  No docstring available.
 - Function 'is_invertable' takes 1 arguments: self.  No docstring available.
 - Function 'get_minor' takes 3 arguments: self, row, column.  No docstring available.
 - Function 'get_cofactor' takes 3 arguments: self, row, column.  No docstring available.
 - Function 'minors' takes 1 arguments: self.  No docstring available.
 - Function 'cofactors' takes 1 arguments: self.  No docstring available.
 - Function 'adjugate' takes 1 arguments: self.  No docstring available.
 - Function 'inverse' takes 1 arguments: self.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function '__str__' takes 1 arguments: self.  No docstring available.
 - Function 'add_row' takes 3 arguments: self, row, position.  No docstring available.
 - Function 'add_column' takes 3 arguments: self, column, position.  No docstring available.
 - Function '__eq__' takes 2 arguments: self, other.  No docstring available.
 - Function '__ne__' takes 2 arguments: self, other.  No docstring available.
 - Function '__neg__' takes 1 arguments: self.  No docstring available.
 - Function '__add__' takes 2 arguments: self, other.  No docstring available.
 - Function '__sub__' takes 2 arguments: self, other.  No docstring available.
 - Function '__mul__' takes 2 arguments: self, other.  No docstring available.
 - Function '__pow__' takes 2 arguments: self, other.  No docstring available.
 - Function 'dot_product' takes 3 arguments: cls, row, column.  No docstring available.

File: matrix_equalization.py
 - Function 'array_equalization' takes 2 arguments: vector, step_size.  Docstring: This algorithm equalizes all elements of the input vector
to a common value, by making the minimal number of
"updates" under the constraint of a step size (step_size).

>>> array_equalization([1, 1, 6, 2, 4, 6, 5, 1, 7, 2, 2, 1, 7, 2, 2], 4)
4
>>> array_equalization([22, 81, 88, 71, 22, 81, 632, 81, 81, 22, 92], 2)
5
>>> array_equalization([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 5)
0
>>> array_equalization([22, 22, 22, 33, 33, 33], 2)
2
>>> array_equalization([1, 2, 3], 0)
Traceback (most recent call last):
ValueError: Step size must be positive and non-zero.
>>> array_equalization([1, 2, 3], -1)
Traceback (most recent call last):
ValueError: Step size must be positive and non-zero.
>>> array_equalization([1, 2, 3], 0.5)
Traceback (most recent call last):
ValueError: Step size must be an integer.
>>> array_equalization([1, 2, 3], maxsize)
1

File: matrix_multiplication_recursion.py
 - Function 'is_square' takes 1 arguments: matrix.  Docstring: >>> is_square([])
True
>>> is_square(matrix_1_to_4)
True
>>> is_square(matrix_5_to_9_high)
False
 - Function 'matrix_multiply' takes 2 arguments: matrix_a, matrix_b.  Docstring: >>> matrix_multiply(matrix_1_to_4, matrix_5_to_8)
[[19, 22], [43, 50]]
 - Function 'matrix_multiply_recursive' takes 2 arguments: matrix_a, matrix_b.  Docstring: :param matrix_a: A square Matrix.
:param matrix_b: Another square Matrix with the same dimensions as matrix_a.
:return: Result of matrix_a * matrix_b.
:raises ValueError: If the matrices cannot be multiplied.

>>> matrix_multiply_recursive([], [])
[]
>>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_8)
[[19, 22], [43, 50]]
>>> matrix_multiply_recursive(matrix_count_up, matrix_unordered)
[[37, 61, 74, 61], [105, 165, 166, 129], [173, 269, 258, 197], [241, 373, 350, 265]]
>>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_9_wide)
Traceback (most recent call last):
    ...
ValueError: Invalid matrix dimensions
>>> matrix_multiply_recursive(matrix_1_to_4, matrix_5_to_9_high)
Traceback (most recent call last):
    ...
ValueError: Invalid matrix dimensions
>>> matrix_multiply_recursive(matrix_1_to_4, matrix_count_up)
Traceback (most recent call last):
    ...
ValueError: Invalid matrix dimensions
 - Function 'multiply' takes 6 arguments: i_loop, j_loop, k_loop, matrix_a, matrix_b, result.  Docstring: :param matrix_a: A square Matrix.
:param matrix_b: Another square Matrix with the same dimensions as matrix_a.
:param result: Result matrix
:param i: Index used for iteration during multiplication.
:param j: Index used for iteration during multiplication.
:param k: Index used for iteration during multiplication.
>>> 0 > 1  # Doctests in inner functions are never run
True

File: matrix_operation.py
 - Function 'add' takes 0 arguments: .  Docstring: >>> add([[1,2],[3,4]],[[2,3],[4,5]])
[[3, 5], [7, 9]]
>>> add([[1.2,2.4],[3,4]],[[2,3],[4,5]])
[[3.2, 5.4], [7, 9]]
>>> add([[1, 2], [4, 5]], [[3, 7], [3, 4]], [[3, 5], [5, 7]])
[[7, 14], [12, 16]]
>>> add([3], [4, 5])
Traceback (most recent call last):
  ...
TypeError: Expected a matrix, got int/list instead
 - Function 'subtract' takes 2 arguments: matrix_a, matrix_b.  Docstring: >>> subtract([[1,2],[3,4]],[[2,3],[4,5]])
[[-1, -1], [-1, -1]]
>>> subtract([[1,2.5],[3,4]],[[2,3],[4,5.5]])
[[-1, -0.5], [-1, -1.5]]
>>> subtract([3], [4, 5])
Traceback (most recent call last):
  ...
TypeError: Expected a matrix, got int/list instead
 - Function 'scalar_multiply' takes 2 arguments: matrix, n.  Docstring: >>> scalar_multiply([[1,2],[3,4]],5)
[[5, 10], [15, 20]]
>>> scalar_multiply([[1.4,2.3],[3,4]],5)
[[7.0, 11.5], [15, 20]]
 - Function 'multiply' takes 2 arguments: matrix_a, matrix_b.  Docstring: >>> multiply([[1,2],[3,4]],[[5,5],[7,5]])
[[19, 15], [43, 35]]
>>> multiply([[1,2.5],[3,4.5]],[[5,5],[7,5]])
[[22.5, 17.5], [46.5, 37.5]]
>>> multiply([[1, 2, 3]], [[2], [3], [4]])
[[20]]
 - Function 'identity' takes 1 arguments: n.  Docstring: :param n: dimension for nxn matrix
:type n: int
:return: Identity matrix of shape [n, n]
>>> identity(3)
[[1, 0, 0], [0, 1, 0], [0, 0, 1]]
 - Function 'transpose' takes 2 arguments: matrix, return_map.  Docstring: >>> transpose([[1,2],[3,4]]) # doctest: +ELLIPSIS
<map object at ...
>>> transpose([[1,2],[3,4]], return_map=False)
[[1, 3], [2, 4]]
>>> transpose([1, [2, 3]])
Traceback (most recent call last):
  ...
TypeError: Expected a matrix, got int/list instead
 - Function 'minor' takes 3 arguments: matrix, row, column.  Docstring: >>> minor([[1, 2], [3, 4]], 1, 1)
[[1]]
 - Function 'determinant' takes 1 arguments: matrix.  Docstring: >>> determinant([[1, 2], [3, 4]])
-2
>>> determinant([[1.5, 2.5], [3, 4]])
-1.5
 - Function 'inverse' takes 1 arguments: matrix.  Docstring: >>> inverse([[1, 2], [3, 4]])
[[-2.0, 1.0], [1.5, -0.5]]
>>> inverse([[1, 1], [1, 1]])
 - Function '_check_not_integer' takes 1 arguments: matrix.  No docstring available.
 - Function '_shape' takes 1 arguments: matrix.  No docstring available.
 - Function '_verify_matrix_sizes' takes 2 arguments: matrix_a, matrix_b.  No docstring available.
 - Function 'main' takes 0 arguments: .  No docstring available.

File: max_area_of_island.py
 - Function 'is_safe' takes 4 arguments: row, col, rows, cols.  Docstring: Checking whether coordinate (row, col) is valid or not.

>>> is_safe(0, 0, 5, 5)
True
>>> is_safe(-1,-1, 5, 5)
False
 - Function 'depth_first_search' takes 4 arguments: row, col, seen, mat.  Docstring: Returns the current area of the island

>>> depth_first_search(0, 0, set(), matrix)
0
 - Function 'find_max_area' takes 1 arguments: mat.  Docstring: Finds the area of all islands and returns the maximum area.

>>> find_max_area(matrix)
6

File: median_matrix.py
 - Function 'median' takes 1 arguments: matrix.  Docstring: Calculate the median of a sorted matrix.

Args:
    matrix: A 2D matrix of integers.

Returns:
    The median value of the matrix.

Examples:
    >>> matrix = [[1, 3, 5], [2, 6, 9], [3, 6, 9]]
    >>> median(matrix)
    5

    >>> matrix = [[1, 2, 3], [4, 5, 6]]
    >>> median(matrix)
    3

File: nth_fibonacci_using_matrix_exponentiation.py
 - Function 'multiply' takes 2 arguments: matrix_a, matrix_b.  No docstring available.
 - Function 'identity' takes 1 arguments: n.  No docstring available.
 - Function 'nth_fibonacci_matrix' takes 1 arguments: n.  Docstring: >>> nth_fibonacci_matrix(100)
354224848179261915075
>>> nth_fibonacci_matrix(-100)
-100
 - Function 'nth_fibonacci_bruteforce' takes 1 arguments: n.  Docstring: >>> nth_fibonacci_bruteforce(100)
354224848179261915075
>>> nth_fibonacci_bruteforce(-100)
-100
 - Function 'main' takes 0 arguments: .  No docstring available.

File: pascal_triangle.py
 - Function 'print_pascal_triangle' takes 1 arguments: num_rows.  Docstring: Print Pascal's triangle for different number of rows
>>> print_pascal_triangle(5)
    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1
 - Function 'generate_pascal_triangle' takes 1 arguments: num_rows.  Docstring: Create Pascal's triangle for different number of rows
>>> generate_pascal_triangle(0)
[]
>>> generate_pascal_triangle(1)
[[1]]
>>> generate_pascal_triangle(2)
[[1], [1, 1]]
>>> generate_pascal_triangle(3)
[[1], [1, 1], [1, 2, 1]]
>>> generate_pascal_triangle(4)
[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]]
>>> generate_pascal_triangle(5)
[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]
>>> generate_pascal_triangle(-5)
Traceback (most recent call last):
    ...
ValueError: The input value of 'num_rows' should be greater than or equal to 0
>>> generate_pascal_triangle(7.89)
Traceback (most recent call last):
    ...
TypeError: The input value of 'num_rows' should be 'int'
 - Function 'populate_current_row' takes 2 arguments: triangle, current_row_idx.  Docstring: >>> triangle = [[1]]
>>> populate_current_row(triangle, 1)
[1, 1]
 - Function 'calculate_current_element' takes 4 arguments: triangle, current_row, current_row_idx, current_col_idx.  Docstring: >>> triangle = [[1], [1, 1]]
>>> current_row = [1, -1, 1]
>>> calculate_current_element(triangle, current_row, 2, 1)
>>> current_row
[1, 2, 1]
 - Function 'generate_pascal_triangle_optimized' takes 1 arguments: num_rows.  Docstring: This function returns a matrix representing the corresponding pascal's triangle
according to the given input of number of rows of Pascal's triangle to be generated.
It reduces the operations done to generate a row by half
by eliminating redundant calculations.

:param num_rows: Integer specifying the number of rows in the Pascal's triangle
:return: 2-D List (matrix) representing the Pascal's triangle

Return the Pascal's triangle of given rows
>>> generate_pascal_triangle_optimized(3)
[[1], [1, 1], [1, 2, 1]]
>>> generate_pascal_triangle_optimized(1)
[[1]]
>>> generate_pascal_triangle_optimized(0)
[]
>>> generate_pascal_triangle_optimized(-5)
Traceback (most recent call last):
    ...
ValueError: The input value of 'num_rows' should be greater than or equal to 0
>>> generate_pascal_triangle_optimized(7.89)
Traceback (most recent call last):
    ...
TypeError: The input value of 'num_rows' should be 'int'
 - Function 'benchmark' takes 0 arguments: .  Docstring: Benchmark multiple functions, with three different length int values.
 - Function 'benchmark_a_function' takes 2 arguments: func, value.  No docstring available.

File: rotate_matrix.py
 - Function 'make_matrix' takes 1 arguments: row_size.  Docstring: >>> make_matrix()
[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]
>>> make_matrix(1)
[[1]]
>>> make_matrix(-2)
[[1, 2], [3, 4]]
>>> make_matrix(3)
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> make_matrix() == make_matrix(4)
True
 - Function 'rotate_90' takes 1 arguments: matrix.  Docstring: >>> rotate_90(make_matrix())
[[4, 8, 12, 16], [3, 7, 11, 15], [2, 6, 10, 14], [1, 5, 9, 13]]
>>> rotate_90(make_matrix()) == transpose(reverse_column(make_matrix()))
True
 - Function 'rotate_180' takes 1 arguments: matrix.  Docstring: >>> rotate_180(make_matrix())
[[16, 15, 14, 13], [12, 11, 10, 9], [8, 7, 6, 5], [4, 3, 2, 1]]
>>> rotate_180(make_matrix()) == reverse_column(reverse_row(make_matrix()))
True
 - Function 'rotate_270' takes 1 arguments: matrix.  Docstring: >>> rotate_270(make_matrix())
[[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]
>>> rotate_270(make_matrix()) == transpose(reverse_row(make_matrix()))
True
 - Function 'transpose' takes 1 arguments: matrix.  No docstring available.
 - Function 'reverse_row' takes 1 arguments: matrix.  No docstring available.
 - Function 'reverse_column' takes 1 arguments: matrix.  No docstring available.
 - Function 'print_matrix' takes 1 arguments: matrix.  No docstring available.

File: searching_in_sorted_matrix.py
 - Function 'search_in_a_sorted_matrix' takes 4 arguments: mat, m, n, key.  Docstring: >>> search_in_a_sorted_matrix(
...     [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 5)
Key 5 found at row- 1 column- 2
>>> search_in_a_sorted_matrix(
...     [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 21)
Key 21 not found
>>> search_in_a_sorted_matrix(
...     [[2.1, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 2.1)
Key 2.1 found at row- 1 column- 1
>>> search_in_a_sorted_matrix(
...     [[2.1, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 2.2)
Key 2.2 not found
 - Function 'main' takes 0 arguments: .  No docstring available.

File: sherman_morrison.py
 - Function '__init__' takes 4 arguments: self, row, column, default_value.  Docstring: <method Matrix.__init__>
Initialize matrix with given size and default value.
Example:
>>> a = Matrix(2, 3, 1)
>>> a
Matrix consist of 2 rows and 3 columns
[1, 1, 1]
[1, 1, 1]
 - Function '__str__' takes 1 arguments: self.  Docstring: <method Matrix.__str__>
Return string representation of this matrix.
 - Function 'single_line' takes 1 arguments: row_vector.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function 'validate_indices' takes 2 arguments: self, loc.  Docstring: <method Matrix.validate_indicies>
Check if given indices are valid to pick element from matrix.
Example:
>>> a = Matrix(2, 6, 0)
>>> a.validate_indices((2, 7))
False
>>> a.validate_indices((0, 0))
True
 - Function '__getitem__' takes 2 arguments: self, loc.  Docstring: <method Matrix.__getitem__>
Return array[row][column] where loc = (row, column).
Example:
>>> a = Matrix(3, 2, 7)
>>> a[1, 0]
7
 - Function '__setitem__' takes 3 arguments: self, loc, value.  Docstring: <method Matrix.__setitem__>
Set array[row][column] = value where loc = (row, column).
Example:
>>> a = Matrix(2, 3, 1)
>>> a[1, 2] = 51
>>> a
Matrix consist of 2 rows and 3 columns
[ 1,  1,  1]
[ 1,  1, 51]
 - Function '__add__' takes 2 arguments: self, another.  Docstring: <method Matrix.__add__>
Return self + another.
Example:
>>> a = Matrix(2, 1, -4)
>>> b = Matrix(2, 1, 3)
>>> a+b
Matrix consist of 2 rows and 1 columns
[-1]
[-1]
 - Function '__neg__' takes 1 arguments: self.  Docstring: <method Matrix.__neg__>
Return -self.
Example:
>>> a = Matrix(2, 2, 3)
>>> a[0, 1] = a[1, 0] = -2
>>> -a
Matrix consist of 2 rows and 2 columns
[-3,  2]
[ 2, -3]
 - Function '__sub__' takes 2 arguments: self, another.  No docstring available.
 - Function '__mul__' takes 2 arguments: self, another.  Docstring: <method Matrix.__mul__>
Return self * another.
Example:
>>> a = Matrix(2, 3, 1)
>>> a[0,2] = a[1,2] = 3
>>> a * -2
Matrix consist of 2 rows and 3 columns
[-2, -2, -6]
[-2, -2, -6]
 - Function 'transpose' takes 1 arguments: self.  Docstring: <method Matrix.transpose>
Return self^T.
Example:
>>> a = Matrix(2, 3)
>>> for r in range(2):
...     for c in range(3):
...             a[r,c] = r*c
...
>>> a.transpose()
Matrix consist of 3 rows and 2 columns
[0, 0]
[0, 1]
[0, 2]
 - Function 'sherman_morrison' takes 3 arguments: self, u, v.  Docstring: <method Matrix.sherman_morrison>
Apply Sherman-Morrison formula in O(n^2).
To learn this formula, please look this:
https://en.wikipedia.org/wiki/Sherman%E2%80%93Morrison_formula
This method returns (A + uv^T)^(-1) where A^(-1) is self. Returns None if it's
impossible to calculate.
Warning: This method doesn't check if self is invertible.
    Make sure self is invertible before execute this method.
Example:
>>> ainv = Matrix(3, 3, 0)
>>> for i in range(3): ainv[i,i] = 1
...
>>> u = Matrix(3, 1, 0)
>>> u[0,0], u[1,0], u[2,0] = 1, 2, -3
>>> v = Matrix(3, 1, 0)
>>> v[0,0], v[1,0], v[2,0] = 4, -2, 5
>>> ainv.sherman_morrison(u, v)
Matrix consist of 3 rows and 3 columns
[  1.2857142857142856, -0.14285714285714285,   0.3571428571428571]
[  0.5714285714285714,   0.7142857142857143,   0.7142857142857142]
[ -0.8571428571428571,  0.42857142857142855,  -0.0714285714285714]
 - Function 'test1' takes 0 arguments: .  No docstring available.
 - Function 'test2' takes 0 arguments: .  No docstring available.

File: spiral_print.py
 - Function 'check_matrix' takes 1 arguments: matrix.  No docstring available.
 - Function 'spiral_print_clockwise' takes 1 arguments: a.  Docstring: >>> spiral_print_clockwise([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
1
2
3
4
8
12
11
10
9
5
6
7
 - Function 'spiral_traversal' takes 1 arguments: matrix.  Docstring: >>> spiral_traversal([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]

Example:
matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
Algorithm:
    Step 1. first pop the 0 index list. (which is [1,2,3,4] and concatenate the
            output of [step 2])
    Step 2. Now perform matrix's Transpose operation (Change rows to column
            and vice versa) and reverse the resultant matrix.
    Step 3. Pass the output of [2nd step], to same recursive function till
            base case hits.
Dry Run:
Stage 1.
[1, 2, 3, 4] +   spiral_traversal([
    [8, 12], [7, 11], [6, 10], [5, 9]]
 ])
Stage 2.
[1, 2, 3, 4, 8, 12] + spiral_traversal([
    [11, 10, 9], [7, 6, 5]
])
Stage 3.
[1, 2, 3, 4, 8, 12, 11, 10, 9] + spiral_traversal([
    [5], [6], [7]
])
Stage 4.
[1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([
    [5], [6], [7]
])
Stage 5.
[1, 2, 3, 4, 8, 12, 11, 10, 9, 5] + spiral_traversal([[6, 7]])
Stage 6.
[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] + spiral_traversal([])

File: validate_sudoku_board.py
 - Function 'is_valid_sudoku_board' takes 1 arguments: sudoku_board.  Docstring: This function validates (but does not solve) a sudoku board.
The board may be valid but unsolvable.

>>> is_valid_sudoku_board([
...  ["5","3",".",".","7",".",".",".","."]
... ,["6",".",".","1","9","5",".",".","."]
... ,[".","9","8",".",".",".",".","6","."]
... ,["8",".",".",".","6",".",".",".","3"]
... ,["4",".",".","8",".","3",".",".","1"]
... ,["7",".",".",".","2",".",".",".","6"]
... ,[".","6",".",".",".",".","2","8","."]
... ,[".",".",".","4","1","9",".",".","5"]
... ,[".",".",".",".","8",".",".","7","9"]
... ])
True
>>> is_valid_sudoku_board([
...  ["8","3",".",".","7",".",".",".","."]
... ,["6",".",".","1","9","5",".",".","."]
... ,[".","9","8",".",".",".",".","6","."]
... ,["8",".",".",".","6",".",".",".","3"]
... ,["4",".",".","8",".","3",".",".","1"]
... ,["7",".",".",".","2",".",".",".","6"]
... ,[".","6",".",".",".",".","2","8","."]
... ,[".",".",".","4","1","9",".",".","5"]
... ,[".",".",".",".","8",".",".","7","9"]
... ])
False
>>> is_valid_sudoku_board([
...  ["1","2","3","4","5","6","7","8","9"]
... ,["4","5","6","7","8","9","1","2","3"]
... ,["7","8","9","1","2","3","4","5","6"]
... ,[".",".",".",".",".",".",".",".","."]
... ,[".",".",".",".",".",".",".",".","."]
... ,[".",".",".",".",".",".",".",".","."]
... ,[".",".",".",".",".",".",".",".","."]
... ,[".",".",".",".",".",".",".",".","."]
... ,[".",".",".",".",".",".",".",".","."]
... ])
True
>>> is_valid_sudoku_board([
...  ["1","2","3",".",".",".",".",".","."]
... ,["4","5","6",".",".",".",".",".","."]
... ,["7","8","9",".",".",".",".",".","."]
... ,[".",".",".","4","5","6",".",".","."]
... ,[".",".",".","7","8","9",".",".","."]
... ,[".",".",".","1","2","3",".",".","."]
... ,[".",".",".",".",".",".","7","8","9"]
... ,[".",".",".",".",".",".","1","2","3"]
... ,[".",".",".",".",".",".","4","5","6"]
... ])
True
>>> is_valid_sudoku_board([
...  ["1","2","3",".",".",".","5","6","4"]
... ,["4","5","6",".",".",".","8","9","7"]
... ,["7","8","9",".",".",".","2","3","1"]
... ,[".",".",".","4","5","6",".",".","."]
... ,[".",".",".","7","8","9",".",".","."]
... ,[".",".",".","1","2","3",".",".","."]
... ,["3","1","2",".",".",".","7","8","9"]
... ,["6","4","5",".",".",".","1","2","3"]
... ,["9","7","8",".",".",".","4","5","6"]
... ])
True
>>> is_valid_sudoku_board([
...  ["1","2","3","4","5","6","7","8","9"]
... ,["2",".",".",".",".",".",".",".","8"]
... ,["3",".",".",".",".",".",".",".","7"]
... ,["4",".",".",".",".",".",".",".","6"]
... ,["5",".",".",".",".",".",".",".","5"]
... ,["6",".",".",".",".",".",".",".","4"]
... ,["7",".",".",".",".",".",".",".","3"]
... ,["8",".",".",".",".",".",".",".","2"]
... ,["9","8","7","6","5","4","3","2","1"]
... ])
False
>>> is_valid_sudoku_board([
...  ["1","2","3","8","9","7","5","6","4"]
... ,["4","5","6","2","3","1","8","9","7"]
... ,["7","8","9","5","6","4","2","3","1"]
... ,["2","3","1","4","5","6","9","7","8"]
... ,["5","6","4","7","8","9","3","1","2"]
... ,["8","9","7","1","2","3","6","4","5"]
... ,["3","1","2","6","4","5","7","8","9"]
... ,["6","4","5","9","7","8","1","2","3"]
... ,["9","7","8","3","1","2","4","5","6"]
... ])
True
>>> is_valid_sudoku_board([["1", "2", "3", "4", "5", "6", "7", "8", "9"]])
Traceback (most recent call last):
    ...
ValueError: Sudoku boards must be 9x9 squares.
>>> is_valid_sudoku_board(
...        [["1"], ["2"], ["3"], ["4"], ["5"], ["6"], ["7"], ["8"], ["9"]]
...  )
Traceback (most recent call last):
    ...
ValueError: Sudoku boards must be 9x9 squares.

File: test_matrix_operation.py
 - Function 'test_addition' takes 2 arguments: mat1, mat2.  No docstring available.
 - Function 'test_subtraction' takes 2 arguments: mat1, mat2.  No docstring available.
 - Function 'test_multiplication' takes 2 arguments: mat1, mat2.  No docstring available.
 - Function 'test_scalar_multiply' takes 0 arguments: .  No docstring available.
 - Function 'test_identity' takes 0 arguments: .  No docstring available.
 - Function 'test_transpose' takes 1 arguments: mat.  No docstring available.

File: ford_fulkerson.py
 - Function 'breadth_first_search' takes 4 arguments: graph, source, sink, parents.  Docstring: This function returns True if there is a node that has not iterated.

Args:
    graph: Adjacency matrix of graph
    source: Source
    sink: Sink
    parents: Parent list

Returns:
    True if there is a node that has not iterated.

>>> breadth_first_search(graph, 0, 5, [-1, -1, -1, -1, -1, -1])
True
>>> breadth_first_search(graph, 0, 6, [-1, -1, -1, -1, -1, -1])
Traceback (most recent call last):
    ...
IndexError: list index out of range
 - Function 'ford_fulkerson' takes 3 arguments: graph, source, sink.  Docstring: This function returns the maximum flow from source to sink in the given graph.

CAUTION: This function changes the given graph.

Args:
    graph: Adjacency matrix of graph
    source: Source
    sink: Sink

Returns:
    Maximum flow

>>> test_graph = [
...     [0, 16, 13, 0, 0, 0],
...     [0, 0, 10, 12, 0, 0],
...     [0, 4, 0, 0, 14, 0],
...     [0, 0, 9, 0, 0, 20],
...     [0, 0, 0, 7, 0, 4],
...     [0, 0, 0, 0, 0, 0],
... ]
>>> ford_fulkerson(test_graph, 0, 5)
23

File: minimum_cut.py
 - Function 'bfs' takes 4 arguments: graph, s, t, parent.  No docstring available.
 - Function 'mincut' takes 3 arguments: graph, source, sink.  Docstring: This array is filled by BFS and to store path
>>> mincut(test_graph, source=0, sink=5)
[(1, 3), (4, 3), (4, 5)]

File: back_propagation_neural_network.py
 - Function 'sigmoid' takes 1 arguments: x.  No docstring available.
 - Function '__init__' takes 5 arguments: self, units, activation, learning_rate, is_input_layer.  Docstring: common connected layer of bp network
:param units: numbers of neural units
:param activation: activation function
:param learning_rate: learning rate for paras
:param is_input_layer: whether it is input layer or not
 - Function 'initializer' takes 2 arguments: self, back_units.  No docstring available.
 - Function 'cal_gradient' takes 1 arguments: self.  No docstring available.
 - Function 'forward_propagation' takes 2 arguments: self, xdata.  No docstring available.
 - Function 'back_propagation' takes 2 arguments: self, gradient.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'add_layer' takes 2 arguments: self, layer.  No docstring available.
 - Function 'build' takes 1 arguments: self.  No docstring available.
 - Function 'summary' takes 1 arguments: self.  No docstring available.
 - Function 'train' takes 5 arguments: self, xdata, ydata, train_round, accuracy.  No docstring available.
 - Function 'cal_loss' takes 3 arguments: self, ydata, ydata_.  No docstring available.
 - Function 'plot_loss' takes 1 arguments: self.  No docstring available.
 - Function 'example' takes 0 arguments: .  No docstring available.

File: convolution_neural_network.py
 - Function '__init__' takes 8 arguments: self, conv1_get, size_p1, bp_num1, bp_num2, bp_num3, rate_w, rate_t.  Docstring: :param conv1_get: [a,c,d], size, number, step of convolution kernel
:param size_p1: pooling size
:param bp_num1: units number of flatten layer
:param bp_num2: units number of hidden layer
:param bp_num3: units number of output layer
:param rate_w: rate of weight learning
:param rate_t: rate of threshold learning
 - Function 'save_model' takes 2 arguments: self, save_path.  No docstring available.
 - Function 'read_model' takes 2 arguments: cls, model_path.  No docstring available.
 - Function 'sig' takes 2 arguments: self, x.  No docstring available.
 - Function 'do_round' takes 2 arguments: self, x.  No docstring available.
 - Function 'convolute' takes 6 arguments: self, data, convs, w_convs, thre_convs, conv_step.  No docstring available.
 - Function 'pooling' takes 4 arguments: self, featuremaps, size_pooling, pooling_type.  No docstring available.
 - Function '_expand' takes 2 arguments: self, data.  No docstring available.
 - Function '_expand_mat' takes 2 arguments: self, data_mat.  No docstring available.
 - Function '_calculate_gradient_from_pool' takes 6 arguments: self, out_map, pd_pool, num_map, size_map, size_pooling.  Docstring: calculate the gradient from the data slice of pool layer
pd_pool: list of matrix
out_map: the shape of data slice(size_map*size_map)
return: pd_all: list of matrix, [num, size_map, size_map]
 - Function 'train' takes 7 arguments: self, patterns, datas_train, datas_teach, n_repeat, error_accuracy, draw_e.  No docstring available.
 - Function 'draw_error' takes 0 arguments: .  No docstring available.
 - Function 'predict' takes 2 arguments: self, datas_test.  No docstring available.
 - Function 'convolution' takes 2 arguments: self, data.  No docstring available.

File: input_data.py
 - Function '_read32' takes 1 arguments: bytestream.  No docstring available.
 - Function '_extract_images' takes 1 arguments: f.  Docstring: Extract the images into a 4D uint8 numpy array [index, y, x, depth].

Args:
  f: A file object that can be passed into a gzip reader.

Returns:
  data: A 4D uint8 numpy array [index, y, x, depth].

Raises:
  ValueError: If the bytestream does not start with 2051.
 - Function '_dense_to_one_hot' takes 2 arguments: labels_dense, num_classes.  Docstring: Convert class labels from scalars to one-hot vectors.
 - Function '_extract_labels' takes 3 arguments: f, one_hot, num_classes.  Docstring: Extract the labels into a 1D uint8 numpy array [index].

Args:
  f: A file object that can be passed into a gzip reader.
  one_hot: Does one hot encoding for the result.
  num_classes: Number of classes for the one hot encoding.

Returns:
  labels: a 1D uint8 numpy array.

Raises:
  ValueError: If the bystream doesn't start with 2049.
 - Function '__init__' takes 8 arguments: self, images, labels, fake_data, one_hot, dtype, reshape, seed.  Docstring: Construct a _DataSet.

one_hot arg is used only if fake_data is true.  `dtype` can be either
`uint8` to leave the input as `[0, 255]`, or `float32` to rescale into
`[0, 1]`.  Seed arg provides for convenient deterministic testing.

Args:
  images: The images
  labels: The labels
  fake_data: Ignore inages and labels, use fake data.
  one_hot: Bool, return the labels as one hot vectors (if True) or ints (if
    False).
  dtype: Output image dtype. One of [uint8, float32]. `uint8` output has
    range [0,255]. float32 output has range [0,1].
  reshape: Bool. If True returned images are returned flattened to vectors.
  seed: The random seed to use.
 - Function 'images' takes 1 arguments: self.  No docstring available.
 - Function 'labels' takes 1 arguments: self.  No docstring available.
 - Function 'num_examples' takes 1 arguments: self.  No docstring available.
 - Function 'epochs_completed' takes 1 arguments: self.  No docstring available.
 - Function 'next_batch' takes 4 arguments: self, batch_size, fake_data, shuffle.  Docstring: Return the next `batch_size` examples from this data set.
 - Function '_maybe_download' takes 3 arguments: filename, work_directory, source_url.  Docstring: Download the data from source url, unless it's already here.

Args:
    filename: string, name of the file in the directory.
    work_directory: string, path to working directory.
    source_url: url to download from if file doesn't exist.

Returns:
    Path to resulting file.
 - Function 'read_data_sets' takes 8 arguments: train_dir, fake_data, one_hot, dtype, reshape, validation_size, seed, source_url.  No docstring available.
 - Function 'fake' takes 0 arguments: .  No docstring available.

File: simple_neural_network.py
 - Function 'sigmoid_function' takes 2 arguments: value, deriv.  Docstring: Return the sigmoid function of a float.

>>> sigmoid_function(3.5)
0.9706877692486436
>>> sigmoid_function(3.5, True)
-8.75
 - Function 'forward_propagation' takes 2 arguments: expected, number_propagations.  Docstring: Return the value found after the forward propagation training.

>>> res = forward_propagation(32, 450_000)  # Was 10_000_000
>>> res > 31 and res < 33
True

>>> res = forward_propagation(32, 1000)
>>> res > 31 and res < 33
False

File: two_hidden_layers_neural_network.py
 - Function '__init__' takes 3 arguments: self, input_array, output_array.  Docstring: This function initializes the TwoHiddenLayerNeuralNetwork class with random
weights for every layer and initializes predicted output with zeroes.

input_array : input values for training the neural network (i.e training data) .
output_array : expected output values of the given inputs.
 - Function 'feedforward' takes 1 arguments: self.  Docstring: The information moves in only one direction i.e. forward from the input nodes,
through the two hidden nodes and to the output nodes.
There are no cycles or loops in the network.

Return layer_between_second_hidden_layer_and_output
    (i.e the last layer of the neural network).

>>> input_val = np.array(([0, 0, 0], [0, 0, 0], [0, 0, 0]), dtype=float)
>>> output_val = np.array(([0], [0], [0]), dtype=float)
>>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)
>>> res = nn.feedforward()
>>> array_sum = np.sum(res)
>>> np.isnan(array_sum)
False
 - Function 'back_propagation' takes 1 arguments: self.  Docstring: Function for fine-tuning the weights of the neural net based on the
error rate obtained in the previous epoch (i.e., iteration).
Updation is done using derivative of sogmoid activation function.

>>> input_val = np.array(([0, 0, 0], [0, 0, 0], [0, 0, 0]), dtype=float)
>>> output_val = np.array(([0], [0], [0]), dtype=float)
>>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)
>>> res = nn.feedforward()
>>> nn.back_propagation()
>>> updated_weights = nn.second_hidden_layer_and_output_layer_weights
>>> (res == updated_weights).all()
False
 - Function 'train' takes 4 arguments: self, output, iterations, give_loss.  Docstring: Performs the feedforwarding and back propagation process for the
given number of iterations.
Every iteration will update the weights of neural network.

output : real output values,required for calculating loss.
iterations : number of times the weights are to be updated.
give_loss : boolean value, If True then prints loss for each iteration,
            If False then nothing is printed

>>> input_val = np.array(([0, 0, 0], [0, 1, 0], [0, 0, 1]), dtype=float)
>>> output_val = np.array(([0], [1], [1]), dtype=float)
>>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)
>>> first_iteration_weights = nn.feedforward()
>>> nn.back_propagation()
>>> updated_weights = nn.second_hidden_layer_and_output_layer_weights
>>> (first_iteration_weights == updated_weights).all()
False
 - Function 'predict' takes 2 arguments: self, input_arr.  Docstring: Predict's the output for the given input values using
the trained neural network.

The output value given by the model ranges in-between 0 and 1.
The predict function returns 1 if the model value is greater
than the threshold value else returns 0,
as the real output values are in binary.

>>> input_val = np.array(([0, 0, 0], [0, 1, 0], [0, 0, 1]), dtype=float)
>>> output_val = np.array(([0], [1], [1]), dtype=float)
>>> nn = TwoHiddenLayerNeuralNetwork(input_val, output_val)
>>> nn.train(output_val, 1000, False)
>>> nn.predict([0, 1, 0]) in (0, 1)
True
 - Function 'sigmoid' takes 1 arguments: value.  Docstring: Applies sigmoid activation function.

return normalized values

>>> sigmoid(np.array(([1, 0, 2], [1, 0, 0]), dtype=np.float64))
array([[0.73105858, 0.5       , 0.88079708],
       [0.73105858, 0.5       , 0.5       ]])
 - Function 'sigmoid_derivative' takes 1 arguments: value.  Docstring: Provides the derivative value of the sigmoid function.

returns derivative of the sigmoid value

>>> sigmoid_derivative(np.array(([1, 0, 2], [1, 0, 0]), dtype=np.float64))
array([[ 0.,  0., -2.],
       [ 0.,  0.,  0.]])
 - Function 'example' takes 0 arguments: .  Docstring: Example for "how to use the neural network class and use the
respected methods for the desired output".
Calls the TwoHiddenLayerNeuralNetwork class and
provides the fixed input output values to the model.
Model is trained for a fixed amount of iterations then the predict method is called.
In this example the output is divided into 2 classes i.e. binary classification,
the two classes are represented by '0' and '1'.

>>> example() in (0, 1)
True

File: binary_step.py
 - Function 'binary_step' takes 1 arguments: vector.  Docstring: Implements the binary step function

Parameters:
    vector (ndarray): A vector that consists of numeric values

Returns:
    vector (ndarray): Input vector after applying binary step function

>>> vector = np.array([-1.2, 0, 2, 1.45, -3.7, 0.3])
>>> binary_step(vector)
array([0, 1, 1, 1, 0, 1])

File: exponential_linear_unit.py
 - Function 'exponential_linear_unit' takes 2 arguments: vector, alpha.  Docstring:      Implements the ELU activation function.
     Parameters:
         vector: the array containing input of elu activation
         alpha: hyper-parameter
     return:
     elu (np.array): The input numpy array after applying elu.

     Mathematically, f(x) = x, x>0 else (alpha * (e^x -1)), x<=0, alpha >=0

Examples:
>>> exponential_linear_unit(vector=np.array([2.3,0.6,-2,-3.8]), alpha=0.3)
array([ 2.3       ,  0.6       , -0.25939942, -0.29328877])

>>> exponential_linear_unit(vector=np.array([-9.2,-0.3,0.45,-4.56]), alpha=0.067)
array([-0.06699323, -0.01736518,  0.45      , -0.06629904])

File: gaussian_error_linear_unit.py
 - Function 'sigmoid' takes 1 arguments: vector.  Docstring: Mathematical function sigmoid takes a vector x of K real numbers as input and
returns 1/ (1 + e^-x).
https://en.wikipedia.org/wiki/Sigmoid_function

>>> sigmoid(np.array([-1.0, 1.0, 2.0]))
array([0.26894142, 0.73105858, 0.88079708])
 - Function 'gaussian_error_linear_unit' takes 1 arguments: vector.  Docstring: Implements the Gaussian Error Linear Unit (GELU) function

Parameters:
    vector (np.ndarray): A  numpy array of shape (1, n) consisting of real values

Returns:
    gelu_vec (np.ndarray): The input numpy array, after applying gelu

Examples:
>>> gaussian_error_linear_unit(np.array([-1.0, 1.0, 2.0]))
array([-0.15420423,  0.84579577,  1.93565862])

>>> gaussian_error_linear_unit(np.array([-3]))
array([-0.01807131])

File: leaky_rectified_linear_unit.py
 - Function 'leaky_rectified_linear_unit' takes 2 arguments: vector, alpha.  Docstring:     Implements the LeakyReLU activation function.

    Parameters:
        vector (np.ndarray): The input array for LeakyReLU activation.
        alpha (float): The slope for negative values.

    Returns:
        np.ndarray: The input array after applying the LeakyReLU activation.

    Formula: f(x) = x if x > 0 else f(x) = alpha * x

Examples:
>>> leaky_rectified_linear_unit(vector=np.array([2.3,0.6,-2,-3.8]), alpha=0.3)
array([ 2.3 ,  0.6 , -0.6 , -1.14])

>>> leaky_rectified_linear_unit(np.array([-9.2, -0.3, 0.45, -4.56]), alpha=0.067)
array([-0.6164 , -0.0201 ,  0.45   , -0.30552])

File: mish.py
 - Function 'mish' takes 1 arguments: vector.  Docstring:     Implements the Mish activation function.

    Parameters:
        vector (np.ndarray): The input array for Mish activation.

    Returns:
        np.ndarray: The input array after applying the Mish activation.

    Formula:
        f(x) = x * tanh(softplus(x)) = x * tanh(ln(1 + e^x))

Examples:
>>> mish(vector=np.array([2.3,0.6,-2,-3.8]))
array([ 2.26211893,  0.46613649, -0.25250148, -0.08405831])

>>> mish(np.array([-9.2, -0.3, 0.45, -4.56]))
array([-0.00092952, -0.15113318,  0.33152014, -0.04745745])

File: rectified_linear_unit.py
 - Function 'relu' takes 1 arguments: vector.  Docstring: Implements the relu function

Parameters:
    vector (np.array,list,tuple): A  numpy array of shape (1,n)
    consisting of real values or a similar list,tuple


Returns:
    relu_vec (np.array): The input numpy array, after applying
    relu.

>>> vec = np.array([-1, 0, 5])
>>> relu(vec)
array([0, 0, 5])

File: scaled_exponential_linear_unit.py
 - Function 'scaled_exponential_linear_unit' takes 3 arguments: vector, alpha, lambda_.  Docstring: Applies the Scaled Exponential Linear Unit function to each element of the vector.
Parameters :
    vector : np.ndarray
    alpha : float (default = 1.6732)
    lambda_ : float (default = 1.0507)

Returns : np.ndarray
Formula : f(x) = lambda_ * x if x > 0
                 lambda_ * alpha * (e**x - 1) if x <= 0
Examples :
>>> scaled_exponential_linear_unit(vector=np.array([1.3, 3.7, 2.4]))
array([1.36591, 3.88759, 2.52168])

>>> scaled_exponential_linear_unit(vector=np.array([1.3, 4.7, 8.2]))
array([1.36591, 4.93829, 8.61574])

File: soboleva_modified_hyperbolic_tangent.py
 - Function 'soboleva_modified_hyperbolic_tangent' takes 5 arguments: vector, a_value, b_value, c_value, d_value.  Docstring: Implements the Soboleva Modified Hyperbolic Tangent function

Parameters:
    vector (ndarray): A vector that consists of numeric values
    a_value (float): parameter a of the equation
    b_value (float): parameter b of the equation
    c_value (float): parameter c of the equation
    d_value (float): parameter d of the equation

Returns:
    vector (ndarray): Input array after applying SMHT function

>>> vector = np.array([5.4, -2.4, 6.3, -5.23, 3.27, 0.56])
>>> soboleva_modified_hyperbolic_tangent(vector, 0.2, 0.4, 0.6, 0.8)
array([ 0.11075085, -0.28236685,  0.07861169, -0.1180085 ,  0.22999056,
        0.1566043 ])

File: softplus.py
 - Function 'softplus' takes 1 arguments: vector.  Docstring: Implements the Softplus activation function.

Parameters:
    vector (np.ndarray): The input array for the Softplus activation.

Returns:
    np.ndarray: The input array after applying the Softplus activation.

Formula: f(x) = ln(1 + e^x)

Examples:
>>> softplus(np.array([2.3, 0.6, -2, -3.8]))
array([2.39554546, 1.03748795, 0.12692801, 0.02212422])

>>> softplus(np.array([-9.2, -0.3, 0.45, -4.56]))
array([1.01034298e-04, 5.54355244e-01, 9.43248946e-01, 1.04077103e-02])

File: squareplus.py
 - Function 'squareplus' takes 2 arguments: vector, beta.  Docstring: Implements the SquarePlus activation function.

Parameters:
    vector (np.ndarray): The input array for the SquarePlus activation.
    beta (float): size of the curved region

Returns:
    np.ndarray: The input array after applying the SquarePlus activation.

Formula: f(x) = ( x + sqrt(x^2 + b) ) / 2

Examples:
>>> squareplus(np.array([2.3, 0.6, -2, -3.8]), beta=2)
array([2.5       , 1.06811457, 0.22474487, 0.12731349])

>>> squareplus(np.array([-9.2, -0.3, 0.45, -4.56]), beta=3)
array([0.0808119 , 0.72891979, 1.11977651, 0.15893419])

File: swish.py
 - Function 'sigmoid' takes 1 arguments: vector.  Docstring: Mathematical function sigmoid takes a vector x of K real numbers as input and
returns 1/ (1 + e^-x).
https://en.wikipedia.org/wiki/Sigmoid_function

>>> sigmoid(np.array([-1.0, 1.0, 2.0]))
array([0.26894142, 0.73105858, 0.88079708])
 - Function 'sigmoid_linear_unit' takes 1 arguments: vector.  Docstring: Implements the Sigmoid Linear Unit (SiLU) or swish function

Parameters:
    vector (np.ndarray): A  numpy array consisting of real values

Returns:
    swish_vec (np.ndarray): The input numpy array, after applying swish

Examples:
>>> sigmoid_linear_unit(np.array([-1.0, 1.0, 2.0]))
array([-0.26894142,  0.73105858,  1.76159416])

>>> sigmoid_linear_unit(np.array([-2]))
array([-0.23840584])
 - Function 'swish' takes 2 arguments: vector, trainable_parameter.  Docstring: Parameters:
    vector (np.ndarray): A  numpy array consisting of real values
    trainable_parameter: Use to implement various Swish Activation Functions

Returns:
    swish_vec (np.ndarray): The input numpy array, after applying swish

Examples:
>>> swish(np.array([-1.0, 1.0, 2.0]), 2)
array([-0.11920292,  0.88079708,  1.96402758])

>>> swish(np.array([-2]), 1)
array([-0.23840584])

File: activity_selection.py
 - Function 'print_max_activities' takes 2 arguments: start, finish.  Docstring: >>> start = [1, 3, 0, 5, 8, 5]
>>> finish = [2, 4, 6, 7, 9, 9]
>>> print_max_activities(start, finish)
The following activities are selected:
0,1,3,4,

File: alternative_list_arrange.py
 - Function 'alternative_list_arrange' takes 2 arguments: first_input_list, second_input_list.  Docstring: The method arranges two lists as one list in alternative forms of the list elements.
:param first_input_list:
:param second_input_list:
:return: List
>>> alternative_list_arrange([1, 2, 3, 4, 5], ["A", "B", "C"])
[1, 'A', 2, 'B', 3, 'C', 4, 5]
>>> alternative_list_arrange(["A", "B", "C"], [1, 2, 3, 4, 5])
['A', 1, 'B', 2, 'C', 3, 4, 5]
>>> alternative_list_arrange(["X", "Y", "Z"], [9, 8, 7, 6])
['X', 9, 'Y', 8, 'Z', 7, 6]
>>> alternative_list_arrange([1, 2, 3, 4, 5], [])
[1, 2, 3, 4, 5]

File: bankers_algorithm.py
 - Function '__init__' takes 4 arguments: self, claim_vector, allocated_resources_table, maximum_claim_table.  Docstring: :param claim_vector: A nxn/nxm list depicting the amount of each resources
 (eg. memory, interface, semaphores, etc.) available.
:param allocated_resources_table: A nxn/nxm list depicting the amount of each
 resource each process is currently holding
:param maximum_claim_table: A nxn/nxm list depicting how much of each resource
 the system currently has available
 - Function '__processes_resource_summation' takes 1 arguments: self.  Docstring: Check for allocated resources in line with each resource in the claim vector
 - Function '__available_resources' takes 1 arguments: self.  Docstring: Check for available resources in line with each resource in the claim vector
 - Function '__need' takes 1 arguments: self.  Docstring: Implement safety checker that calculates the needs by ensuring that
max_claim[i][j] - alloc_table[i][j] <= avail[j]
 - Function '__need_index_manager' takes 1 arguments: self.  Docstring: This function builds an index control dictionary to track original ids/indices
of processes when altered during execution of method "main"
    Return: {0: [a: int, b: int], 1: [c: int, d: int]}
>>> (BankersAlgorithm(test_claim_vector, test_allocated_res_table,
...     test_maximum_claim_table)._BankersAlgorithm__need_index_manager()
...     )  # doctest: +NORMALIZE_WHITESPACE
{0: [1, 2, 0, 3], 1: [0, 1, 3, 1], 2: [1, 1, 0, 2], 3: [1, 3, 2, 0],
 4: [2, 0, 0, 3]}
 - Function 'main' takes 1 arguments: self.  Docstring: Utilize various methods in this class to simulate the Banker's algorithm
Return: None
>>> BankersAlgorithm(test_claim_vector, test_allocated_res_table,
...    test_maximum_claim_table).main(describe=True)
         Allocated Resource Table
P1       2        0        1        1
<BLANKLINE>
P2       0        1        2        1
<BLANKLINE>
P3       4        0        0        3
<BLANKLINE>
P4       0        2        1        0
<BLANKLINE>
P5       1        0        3        0
<BLANKLINE>
         System Resource Table
P1       3        2        1        4
<BLANKLINE>
P2       0        2        5        2
<BLANKLINE>
P3       5        1        0        5
<BLANKLINE>
P4       1        5        3        0
<BLANKLINE>
P5       3        0        3        3
<BLANKLINE>
Current Usage by Active Processes: 8 5 9 7
Initial Available Resources:       1 2 2 2
__________________________________________________
<BLANKLINE>
Process 3 is executing.
Updated available resource stack for processes: 5 2 2 5
The process is in a safe state.
<BLANKLINE>
Process 1 is executing.
Updated available resource stack for processes: 7 2 3 6
The process is in a safe state.
<BLANKLINE>
Process 2 is executing.
Updated available resource stack for processes: 7 3 5 7
The process is in a safe state.
<BLANKLINE>
Process 4 is executing.
Updated available resource stack for processes: 7 5 6 7
The process is in a safe state.
<BLANKLINE>
Process 5 is executing.
Updated available resource stack for processes: 8 5 9 7
The process is in a safe state.
<BLANKLINE>
 - Function '__pretty_data' takes 1 arguments: self.  Docstring: Properly align display of the algorithm's solution

File: davis_putnam_logemann_loveland.py
 - Function '__init__' takes 2 arguments: self, literals.  Docstring: Represent the literals and an assignment in a clause."
 - Function '__str__' takes 1 arguments: self.  Docstring: To print a clause as in Conjunctive Normal Form.
>>> str(Clause(["A1", "A2'", "A3"]))
"{A1 , A2' , A3}"
 - Function '__len__' takes 1 arguments: self.  Docstring: To print a clause as in Conjunctive Normal Form.
>>> len(Clause([]))
0
>>> len(Clause(["A1", "A2'", "A3"]))
3
 - Function 'assign' takes 2 arguments: self, model.  Docstring: Assign values to literals of the clause as given by model.
 - Function 'evaluate' takes 2 arguments: self, model.  Docstring: Evaluates the clause with the assignments in model.
This has the following steps:
1. Return True if both a literal and its complement exist in the clause.
2. Return True if a single literal has the assignment True.
3. Return None(unable to complete evaluation) if a literal has no assignment.
4. Compute disjunction of all values assigned in clause.
 - Function '__init__' takes 2 arguments: self, clauses.  Docstring: Represent the number of clauses and the clauses themselves.
 - Function '__str__' takes 1 arguments: self.  Docstring: To print a formula as in Conjunctive Normal Form.
str(Formula([Clause(["A1", "A2'", "A3"]), Clause(["A5'", "A2'", "A1"])]))
"{{A1 , A2' , A3} , {A5' , A2' , A1}}"
 - Function 'generate_clause' takes 0 arguments: .  Docstring: Randomly generate a clause.
All literals have the name Ax, where x is an integer from 1 to 5.
 - Function 'generate_formula' takes 0 arguments: .  Docstring: Randomly generate a formula.
 - Function 'generate_parameters' takes 1 arguments: formula.  Docstring: Return the clauses and symbols from a formula.
A symbol is the uncomplemented form of a literal.
For example,
    Symbol of A3 is A3.
    Symbol of A5' is A5.

>>> formula = Formula([Clause(["A1", "A2'", "A3"]), Clause(["A5'", "A2'", "A1"])])
>>> clauses, symbols = generate_parameters(formula)
>>> clauses_list = [str(i) for i in clauses]
>>> clauses_list
["{A1 , A2' , A3}", "{A5' , A2' , A1}"]
>>> symbols
['A1', 'A2', 'A3', 'A5']
 - Function 'find_pure_symbols' takes 3 arguments: clauses, symbols, model.  Docstring: Return pure symbols and their values to satisfy clause.
Pure symbols are symbols in a formula that exist only
in one form, either complemented or otherwise.
For example,
    { { A4 , A3 , A5' , A1 , A3' } , { A4 } , { A3 } } has
    pure symbols A4, A5' and A1.
This has the following steps:
1. Ignore clauses that have already evaluated to be True.
2. Find symbols that occur only in one form in the rest of the clauses.
3. Assign value True or False depending on whether the symbols occurs
in normal or complemented form respectively.

>>> formula = Formula([Clause(["A1", "A2'", "A3"]), Clause(["A5'", "A2'", "A1"])])
>>> clauses, symbols = generate_parameters(formula)

>>> pure_symbols, values = find_pure_symbols(clauses, symbols, {})
>>> pure_symbols
['A1', 'A2', 'A3', 'A5']
>>> values
{'A1': True, 'A2': False, 'A3': True, 'A5': False}
 - Function 'find_unit_clauses' takes 2 arguments: clauses, model.  Docstring: Returns the unit symbols and their values to satisfy clause.
Unit symbols are symbols in a formula that are:
- Either the only symbol in a clause
- Or all other literals in that clause have been assigned False
This has the following steps:
1. Find symbols that are the only occurrences in a clause.
2. Find symbols in a clause where all other literals are assigned False.
3. Assign True or False depending on whether the symbols occurs in
normal or complemented form respectively.

>>> clause1 = Clause(["A4", "A3", "A5'", "A1", "A3'"])
>>> clause2 = Clause(["A4"])
>>> clause3 = Clause(["A3"])
>>> clauses, symbols = generate_parameters(Formula([clause1, clause2, clause3]))

>>> unit_clauses, values = find_unit_clauses(clauses, {})
>>> unit_clauses
['A4', 'A3']
>>> values
{'A4': True, 'A3': True}
 - Function 'dpll_algorithm' takes 3 arguments: clauses, symbols, model.  Docstring: Returns the model if the formula is satisfiable, else None
This has the following steps:
1. If every clause in clauses is True, return True.
2. If some clause in clauses is False, return False.
3. Find pure symbols.
4. Find unit symbols.

>>> formula = Formula([Clause(["A4", "A3", "A5'", "A1", "A3'"]), Clause(["A4"])])
>>> clauses, symbols = generate_parameters(formula)

>>> soln, model = dpll_algorithm(clauses, symbols, {})
>>> soln
True
>>> model
{'A4': True}

File: doomsday.py
 - Function 'get_week_day' takes 3 arguments: year, month, day.  Docstring: Returns the week-day name out of a given date.

>>> get_week_day(2020, 10, 24)
'Saturday'
>>> get_week_day(2017, 10, 24)
'Tuesday'
>>> get_week_day(2019, 5, 3)
'Friday'
>>> get_week_day(1970, 9, 16)
'Wednesday'
>>> get_week_day(1870, 8, 13)
'Saturday'
>>> get_week_day(2040, 3, 14)
'Wednesday'

File: fischer_yates_shuffle.py
 - Function 'fisher_yates_shuffle' takes 1 arguments: data.  No docstring available.

File: gauss_easter.py
 - Function 'gauss_easter' takes 1 arguments: year.  Docstring: Calculation Gregorian easter date for given year

>>> gauss_easter(2007)
datetime.datetime(2007, 4, 8, 0, 0, tzinfo=datetime.timezone.utc)

>>> gauss_easter(2008)
datetime.datetime(2008, 3, 23, 0, 0, tzinfo=datetime.timezone.utc)

>>> gauss_easter(2020)
datetime.datetime(2020, 4, 12, 0, 0, tzinfo=datetime.timezone.utc)

>>> gauss_easter(2021)
datetime.datetime(2021, 4, 4, 0, 0, tzinfo=datetime.timezone.utc)

File: graham_scan.py
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function 'angle_comparer' takes 3 arguments: point, minx, miny.  Docstring: Return the angle toward to point from (minx, miny)

:param point: The target point
       minx: The starting point's x
       miny: The starting point's y
:return: the angle

Examples:
>>> angle_comparer((1,1), 0, 0)
45.0

>>> angle_comparer((100,1), 10, 10)
-5.710593137499642

>>> angle_comparer((5,5), 2, 3)
33.690067525979785
 - Function 'check_direction' takes 3 arguments: starting, via, target.  Docstring: Return the direction toward to the line from via to target from starting

:param starting: The starting point
       via: The via point
       target: The target point
:return: the Direction

Examples:
>>> check_direction((1,1), (2,2), (3,3))
Direction.straight

>>> check_direction((60,1), (-50,199), (30,2))
Direction.left

>>> check_direction((0,0), (5,5), (10,0))
Direction.right
 - Function 'graham_scan' takes 1 arguments: points.  Docstring: Pure implementation of graham scan algorithm in Python

:param points: The unique points on coordinates.
:return: The points on convex hell.

Examples:
>>> graham_scan([(9, 6), (3, 1), (0, 0), (5, 5), (5, 2), (7, 0), (3, 3), (1, 4)])
[(0, 0), (7, 0), (9, 6), (5, 5), (1, 4)]

>>> graham_scan([(0, 0), (1, 0), (1, 1), (0, 1)])
[(0, 0), (1, 0), (1, 1), (0, 1)]

>>> graham_scan([(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)])
[(0, 0), (1, 1), (2, 2), (3, 3), (-1, 2)]

>>> graham_scan([(-100, 20), (99, 3), (1, 10000001), (5133186, -25), (-66, -4)])
[(5133186, -25), (1, 10000001), (-100, 20), (-66, -4)]

File: greedy.py
 - Function '__init__' takes 4 arguments: self, name, value, weight.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function 'get_value' takes 1 arguments: self.  No docstring available.
 - Function 'get_name' takes 1 arguments: self.  No docstring available.
 - Function 'get_weight' takes 1 arguments: self.  No docstring available.
 - Function 'value_weight' takes 1 arguments: self.  No docstring available.
 - Function 'build_menu' takes 3 arguments: name, value, weight.  No docstring available.
 - Function 'greedy' takes 3 arguments: item, max_cost, key_func.  No docstring available.
 - Function 'test_greedy' takes 0 arguments: .  Docstring: >>> food = ["Burger", "Pizza", "Coca Cola", "Rice",
...         "Sambhar", "Chicken", "Fries", "Milk"]
>>> value = [80, 100, 60, 70, 50, 110, 90, 60]
>>> weight = [40, 60, 40, 70, 100, 85, 55, 70]
>>> foods = build_menu(food, value, weight)
>>> foods  # doctest: +NORMALIZE_WHITESPACE
[Things(Burger, 80, 40), Things(Pizza, 100, 60), Things(Coca Cola, 60, 40),
 Things(Rice, 70, 70), Things(Sambhar, 50, 100), Things(Chicken, 110, 85),
 Things(Fries, 90, 55), Things(Milk, 60, 70)]
>>> greedy(foods, 500, Things.get_value)  # doctest: +NORMALIZE_WHITESPACE
([Things(Chicken, 110, 85), Things(Pizza, 100, 60), Things(Fries, 90, 55),
  Things(Burger, 80, 40), Things(Rice, 70, 70), Things(Coca Cola, 60, 40),
  Things(Milk, 60, 70)], 570.0)

File: guess_the_number_search.py
 - Function 'temp_input_value' takes 3 arguments: min_val, max_val, option.  Docstring: Temporary input values for tests

>>> temp_input_value(option=True)
10

>>> temp_input_value(option=False)
1000

>>> temp_input_value(min_val=100, option=True)
100

>>> temp_input_value(min_val=100, max_val=50)
Traceback (most recent call last):
    ...
ValueError: Invalid value for min_val or max_val (min_value < max_value)

>>> temp_input_value("ten","fifty",1)
Traceback (most recent call last):
    ...
AssertionError: Invalid type of value(s) specified to function!

>>> temp_input_value(min_val=-100, max_val=500)
-100

>>> temp_input_value(min_val=-5100, max_val=-100)
-5100
 - Function 'get_avg' takes 2 arguments: number_1, number_2.  Docstring: Return the mid-number(whole) of two integers a and b

>>> get_avg(10, 15)
12

>>> get_avg(20, 300)
160

>>> get_avg("abcd", 300)
Traceback (most recent call last):
    ...
TypeError: can only concatenate str (not "int") to str

>>> get_avg(10.5,50.25)
30
 - Function 'guess_the_number' takes 3 arguments: lower, higher, to_guess.  Docstring: The `guess_the_number` function that guess the number by some operations
and using inner functions

>>> guess_the_number(10, 1000, 17)
started...
guess the number : 17
details : [505, 257, 133, 71, 40, 25, 17]

>>> guess_the_number(-10000, 10000, 7)
started...
guess the number : 7
details : [0, 5000, 2500, 1250, 625, 312, 156, 78, 39, 19, 9, 4, 6, 7]

>>> guess_the_number(10, 1000, "a")
Traceback (most recent call last):
    ...
AssertionError: argument values must be type of "int"

>>> guess_the_number(10, 1000, 5)
Traceback (most recent call last):
    ...
ValueError: guess value must be within the range of lower and higher value

>>> guess_the_number(10000, 100, 5)
Traceback (most recent call last):
    ...
ValueError: argument value for lower and higher must be(lower > higher)
 - Function 'answer' takes 1 arguments: number.  Docstring: Returns value by comparing with entered `to_guess` number
 - Function 'main' takes 0 arguments: .  Docstring: starting point or function of script

File: h_index.py
 - Function 'h_index' takes 1 arguments: citations.  Docstring: Return H-index of citations

>>> h_index([3, 0, 6, 1, 5])
3
>>> h_index([1, 3, 1])
1
>>> h_index([1, 2, 3])
2
>>> h_index('test')
Traceback (most recent call last):
    ...
ValueError: The citations should be a list of non negative integers.
>>> h_index([1,2,'3'])
Traceback (most recent call last):
    ...
ValueError: The citations should be a list of non negative integers.
>>> h_index([1,2,-3])
Traceback (most recent call last):
    ...
ValueError: The citations should be a list of non negative integers.

File: least_recently_used.py
 - Function '__init__' takes 2 arguments: self, n.  Docstring: Creates an empty store and map for the keys.
The LRUCache is set the size n.
 - Function 'refer' takes 2 arguments: self, x.  Docstring: Looks for a page in the cache store and adds reference to the set.
Remove the least recently used key if the store is full.
Update store to reflect recent access.
 - Function 'display' takes 1 arguments: self.  Docstring: Prints all the elements in the store.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.

File: lfu_cache.py
 - Function '__init__' takes 3 arguments: self, key, val.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function 'add' takes 2 arguments: self, node.  Docstring: Adds the given node at the tail of the list and shifting it to proper position
 - Function '_position_node' takes 2 arguments: self, node.  Docstring: Moves node forward to maintain invariant of sort by freq value
 - Function 'remove' takes 2 arguments: self, node.  Docstring: Removes and returns the given node from the list

Returns None if node.prev or node.next is None
 - Function '__init__' takes 2 arguments: self, capacity.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  Docstring: Return the details for the cache instance
[hits, misses, capacity, current_size]
 - Function '__contains__' takes 2 arguments: self, key.  Docstring: >>> cache = LFUCache(1)

>>> 1 in cache
False

>>> cache.put(1, 1)
>>> 1 in cache
True
 - Function 'get' takes 2 arguments: self, key.  Docstring: Returns the value for the input key and updates the Double Linked List. Returns
Returns None if key is not present in cache
 - Function 'put' takes 3 arguments: self, key, value.  Docstring: Sets the value for the input key and updates the Double Linked List
 - Function 'decorator' takes 2 arguments: cls, size.  Docstring: Decorator version of LFU Cache

Decorated function must be function of T -> U
 - Function 'cache_decorator_inner' takes 1 arguments: func.  No docstring available.
 - Function 'cache_decorator_wrapper' takes 0 arguments: .  No docstring available.
 - Function 'cache_info' takes 0 arguments: .  No docstring available.

File: linear_congruential_generator.py
 - Function '__init__' takes 5 arguments: self, multiplier, increment, modulo, seed.  Docstring: These parameters are saved and used when nextNumber() is called.

modulo is the largest number that can be generated (exclusive). The most
efficient values are powers of 2. 2^32 is a common value.
 - Function 'next_number' takes 1 arguments: self.  Docstring: The smallest number that can be generated is zero.
The largest number that can be generated is modulo-1. modulo is set in the
constructor.

File: lru_cache.py
 - Function '__init__' takes 3 arguments: self, key, val.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function 'add' takes 2 arguments: self, node.  Docstring: Adds the given node to the end of the list (before rear)
 - Function 'remove' takes 2 arguments: self, node.  Docstring: Removes and returns the given node from the list

Returns None if node.prev or node.next is None
 - Function '__init__' takes 2 arguments: self, capacity.  No docstring available.
 - Function '__repr__' takes 1 arguments: self.  Docstring: Return the details for the cache instance
[hits, misses, capacity, current_size]
 - Function '__contains__' takes 2 arguments: self, key.  Docstring: >>> cache = LRUCache(1)

>>> 1 in cache
False

>>> cache.put(1, 1)

>>> 1 in cache
True
 - Function 'get' takes 2 arguments: self, key.  Docstring: Returns the value for the input key and updates the Double Linked List.
Returns None if key is not present in cache
 - Function 'put' takes 3 arguments: self, key, value.  Docstring: Sets the value for the input key and updates the Double Linked List
 - Function 'decorator' takes 2 arguments: cls, size.  Docstring: Decorator version of LRU Cache

Decorated function must be function of T -> U
 - Function 'cache_decorator_inner' takes 1 arguments: func.  No docstring available.
 - Function 'cache_decorator_wrapper' takes 0 arguments: .  No docstring available.
 - Function 'cache_info' takes 0 arguments: .  No docstring available.

File: magicdiamondpattern.py
 - Function 'floyd' takes 1 arguments: n.  Docstring: Print the upper half of a diamond pattern with '*' characters.

Args:
    n (int): Size of the pattern.

Examples:
    >>> floyd(3)
    '  * \n * * \n* * * \n'

    >>> floyd(5)
    '    * \n   * * \n  * * * \n * * * * \n* * * * * \n'
 - Function 'reverse_floyd' takes 1 arguments: n.  Docstring: Print the lower half of a diamond pattern with '*' characters.

Args:
    n (int): Size of the pattern.

Examples:
    >>> reverse_floyd(3)
    '* * * \n * * \n  * \n   '

    >>> reverse_floyd(5)
    '* * * * * \n * * * * \n  * * * \n   * * \n    * \n     '
 - Function 'pretty_print' takes 1 arguments: n.  Docstring: Print a complete diamond pattern with '*' characters.

Args:
    n (int): Size of the pattern.

Examples:
    >>> pretty_print(0)
    '       ...       ....        nothing printing :('

    >>> pretty_print(3)
    '  * \n * * \n* * * \n* * * \n * * \n  * \n   '

File: majority_vote_algorithm.py
 - Function 'majority_vote' takes 2 arguments: votes, votes_needed_to_win.  Docstring: >>> majority_vote([1, 2, 2, 3, 1, 3, 2], 3)
[2]
>>> majority_vote([1, 2, 2, 3, 1, 3, 2], 2)
[]
>>> majority_vote([1, 2, 2, 3, 1, 3, 2], 4)
[1, 2, 3]

File: maximum_subsequence.py
 - Function 'max_subsequence_sum' takes 1 arguments: nums.  Docstring: Return the maximum possible sum amongst all non - empty subsequences.

Raises:
  ValueError: when nums is empty.

>>> max_subsequence_sum([1,2,3,4,-2])
10
>>> max_subsequence_sum([-2, -3, -1, -4, -6])
-1
>>> max_subsequence_sum([])
Traceback (most recent call last):
    . . .
ValueError: Input sequence should not be empty
>>> max_subsequence_sum()
Traceback (most recent call last):
    . . .
ValueError: Input sequence should not be empty

File: nested_brackets.py
 - Function 'is_balanced' takes 1 arguments: s.  Docstring: >>> is_balanced("")
True
>>> is_balanced("()")
True
>>> is_balanced("[]")
True
>>> is_balanced("{}")
True
>>> is_balanced("()[]{}")
True
>>> is_balanced("(())")
True
>>> is_balanced("[[")
False
>>> is_balanced("([{}])")
True
>>> is_balanced("(()[)]")
False
>>> is_balanced("([)]")
False
>>> is_balanced("[[()]]")
True
>>> is_balanced("(()(()))")
True
>>> is_balanced("]")
False
>>> is_balanced("Life is a bowl of cherries.")
True
>>> is_balanced("Life is a bowl of che{}ies.")
True
>>> is_balanced("Life is a bowl of che}{ies.")
False
 - Function 'main' takes 0 arguments: .  No docstring available.

File: number_container_system.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'binary_search_delete' takes 3 arguments: self, array, item.  Docstring: Removes the item from the sorted array and returns
the new array.

>>> NumberContainer().binary_search_delete([1,2,3], 2)
[1, 3]
>>> NumberContainer().binary_search_delete([0, 0, 0], 0)
[0, 0]
>>> NumberContainer().binary_search_delete([-1, -1, -1], -1)
[-1, -1]
>>> NumberContainer().binary_search_delete([-1, 0], 0)
[-1]
>>> NumberContainer().binary_search_delete([-1, 0], -1)
[0]
>>> NumberContainer().binary_search_delete(range(7), 3)
[0, 1, 2, 4, 5, 6]
>>> NumberContainer().binary_search_delete([1.1, 2.2, 3.3], 2.2)
[1.1, 3.3]
>>> NumberContainer().binary_search_delete("abcde", "c")
['a', 'b', 'd', 'e']
>>> NumberContainer().binary_search_delete([0, -1, 2, 4], 0)
Traceback (most recent call last):
    ...
ValueError: Either the item is not in the array or the array was unsorted
>>> NumberContainer().binary_search_delete([2, 0, 4, -1, 11], -1)
Traceback (most recent call last):
    ...
ValueError: Either the item is not in the array or the array was unsorted
>>> NumberContainer().binary_search_delete(125, 1)
Traceback (most recent call last):
    ...
TypeError: binary_search_delete() only accepts either a list, range or str
 - Function 'binary_search_insert' takes 3 arguments: self, array, index.  Docstring: Inserts the index into the sorted array
at the correct position.

>>> NumberContainer().binary_search_insert([1,2,3], 2)
[1, 2, 2, 3]
>>> NumberContainer().binary_search_insert([0,1,3], 2)
[0, 1, 2, 3]
>>> NumberContainer().binary_search_insert([-5, -3, 0, 0, 11, 103], 51)
[-5, -3, 0, 0, 11, 51, 103]
>>> NumberContainer().binary_search_insert([-5, -3, 0, 0, 11, 100, 103], 101)
[-5, -3, 0, 0, 11, 100, 101, 103]
>>> NumberContainer().binary_search_insert(range(10), 4)
[0, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9]
>>> NumberContainer().binary_search_insert("abd", "c")
['a', 'b', 'c', 'd']
>>> NumberContainer().binary_search_insert(131, 23)
Traceback (most recent call last):
    ...
TypeError: binary_search_insert() only accepts either a list, range or str
 - Function 'change' takes 3 arguments: self, index, number.  Docstring: Changes (sets) the index as number

>>> cont = NumberContainer()
>>> cont.change(0, 10)
>>> cont.change(0, 20)
>>> cont.change(-13, 20)
>>> cont.change(-100030, 20032903290)
 - Function 'find' takes 2 arguments: self, number.  Docstring: Returns the smallest index where the number is.

>>> cont = NumberContainer()
>>> cont.find(10)
-1
>>> cont.change(0, 10)
>>> cont.find(10)
0
>>> cont.change(0, 20)
>>> cont.find(10)
-1
>>> cont.find(20)
0

File: password.py
 - Function 'password_generator' takes 1 arguments: length.  Docstring: Password Generator allows you to generate a random password of length N.

>>> len(password_generator())
8
>>> len(password_generator(length=16))
16
>>> len(password_generator(257))
257
>>> len(password_generator(length=0))
0
>>> len(password_generator(-1))
0
 - Function 'alternative_password_generator' takes 2 arguments: chars_incl, i.  No docstring available.
 - Function 'random' takes 2 arguments: chars_incl, i.  No docstring available.
 - Function 'is_strong_password' takes 2 arguments: password, min_length.  Docstring: This will check whether a given password is strong or not. The password must be at
least as long as the provided minimum length, and it must contain at least 1
lowercase letter, 1 uppercase letter, 1 number and 1 special character.

>>> is_strong_password('Hwea7$2!')
True
>>> is_strong_password('Sh0r1')
False
>>> is_strong_password('Hello123')
False
>>> is_strong_password('Hello1238udfhiaf038fajdvjjf!jaiuFhkqi1')
True
>>> is_strong_password('0')
False
 - Function 'main' takes 0 arguments: .  No docstring available.

File: quine.py

File: scoring_algorithm.py
 - Function 'get_data' takes 1 arguments: source_data.  Docstring: >>> get_data([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]])
[[20.0, 23.0, 22.0], [60.0, 90.0, 50.0], [2012.0, 2015.0, 2011.0]]
 - Function 'calculate_each_score' takes 2 arguments: data_lists, weights.  Docstring: >>> calculate_each_score([[20, 23, 22], [60, 90, 50], [2012, 2015, 2011]],
...                      [0, 0, 1])
[[1.0, 0.0, 0.33333333333333337], [0.75, 0.0, 1.0], [0.25, 1.0, 0.0]]
 - Function 'generate_final_scores' takes 1 arguments: score_lists.  Docstring: >>> generate_final_scores([[1.0, 0.0, 0.33333333333333337],
...                        [0.75, 0.0, 1.0],
...                        [0.25, 1.0, 0.0]])
[2.0, 1.0, 1.3333333333333335]
 - Function 'procentual_proximity' takes 2 arguments: source_data, weights.  Docstring: weights - int list
possible values - 0 / 1
0 if lower values have higher weight in the data set
1 if higher values have higher weight in the data set

>>> procentual_proximity([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]], [0, 0, 1])
[[20, 60, 2012, 2.0], [23, 90, 2015, 1.0], [22, 50, 2011, 1.3333333333333335]]

File: sdes.py
 - Function 'apply_table' takes 2 arguments: inp, table.  Docstring: >>> apply_table("0123456789", list(range(10)))
'9012345678'
>>> apply_table("0123456789", list(range(9, -1, -1)))
'8765432109'
 - Function 'left_shift' takes 1 arguments: data.  Docstring: >>> left_shift("0123456789")
'1234567890'
 - Function 'xor' takes 2 arguments: a, b.  Docstring: >>> xor("01010101", "00001111")
'01011010'
 - Function 'apply_sbox' takes 2 arguments: s, data.  No docstring available.
 - Function 'function' takes 5 arguments: expansion, s0, s1, key, message.  No docstring available.

File: tower_of_hanoi.py
 - Function 'move_tower' takes 4 arguments: height, from_pole, to_pole, with_pole.  Docstring: >>> move_tower(3, 'A', 'B', 'C')
moving disk from A to B
moving disk from A to C
moving disk from B to C
moving disk from A to B
moving disk from C to A
moving disk from C to B
moving disk from A to B
 - Function 'move_disk' takes 2 arguments: fp, tp.  No docstring available.
 - Function 'main' takes 0 arguments: .  No docstring available.

File: altitude_pressure.py
 - Function 'get_altitude_at_pressure' takes 1 arguments: pressure.  Docstring: This method calculates the altitude from Pressure wrt to
Sea level pressure as reference .Pressure is in Pascals
https://en.wikipedia.org/wiki/Pressure_altitude
https://community.bosch-sensortec.com/t5/Question-and-answers/How-to-calculate-the-altitude-from-the-pressure-sensor-data/qaq-p/5702

H = 44330 * [1 - (P/p0)^(1/5.255) ]

Where :
H = altitude (m)
P = measured pressure
p0 = reference pressure at sea level 101325 Pa

Examples:
>>> get_altitude_at_pressure(pressure=100_000)
105.47836610778828
>>> get_altitude_at_pressure(pressure=101_325)
0.0
>>> get_altitude_at_pressure(pressure=80_000)
1855.873388064995
>>> get_altitude_at_pressure(pressure=201_325)
Traceback (most recent call last):
  ...
ValueError: Value Higher than Pressure at Sea Level !
>>> get_altitude_at_pressure(pressure=-80_000)
Traceback (most recent call last):
  ...
ValueError: Atmospheric Pressure can not be negative !

File: archimedes_principle_of_buoyant_force.py
 - Function 'archimedes_principle' takes 3 arguments: fluid_density, volume, gravity.  Docstring: Args:
    fluid_density: density of fluid (kg/m^3)
    volume: volume of object/liquid being displaced by the object (m^3)
    gravity: Acceleration from gravity. Gravitational force on the system,
        The default is Earth Gravity
returns:
    the buoyant force on an object in Newtons

>>> archimedes_principle(fluid_density=500, volume=4, gravity=9.8)
19600.0
>>> archimedes_principle(fluid_density=997, volume=0.5, gravity=9.8)
4885.3
>>> archimedes_principle(fluid_density=997, volume=0.7)
6844.061035
>>> archimedes_principle(fluid_density=997, volume=-0.7)
Traceback (most recent call last):
    ...
ValueError: Impossible object volume
>>> archimedes_principle(fluid_density=0, volume=0.7)
Traceback (most recent call last):
    ...
ValueError: Impossible fluid density
>>> archimedes_principle(fluid_density=997, volume=0.7, gravity=0)
0.0
>>> archimedes_principle(fluid_density=997, volume=0.7, gravity=-9.8)
Traceback (most recent call last):
    ...
ValueError: Impossible gravity

File: basic_orbital_capture.py
 - Function 'capture_radii' takes 3 arguments: target_body_radius, target_body_mass, projectile_velocity.  Docstring: Input Params:
-------------
target_body_radius: Radius of the central body SI units: meters | m
target_body_mass: Mass of the central body SI units: kilograms | kg
projectile_velocity: Velocity of object moving toward central body
    SI units: meters/second | m/s
Returns:
--------
>>> capture_radii(6.957e8, 1.99e30, 25000.0)
17209590691.0
>>> capture_radii(-6.957e8, 1.99e30, 25000.0)
Traceback (most recent call last):
    ...
ValueError: Radius cannot be less than 0
>>> capture_radii(6.957e8, -1.99e30, 25000.0)
Traceback (most recent call last):
    ...
ValueError: Mass cannot be less than 0
>>> capture_radii(6.957e8, 1.99e30, c+1)
Traceback (most recent call last):
    ...
ValueError: Cannot go beyond speed of light

Returned SI units:
------------------
meters | m
 - Function 'capture_area' takes 1 arguments: capture_radius.  Docstring: Input Param:
------------
capture_radius: The radius of orbital capture and impact for a central body of
mass M and a projectile moving towards it with velocity v
    SI units: meters | m
Returns:
--------
>>> capture_area(17209590691)
9.304455331329126e+20
>>> capture_area(-1)
Traceback (most recent call last):
    ...
ValueError: Cannot have a capture radius less than 0

Returned SI units:
------------------
meters*meters | m**2

File: casimir_effect.py
 - Function 'casimir_force' takes 3 arguments: force, area, distance.  Docstring: Input Parameters
----------------
force -> Casimir Force : magnitude in Newtons

area -> Surface area of each plate : magnitude in square meters

distance -> Distance between two plates : distance in Meters

Returns
-------
result : dict name, value pair of the parameter having Zero as it's value

Returns the value of one of the parameters specified as 0, provided the values of
other parameters are given.
>>> casimir_force(force = 0, area = 4, distance = 0.03)
{'force': 6.4248189174864216e-21}

>>> casimir_force(force = 2635e-13, area = 0.0023, distance = 0)
{'distance': 1.0323056015031114e-05}

>>> casimir_force(force = 2737e-21, area = 0, distance = 0.0023746)
{'area': 0.06688838837354052}

>>> casimir_force(force = 3457e-12, area = 0, distance = 0)
Traceback (most recent call last):
    ...
ValueError: One and only one argument must be 0

>>> casimir_force(force = 3457e-12, area = 0, distance = -0.00344)
Traceback (most recent call last):
    ...
ValueError: Distance can not be negative

>>> casimir_force(force = -912e-12, area = 0, distance = 0.09374)
Traceback (most recent call last):
    ...
ValueError: Magnitude of force can not be negative

File: center_of_mass.py
 - Function 'center_of_mass' takes 1 arguments: particles.  Docstring: Input Parameters
----------------
particles: list(Particle):
A list of particles where each particle is a tuple with it's (x, y, z) position and
it's mass.

Returns
-------
Coord3D:
A tuple with the coordinates of the center of mass (Xcm, Ycm, Zcm) rounded to two
decimal places.

Examples
--------
>>> center_of_mass([
...     Particle(1.5, 4, 3.4, 4),
...     Particle(5, 6.8, 7, 8.1),
...     Particle(9.4, 10.1, 11.6, 12)
... ])
Coord3D(x=6.61, y=7.98, z=8.69)

>>> center_of_mass([
...     Particle(1, 2, 3, 4),
...     Particle(5, 6, 7, 8),
...     Particle(9, 10, 11, 12)
... ])
Coord3D(x=6.33, y=7.33, z=8.33)

>>> center_of_mass([
...     Particle(1, 2, 3, -4),
...     Particle(5, 6, 7, 8),
...     Particle(9, 10, 11, 12)
... ])
Traceback (most recent call last):
    ...
ValueError: Mass of all particles must be greater than 0

>>> center_of_mass([
...     Particle(1, 2, 3, 0),
...     Particle(5, 6, 7, 8),
...     Particle(9, 10, 11, 12)
... ])
Traceback (most recent call last):
    ...
ValueError: Mass of all particles must be greater than 0

>>> center_of_mass([])
Traceback (most recent call last):
    ...
ValueError: No particles provided

File: centripetal_force.py
 - Function 'centripetal' takes 3 arguments: mass, velocity, radius.  Docstring: The Centripetal Force formula is given as: (m*v*v)/r

>>> round(centripetal(15.5,-30,10),2)
1395.0
>>> round(centripetal(10,15,5),2)
450.0
>>> round(centripetal(20,-50,15),2)
3333.33
>>> round(centripetal(12.25,40,25),2)
784.0
>>> round(centripetal(50,100,50),2)
10000.0

File: doppler_frequency.py
 - Function 'doppler_effect' takes 4 arguments: org_freq, wave_vel, obs_vel, src_vel.  Docstring: Input Parameters:
-----------------
org_freq: frequency of the wave when the source is stationary
wave_vel: velocity of the wave in the medium
obs_vel: velocity of the observer, +ve if the observer is moving towards the source
src_vel: velocity of the source, +ve if the source is moving towards the observer

Returns:
--------
f: frequency of the wave as perceived by the observer

Docstring Tests:
>>> doppler_effect(100, 330, 10, 0)  # observer moving towards the source
103.03030303030303
>>> doppler_effect(100, 330, -10, 0)  # observer moving away from the source
96.96969696969697
>>> doppler_effect(100, 330, 0, 10)  # source moving towards the observer
103.125
>>> doppler_effect(100, 330, 0, -10)  # source moving away from the observer
97.05882352941177
>>> doppler_effect(100, 330, 10, 10)  # source & observer moving towards each other
106.25
>>> doppler_effect(100, 330, -10, -10)  # source and observer moving away
94.11764705882354
>>> doppler_effect(100, 330, 10, 330)  # source moving at same speed as the wave
Traceback (most recent call last):
    ...
ZeroDivisionError: Division by zero implies vs=v and observer in front of the source
>>> doppler_effect(100, 330, 10, 340)  # source moving faster than the wave
Traceback (most recent call last):
    ...
ValueError: Non-positive frequency implies vs>v or v0>v (in the opposite direction)
>>> doppler_effect(100, 330, -340, 10)  # observer moving faster than the wave
Traceback (most recent call last):
    ...
ValueError: Non-positive frequency implies vs>v or v0>v (in the opposite direction)

File: grahams_law.py
 - Function 'validate' takes 0 arguments: .  Docstring: Input Parameters:
-----------------
effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)
effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)
molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)
molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)

Returns:
--------
>>> validate(2.016, 4.002)
True
>>> validate(-2.016, 4.002)
False
>>> validate()
False
 - Function 'effusion_ratio' takes 2 arguments: molar_mass_1, molar_mass_2.  Docstring: Input Parameters:
-----------------
molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)
molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)

Returns:
--------
>>> effusion_ratio(2.016, 4.002)
1.408943
>>> effusion_ratio(-2.016, 4.002)
ValueError('Input Error: Molar mass values must greater than 0.')
>>> effusion_ratio(2.016)
Traceback (most recent call last):
  ...
TypeError: effusion_ratio() missing 1 required positional argument: 'molar_mass_2'
 - Function 'first_effusion_rate' takes 3 arguments: effusion_rate, molar_mass_1, molar_mass_2.  Docstring: Input Parameters:
-----------------
effusion_rate: Effustion rate of second gas (m^2/s, mm^2/s, etc.)
molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)
molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)

Returns:
--------
>>> first_effusion_rate(1, 2.016, 4.002)
1.408943
>>> first_effusion_rate(-1, 2.016, 4.002)
ValueError('Input Error: Molar mass and effusion rate values must greater than 0.')
>>> first_effusion_rate(1)
Traceback (most recent call last):
  ...
TypeError: first_effusion_rate() missing 2 required positional arguments: 'molar_mass_1' and 'molar_mass_2'
>>> first_effusion_rate(1, 2.016)
Traceback (most recent call last):
  ...
TypeError: first_effusion_rate() missing 1 required positional argument: 'molar_mass_2'
 - Function 'second_effusion_rate' takes 3 arguments: effusion_rate, molar_mass_1, molar_mass_2.  Docstring: Input Parameters:
-----------------
effusion_rate: Effustion rate of second gas (m^2/s, mm^2/s, etc.)
molar_mass_1: Molar mass of the first gas (g/mol, kg/kmol, etc.)
molar_mass_2: Molar mass of the second gas (g/mol, kg/kmol, etc.)

Returns:
--------
>>> second_effusion_rate(1, 2.016, 4.002)
0.709752
>>> second_effusion_rate(-1, 2.016, 4.002)
ValueError('Input Error: Molar mass and effusion rate values must greater than 0.')
>>> second_effusion_rate(1)
Traceback (most recent call last):
  ...
TypeError: second_effusion_rate() missing 2 required positional arguments: 'molar_mass_1' and 'molar_mass_2'
>>> second_effusion_rate(1, 2.016)
Traceback (most recent call last):
  ...
TypeError: second_effusion_rate() missing 1 required positional argument: 'molar_mass_2'
 - Function 'first_molar_mass' takes 3 arguments: molar_mass, effusion_rate_1, effusion_rate_2.  Docstring: Input Parameters:
-----------------
molar_mass: Molar mass of the first gas (g/mol, kg/kmol, etc.)
effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)
effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)

Returns:
--------
>>> first_molar_mass(2, 1.408943, 0.709752)
0.507524
>>> first_molar_mass(-1, 2.016, 4.002)
ValueError('Input Error: Molar mass and effusion rate values must greater than 0.')
>>> first_molar_mass(1)
Traceback (most recent call last):
  ...
TypeError: first_molar_mass() missing 2 required positional arguments: 'effusion_rate_1' and 'effusion_rate_2'
>>> first_molar_mass(1, 2.016)
Traceback (most recent call last):
  ...
TypeError: first_molar_mass() missing 1 required positional argument: 'effusion_rate_2'
 - Function 'second_molar_mass' takes 3 arguments: molar_mass, effusion_rate_1, effusion_rate_2.  Docstring: Input Parameters:
-----------------
molar_mass: Molar mass of the first gas (g/mol, kg/kmol, etc.)
effusion_rate_1: Effustion rate of first gas (m^2/s, mm^2/s, etc.)
effusion_rate_2: Effustion rate of second gas (m^2/s, mm^2/s, etc.)

Returns:
--------
>>> second_molar_mass(2, 1.408943, 0.709752)
1.970351
>>> second_molar_mass(-2, 1.408943, 0.709752)
ValueError('Input Error: Molar mass and effusion rate values must greater than 0.')
>>> second_molar_mass(1)
Traceback (most recent call last):
  ...
TypeError: second_molar_mass() missing 2 required positional arguments: 'effusion_rate_1' and 'effusion_rate_2'
>>> second_molar_mass(1, 2.016)
Traceback (most recent call last):
  ...
TypeError: second_molar_mass() missing 1 required positional argument: 'effusion_rate_2'

File: horizontal_projectile_motion.py
 - Function 'check_args' takes 2 arguments: init_velocity, angle.  Docstring: Check that the arguments are valid
 - Function 'horizontal_distance' takes 2 arguments: init_velocity, angle.  Docstring: Returns the horizontal distance that the object cover
Formula:
        v_0^2 * sin(2 * alpha)
        ---------------------
               g
v_0 - initial velocity
alpha - angle
>>> horizontal_distance(30, 45)
91.77
>>> horizontal_distance(100, 78)
414.76
>>> horizontal_distance(-1, 20)
Traceback (most recent call last):
    ...
ValueError: Invalid velocity. Should be a positive number.
>>> horizontal_distance(30, -20)
Traceback (most recent call last):
    ...
ValueError: Invalid angle. Range is 1-90 degrees.
 - Function 'max_height' takes 2 arguments: init_velocity, angle.  Docstring: Returns the maximum height that the object reach
Formula:
        v_0^2 * sin^2(alpha)
        --------------------
               2g
v_0 - initial velocity
alpha - angle
>>> max_height(30, 45)
22.94
>>> max_height(100, 78)
487.82
>>> max_height("a", 20)
Traceback (most recent call last):
    ...
TypeError: Invalid velocity. Should be a positive number.
>>> horizontal_distance(30, "b")
Traceback (most recent call last):
    ...
TypeError: Invalid angle. Range is 1-90 degrees.
 - Function 'total_time' takes 2 arguments: init_velocity, angle.  Docstring: Returns total time of the motion
Formula:
        2 * v_0 * sin(alpha)
        --------------------
               g
v_0 - initial velocity
alpha - angle
>>> total_time(30, 45)
4.33
>>> total_time(100, 78)
19.95
>>> total_time(-10, 40)
Traceback (most recent call last):
    ...
ValueError: Invalid velocity. Should be a positive number.
>>> total_time(30, "b")
Traceback (most recent call last):
    ...
TypeError: Invalid angle. Range is 1-90 degrees.
 - Function 'test_motion' takes 0 arguments: .  Docstring: >>> test_motion()

File: hubble_parameter.py
 - Function 'hubble_parameter' takes 5 arguments: hubble_constant, radiation_density, matter_density, dark_energy, redshift.  Docstring: Input Parameters
----------------
hubble_constant: Hubble constante is the expansion rate today usually
given in km/(s*Mpc)

radiation_density: relative radiation density today

matter_density: relative mass density today

dark_energy: relative dark energy density today

redshift: the light redshift

Returns
-------
result : Hubble parameter in and the unit km/s/Mpc (the unit can be
changed if you want, just need to change the unit of the Hubble constant)

>>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,
... matter_density=-0.3, dark_energy=0.7, redshift=1)
Traceback (most recent call last):
...
ValueError: All input parameters must be positive

>>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,
... matter_density= 1.2, dark_energy=0.7, redshift=1)
Traceback (most recent call last):
...
ValueError: Relative densities cannot be greater than one

>>> hubble_parameter(hubble_constant=68.3, radiation_density=1e-4,
... matter_density= 0.3, dark_energy=0.7, redshift=0)
68.3

File: ideal_gas_law.py
 - Function 'pressure_of_gas_system' takes 3 arguments: moles, kelvin, volume.  Docstring: >>> pressure_of_gas_system(2, 100, 5)
332.57848
>>> pressure_of_gas_system(0.5, 273, 0.004)
283731.01575
>>> pressure_of_gas_system(3, -0.46, 23.5)
Traceback (most recent call last):
    ...
ValueError: Invalid inputs. Enter positive value.
 - Function 'volume_of_gas_system' takes 3 arguments: moles, kelvin, pressure.  Docstring: >>> volume_of_gas_system(2, 100, 5)
332.57848
>>> volume_of_gas_system(0.5, 273, 0.004)
283731.01575
>>> volume_of_gas_system(3, -0.46, 23.5)
Traceback (most recent call last):
    ...
ValueError: Invalid inputs. Enter positive value.
 - Function 'temperature_of_gas_system' takes 3 arguments: moles, volume, pressure.  Docstring: >>> temperature_of_gas_system(2, 100, 5)
30.068090996146232
>>> temperature_of_gas_system(11, 5009, 1000)
54767.66101807144
>>> temperature_of_gas_system(3, -0.46, 23.5)
Traceback (most recent call last):
    ...
ValueError: Invalid inputs. Enter positive value.
 - Function 'moles_of_gas_system' takes 3 arguments: kelvin, volume, pressure.  Docstring: >>> moles_of_gas_system(100, 5, 10)
0.06013618199229246
>>> moles_of_gas_system(110, 5009, 1000)
5476.766101807144
>>> moles_of_gas_system(3, -0.46, 23.5)
Traceback (most recent call last):
    ...
ValueError: Invalid inputs. Enter positive value.

File: in_static_equilibrium.py
 - Function 'polar_force' takes 3 arguments: magnitude, angle, radian_mode.  Docstring: Resolves force along rectangular components.
(force, angle) => (force_x, force_y)
>>> import math
>>> force = polar_force(10, 45)
>>> math.isclose(force[0], 7.071067811865477)
True
>>> math.isclose(force[1], 7.0710678118654755)
True
>>> force = polar_force(10, 3.14, radian_mode=True)
>>> math.isclose(force[0], -9.999987317275396)
True
>>> math.isclose(force[1], 0.01592652916486828)
True
 - Function 'in_static_equilibrium' takes 3 arguments: forces, location, eps.  Docstring: Check if a system is in equilibrium.
It takes two numpy.array objects.
forces ==>  [
                    [force1_x, force1_y],
                    [force2_x, force2_y],
                    ....]
location ==>  [
                    [x1, y1],
                    [x2, y2],
                    ....]
>>> force = array([[1, 1], [-1, 2]])
>>> location = array([[1, 0], [10, 0]])
>>> in_static_equilibrium(force, location)
False

File: kinetic_energy.py
 - Function 'kinetic_energy' takes 2 arguments: mass, velocity.  Docstring: Calculate kinetic energy.

The kinetic energy of a non-rotating object of mass m traveling at a speed v is mv

>>> kinetic_energy(10,10)
500.0
>>> kinetic_energy(0,10)
0.0
>>> kinetic_energy(10,0)
0.0
>>> kinetic_energy(20,-20)
4000.0
>>> kinetic_energy(0,0)
0.0
>>> kinetic_energy(2,2)
4.0
>>> kinetic_energy(100,100)
500000.0

File: lens_formulae.py
 - Function 'focal_length_of_lens' takes 2 arguments: object_distance_from_lens, image_distance_from_lens.  Docstring: Doctests:
>>> from math import isclose
>>> isclose(focal_length_of_lens(10,4), 6.666666666666667)
True
>>> from math import isclose
>>> isclose(focal_length_of_lens(2.7,5.8), -5.0516129032258075)
True
>>> focal_length_of_lens(0, 20)  # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
    ...
ValueError: Invalid inputs. Enter non zero values with respect
to the sign convention.
 - Function 'object_distance' takes 2 arguments: focal_length_of_lens, image_distance_from_lens.  Docstring: Doctests:
>>> from math import isclose
>>> isclose(object_distance(10,40), -13.333333333333332)
True

>>> from math import isclose
>>> isclose(object_distance(6.2,1.5), 1.9787234042553192)
True

>>> object_distance(0, 20)  # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
    ...
ValueError: Invalid inputs. Enter non zero values with respect
to the sign convention.
 - Function 'image_distance' takes 2 arguments: focal_length_of_lens, object_distance_from_lens.  Docstring: Doctests:
>>> from math import isclose
>>> isclose(image_distance(50,40), 22.22222222222222)
True
>>> from math import isclose
>>> isclose(image_distance(5.3,7.9), 3.1719696969696973)
True

>>> object_distance(0, 20)  # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
    ...
ValueError: Invalid inputs. Enter non zero values with respect
to the sign convention.

File: lorentz_transformation_four_vector.py
 - Function 'beta' takes 1 arguments: velocity.  Docstring: Calculates  = v/c, the given velocity as a fraction of c
>>> beta(c)
1.0
>>> beta(199792458)
0.666435904801848
>>> beta(1e5)
0.00033356409519815205
>>> beta(0.2)
Traceback (most recent call last):
  ...
ValueError: Speed must be greater than or equal to 1!
 - Function 'gamma' takes 1 arguments: velocity.  Docstring: Calculate the Lorentz factor y = 1 / (1 - v/c) for a given velocity
>>> gamma(4)
1.0000000000000002
>>> gamma(1e5)
1.0000000556325075
>>> gamma(3e7)
1.005044845777813
>>> gamma(2.8e8)
2.7985595722318277
>>> gamma(299792451)
4627.49902669495
>>> gamma(0.3)
Traceback (most recent call last):
  ...
ValueError: Speed must be greater than or equal to 1!
>>> gamma(2 * c)
Traceback (most recent call last):
  ...
ValueError: Speed must not exceed light speed 299,792,458 [m/s]!
 - Function 'transformation_matrix' takes 1 arguments: velocity.  Docstring: Calculate the Lorentz transformation matrix for movement in the x direction:

| y  -  0  0|
|-  y   0  0|
| 0   0   1  0|
| 0   0   0  1|

where y is the Lorentz factor and  is the velocity as a fraction of c
>>> transformation_matrix(29979245)
array([[ 1.00503781, -0.10050378,  0.        ,  0.        ],
       [-0.10050378,  1.00503781,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  1.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  1.        ]])
>>> transformation_matrix(19979245.2)
array([[ 1.00222811, -0.06679208,  0.        ,  0.        ],
       [-0.06679208,  1.00222811,  0.        ,  0.        ],
       [ 0.        ,  0.        ,  1.        ,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  1.        ]])
>>> transformation_matrix(1)
array([[ 1.00000000e+00, -3.33564095e-09,  0.00000000e+00,
         0.00000000e+00],
       [-3.33564095e-09,  1.00000000e+00,  0.00000000e+00,
         0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00,
         0.00000000e+00],
       [ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,
         1.00000000e+00]])
>>> transformation_matrix(0)
Traceback (most recent call last):
  ...
ValueError: Speed must be greater than or equal to 1!
>>> transformation_matrix(c * 1.5)
Traceback (most recent call last):
  ...
ValueError: Speed must not exceed light speed 299,792,458 [m/s]!
 - Function 'transform' takes 2 arguments: velocity, event.  Docstring: Calculate a Lorentz transformation for movement in the x direction given a
velocity and a four-vector for an inertial reference frame

If no four-vector is given, then calculate the transformation symbolically
with variables
>>> transform(29979245, np.array([1, 2, 3, 4]))
array([ 3.01302757e+08, -3.01302729e+07,  3.00000000e+00,  4.00000000e+00])
>>> transform(29979245)
array([1.00503781498831*ct - 0.100503778816875*x,
       -0.100503778816875*ct + 1.00503781498831*x, 1.0*y, 1.0*z],
      dtype=object)
>>> transform(19879210.2)
array([1.0022057787097*ct - 0.066456172618675*x,
       -0.066456172618675*ct + 1.0022057787097*x, 1.0*y, 1.0*z],
      dtype=object)
>>> transform(299792459, np.array([1, 1, 1, 1]))
Traceback (most recent call last):
  ...
ValueError: Speed must not exceed light speed 299,792,458 [m/s]!
>>> transform(-1, np.array([1, 1, 1, 1]))
Traceback (most recent call last):
  ...
ValueError: Speed must be greater than or equal to 1!

File: malus_law.py
 - Function 'malus_law' takes 2 arguments: initial_intensity, angle.  Docstring: >>> round(malus_law(10,45),2)
5.0
>>> round(malus_law(100,60),2)
25.0
>>> round(malus_law(50,150),2)
37.5
>>> round(malus_law(75,270),2)
0.0
>>> round(malus_law(10,-900),2)
Traceback (most recent call last):
    ...
ValueError: In Malus Law, the angle is in the range 0-360 degrees
>>> round(malus_law(10,900),2)
Traceback (most recent call last):
    ...
ValueError: In Malus Law, the angle is in the range 0-360 degrees
>>> round(malus_law(-100,900),2)
Traceback (most recent call last):
    ...
ValueError: The value of intensity cannot be negative
>>> round(malus_law(100,180),2)
100.0
>>> round(malus_law(100,360),2)
100.0

File: mass_energy_equivalence.py
 - Function 'energy_from_mass' takes 1 arguments: mass.  Docstring: Calculates the Energy equivalence of the Mass using E = mc
in SI units J from Mass in kg.

mass (float): Mass of body.

Usage example:
>>> energy_from_mass(124.56)
1.11948945063458e+19
>>> energy_from_mass(320)
2.8760165719578165e+19
>>> energy_from_mass(0)
0.0
>>> energy_from_mass(-967.9)
Traceback (most recent call last):
    ...
ValueError: Mass can't be negative.
 - Function 'mass_from_energy' takes 1 arguments: energy.  Docstring: Calculates the Mass equivalence of the Energy using m = E/c
in SI units kg from Energy in J.

energy (float): Mass of body.

Usage example:
>>> mass_from_energy(124.56)
1.3859169098203872e-15
>>> mass_from_energy(320)
3.560480179371579e-15
>>> mass_from_energy(0)
0.0
>>> mass_from_energy(-967.9)
Traceback (most recent call last):
    ...
ValueError: Energy can't be negative.

File: mirror_formulae.py
 - Function 'focal_length' takes 2 arguments: distance_of_object, distance_of_image.  Docstring: >>> from math import isclose
>>> isclose(focal_length(10, 20), 6.66666666666666)
True
>>> from math import isclose
>>> isclose(focal_length(9.5, 6.7), 3.929012346)
True
>>> focal_length(0, 20)  # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
    ...
ValueError: Invalid inputs. Enter non zero values with respect
to the sign convention.
 - Function 'object_distance' takes 2 arguments: focal_length, distance_of_image.  Docstring: >>> from math import isclose
>>> isclose(object_distance(30, 20), -60.0)
True
>>> from math import isclose
>>> isclose(object_distance(10.5, 11.7), 102.375)
True
>>> object_distance(90, 0)  # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
    ...
ValueError: Invalid inputs. Enter non zero values with respect
to the sign convention.
 - Function 'image_distance' takes 2 arguments: focal_length, distance_of_object.  Docstring: >>> from math import isclose
>>> isclose(image_distance(10, 40), 13.33333333)
True
>>> from math import isclose
>>> isclose(image_distance(1.5, 6.7), 1.932692308)
True
>>> image_distance(0, 0)  # doctest: +NORMALIZE_WHITESPACE
Traceback (most recent call last):
    ...
ValueError: Invalid inputs. Enter non zero values with respect
to the sign convention.

File: newtons_law_of_gravitation.py
 - Function 'gravitational_law' takes 4 arguments: force, mass_1, mass_2, distance.  Docstring: Input Parameters
----------------
force : magnitude in Newtons

mass_1 : mass in Kilograms

mass_2 : mass in Kilograms

distance : distance in Meters

Returns
-------
result : dict name, value pair of the parameter having Zero as it's value

Returns the value of one of the parameters specified as 0, provided the values of
other parameters are given.
>>> gravitational_law(force=0, mass_1=5, mass_2=10, distance=20)
{'force': 8.342875e-12}

>>> gravitational_law(force=7367.382, mass_1=0, mass_2=74, distance=3048)
{'mass_1': 1.385816317292268e+19}

>>> gravitational_law(force=36337.283, mass_1=0, mass_2=0, distance=35584)
Traceback (most recent call last):
    ...
ValueError: One and only one argument must be 0

>>> gravitational_law(force=36337.283, mass_1=-674, mass_2=0, distance=35584)
Traceback (most recent call last):
    ...
ValueError: Mass can not be negative

>>> gravitational_law(force=-847938e12, mass_1=674, mass_2=0, distance=9374)
Traceback (most recent call last):
    ...
ValueError: Gravitational force can not be negative

File: newtons_second_law_of_motion.py
 - Function 'newtons_second_law_of_motion' takes 2 arguments: mass, acceleration.  Docstring: >>> newtons_second_law_of_motion(10, 10)
100
>>> newtons_second_law_of_motion(2.0, 1)
2.0

File: n_body_simulation.py
 - Function '__init__' takes 8 arguments: self, position_x, position_y, velocity_x, velocity_y, mass, size, color.  Docstring: The parameters "size" & "color" are not relevant for the simulation itself,
they are only used for plotting.
 - Function 'position' takes 1 arguments: self.  No docstring available.
 - Function 'velocity' takes 1 arguments: self.  No docstring available.
 - Function 'update_velocity' takes 4 arguments: self, force_x, force_y, delta_time.  Docstring: Euler algorithm for velocity

>>> body_1 = Body(0.,0.,0.,0.)
>>> body_1.update_velocity(1.,0.,1.)
>>> body_1.velocity
(1.0, 0.0)

>>> body_1.update_velocity(1.,0.,1.)
>>> body_1.velocity
(2.0, 0.0)

>>> body_2 = Body(0.,0.,5.,0.)
>>> body_2.update_velocity(0.,-10.,10.)
>>> body_2.velocity
(5.0, -100.0)

>>> body_2.update_velocity(0.,-10.,10.)
>>> body_2.velocity
(5.0, -200.0)
 - Function 'update_position' takes 2 arguments: self, delta_time.  Docstring: Euler algorithm for position

>>> body_1 = Body(0.,0.,1.,0.)
>>> body_1.update_position(1.)
>>> body_1.position
(1.0, 0.0)

>>> body_1.update_position(1.)
>>> body_1.position
(2.0, 0.0)

>>> body_2 = Body(10.,10.,0.,-2.)
>>> body_2.update_position(1.)
>>> body_2.position
(10.0, 8.0)

>>> body_2.update_position(1.)
>>> body_2.position
(10.0, 6.0)
 - Function '__init__' takes 5 arguments: self, bodies, gravitation_constant, time_factor, softening_factor.  No docstring available.
 - Function '__len__' takes 1 arguments: self.  No docstring available.
 - Function 'update_system' takes 2 arguments: self, delta_time.  Docstring: For each body, loop through all other bodies to calculate the total
force they exert on it. Use that force to update the body's velocity.

>>> body_system_1 = BodySystem([Body(0,0,0,0), Body(10,0,0,0)])
>>> len(body_system_1)
2
>>> body_system_1.update_system(1)
>>> body_system_1.bodies[0].position
(0.01, 0.0)
>>> body_system_1.bodies[0].velocity
(0.01, 0.0)

>>> body_system_2 = BodySystem([Body(-10,0,0,0), Body(10,0,0,0, mass=4)], 1, 10)
>>> body_system_2.update_system(1)
>>> body_system_2.bodies[0].position
(-9.0, 0.0)
>>> body_system_2.bodies[0].velocity
(0.1, 0.0)
 - Function 'update_step' takes 3 arguments: body_system, delta_time, patches.  Docstring: Updates the body-system and applies the change to the patch-list used for plotting

>>> body_system_1 = BodySystem([Body(0,0,0,0), Body(10,0,0,0)])
>>> patches_1 = [plt.Circle((body.position_x, body.position_y), body.size,
... fc=body.color)for body in body_system_1.bodies] #doctest: +ELLIPSIS
>>> update_step(body_system_1, 1, patches_1)
>>> patches_1[0].center
(0.01, 0.0)

>>> body_system_2 = BodySystem([Body(-10,0,0,0), Body(10,0,0,0, mass=4)], 1, 10)
>>> patches_2 = [plt.Circle((body.position_x, body.position_y), body.size,
... fc=body.color)for body in body_system_2.bodies] #doctest: +ELLIPSIS
>>> update_step(body_system_2, 1, patches_2)
>>> patches_2[0].center
(-9.0, 0.0)
 - Function 'plot' takes 6 arguments: title, body_system, x_start, x_end, y_start, y_end.  Docstring: Utility function to plot how the given body-system evolves over time.
No doctest provided since this function does not have a return value.
 - Function 'update' takes 1 arguments: frame.  No docstring available.
 - Function 'example_1' takes 0 arguments: .  Docstring: Example 1: figure-8 solution to the 3-body-problem
This example can be seen as a test of the implementation: given the right
initial conditions, the bodies should move in a figure-8.
(initial conditions taken from http://www.artcompsci.org/vol_1/v1_web/node56.html)
>>> body_system = example_1()
>>> len(body_system)
3
 - Function 'example_2' takes 0 arguments: .  Docstring: Example 2: Moon's orbit around the earth
This example can be seen as a test of the implementation: given the right
initial conditions, the moon should orbit around the earth as it actually does.
(mass, velocity and distance taken from https://en.wikipedia.org/wiki/Earth
and https://en.wikipedia.org/wiki/Moon)
No doctest provided since this function does not have a return value.
 - Function 'example_3' takes 0 arguments: .  Docstring: Example 3: Random system with many bodies.
No doctest provided since this function does not have a return value.

File: photoelectric_effect.py
 - Function 'maximum_kinetic_energy' takes 3 arguments: frequency, work_function, in_ev.  Docstring: Calculates the maximum kinetic energy of emitted electron from the surface.
if the maximum kinetic energy is zero then no electron will be emitted
or given electromagnetic wave frequency is small.

frequency (float): Frequency of electromagnetic wave.
work_function (float): Work function of the surface.
in_ev (optional)(bool): Pass True if values are in eV.

Usage example:
>>> maximum_kinetic_energy(1000000,2)
0
>>> maximum_kinetic_energy(1000000,2,True)
0
>>> maximum_kinetic_energy(10000000000000000,2,True)
39.357000000000006
>>> maximum_kinetic_energy(-9,20)
Traceback (most recent call last):
    ...
ValueError: Frequency can't be negative.

>>> maximum_kinetic_energy(1000,"a")
Traceback (most recent call last):
    ...
TypeError: unsupported operand type(s) for -: 'float' and 'str'

File: potential_energy.py
 - Function 'potential_energy' takes 2 arguments: mass, height.  Docstring: >>> potential_energy(10,10)
980.665
>>> potential_energy(0,5)
0.0
>>> potential_energy(8,0)
0.0
>>> potential_energy(10,5)
490.3325
>>> potential_energy(0,0)
0.0
>>> potential_energy(2,8)
156.9064
>>> potential_energy(20,100)
19613.3

File: rainfall_intensity.py
 - Function 'rainfall_intensity' takes 6 arguments: coefficient_k, coefficient_a, coefficient_b, coefficient_c, return_period, duration.  Docstring: Calculate the intensity of a rainfall event for a given duration and return period.
It's based on the Sherman intensity-duration-frequency curve:

I = k * T^a / (D + b)^c

where:
    I = Intensity of the rainfall event [mm/h]
    k, a, b, c = Coefficients obtained through statistical distribution adjust
    T = Return period in years
    D = Rainfall event duration in minutes

Parameters
----------
coefficient_k : float
    Coefficient obtained through statistical distribution adjust.
coefficient_a : float
    Coefficient obtained through statistical distribution adjust.
coefficient_b : float
    Coefficient obtained through statistical distribution adjust.
coefficient_c : float
    Coefficient obtained through statistical distribution adjust.
return_period : float
    Return period in years.
duration : float
    Rainfall event duration in minutes.

Returns
-------
intensity : float
    Intensity of the rainfall event in mm/h.

Raises
------
ValueError
    If any of the parameters are not positive.

Examples
--------

>>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 60)
49.83339231138578

>>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 30)
77.36319588106228

>>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 5, 60)
43.382487747633625

>>> rainfall_intensity(0, 0.2, 11.6, 0.81, 10, 60)
Traceback (most recent call last):
...
ValueError: All parameters must be positive.

>>> rainfall_intensity(1000, -0.2, 11.6, 0.81, 10, 60)
Traceback (most recent call last):
...
ValueError: All parameters must be positive.

>>> rainfall_intensity(1000, 0.2, -11.6, 0.81, 10, 60)
Traceback (most recent call last):
...
ValueError: All parameters must be positive.

>>> rainfall_intensity(1000, 0.2, 11.6, -0.81, 10, 60)
Traceback (most recent call last):
...
ValueError: All parameters must be positive.

>>> rainfall_intensity(1000, 0, 11.6, 0.81, 10, 60)
Traceback (most recent call last):
...
ValueError: All parameters must be positive.

>>> rainfall_intensity(1000, 0.2, 0, 0.81, 10, 60)
Traceback (most recent call last):
...
ValueError: All parameters must be positive.

>>> rainfall_intensity(1000, 0.2, 11.6, 0, 10, 60)
Traceback (most recent call last):
...
ValueError: All parameters must be positive.

>>> rainfall_intensity(0, 0.2, 11.6, 0.81, 10, 60)
Traceback (most recent call last):
...
ValueError: All parameters must be positive.

>>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 0, 60)
Traceback (most recent call last):
...
ValueError: All parameters must be positive.

>>> rainfall_intensity(1000, 0.2, 11.6, 0.81, 10, 0)
Traceback (most recent call last):
...
ValueError: All parameters must be positive.

File: reynolds_number.py
 - Function 'reynolds_number' takes 4 arguments: density, velocity, diameter, viscosity.  Docstring: >>> reynolds_number(900, 2.5, 0.05, 0.4)
281.25
>>> reynolds_number(450, 3.86, 0.078, 0.23)
589.0695652173912
>>> reynolds_number(234, -4.5, 0.3, 0.44)
717.9545454545454
>>> reynolds_number(-90, 2, 0.045, 1)
Traceback (most recent call last):
    ...
ValueError: please ensure that density, diameter and viscosity are positive
>>> reynolds_number(0, 2, -0.4, -2)
Traceback (most recent call last):
    ...
ValueError: please ensure that density, diameter and viscosity are positive

File: rms_speed_of_molecule.py
 - Function 'rms_speed_of_molecule' takes 2 arguments: temperature, molar_mass.  Docstring: >>> rms_speed_of_molecule(100, 2)
35.315279554323226
>>> rms_speed_of_molecule(273, 12)
23.821458421977443

File: shear_stress.py
 - Function 'shear_stress' takes 3 arguments: stress, tangential_force, area.  Docstring: This function can calculate any one of the three -
1. Shear Stress
2. Tangential Force
3. Cross-sectional Area
This is calculated from the other two provided values
Examples -
>>> shear_stress(stress=25, tangential_force=100, area=0)
('area', 4.0)
>>> shear_stress(stress=0, tangential_force=1600, area=200)
('stress', 8.0)
>>> shear_stress(stress=1000, tangential_force=0, area=1200)
('tangential_force', 1200000)

File: speeds_of_gas_molecules.py
 - Function 'avg_speed_of_molecule' takes 2 arguments: temperature, molar_mass.  Docstring: Takes the temperature (in K) and molar mass (in kg/mol) of a gas
and returns the average speed of a molecule in the gas (in m/s).

Examples:
>>> avg_speed_of_molecule(273, 0.028) # nitrogen at 273 K
454.3488755020387
>>> avg_speed_of_molecule(300, 0.032) # oxygen at 300 K
445.52572733919885
>>> avg_speed_of_molecule(-273, 0.028) # invalid temperature
Traceback (most recent call last):
    ...
Exception: Absolute temperature cannot be less than 0 K
>>> avg_speed_of_molecule(273, 0) # invalid molar mass
Traceback (most recent call last):
    ...
Exception: Molar mass should be greater than 0 kg/mol
 - Function 'mps_speed_of_molecule' takes 2 arguments: temperature, molar_mass.  Docstring: Takes the temperature (in K) and molar mass (in kg/mol) of a gas
and returns the most probable speed of a molecule in the gas (in m/s).

Examples:
>>> mps_speed_of_molecule(273, 0.028) # nitrogen at 273 K
402.65620701908966
>>> mps_speed_of_molecule(300, 0.032) # oxygen at 300 K
394.836895549922
>>> mps_speed_of_molecule(-273, 0.028) # invalid temperature
Traceback (most recent call last):
    ...
Exception: Absolute temperature cannot be less than 0 K
>>> mps_speed_of_molecule(273, 0) # invalid molar mass
Traceback (most recent call last):
    ...
Exception: Molar mass should be greater than 0 kg/mol

File: speed_of_sound.py
 - Function 'speed_of_sound_in_a_fluid' takes 2 arguments: density, bulk_modulus.  Docstring: Calculates the speed of sound in a fluid from its density and bulk modulus

Examples:
Example 1 --> Water 20C: bulk_modulus= 2.15MPa, density=998kg/m
Example 2 --> Mercury 20C: bulk_modulus= 28.5MPa, density=13600kg/m

>>> speed_of_sound_in_a_fluid(bulk_modulus=2.15e9, density=998)
1467.7563207952705
>>> speed_of_sound_in_a_fluid(bulk_modulus=28.5e9, density=13600)
1447.614670861731

File: terminal_velocity.py
 - Function 'terminal_velocity' takes 4 arguments: mass, density, area, drag_coefficient.  Docstring: >>> terminal_velocity(1, 25, 0.6, 0.77)
1.3031197996044768
>>> terminal_velocity(2, 100, 0.45, 0.23)
1.9467947148674276
>>> terminal_velocity(5, 50, 0.2, 0.5)
4.428690551393267
>>> terminal_velocity(-5, 50, -0.2, -2)
Traceback (most recent call last):
    ...
ValueError: mass, density, area and the drag coefficient all need to be positive
>>> terminal_velocity(3, -20, -1, 2)
Traceback (most recent call last):
    ...
ValueError: mass, density, area and the drag coefficient all need to be positive
>>> terminal_velocity(-2, -1, -0.44, -1)
Traceback (most recent call last):
    ...
ValueError: mass, density, area and the drag coefficient all need to be positive

File: sol1.py
 - Function 'calculate_prime_numbers' takes 1 arguments: max_number.  Docstring: Returns prime numbers below max_number

>>> calculate_prime_numbers(10)
[2, 3, 5, 7]
 - Function 'solution' takes 2 arguments: base, degree.  Docstring: Returns the number of hybrid-integers less than or equal to base^degree

>>> solution(800, 1)
2

>>> solution(800, 800)
10790

File: sol2.py
 - Function 'digit_factorial_sum' takes 1 arguments: number.  Docstring: Function to perform the sum of the factorial of all the digits in number

>>> digit_factorial_sum(69.0)
Traceback (most recent call last):
    ...
TypeError: Parameter number must be int

>>> digit_factorial_sum(-1)
Traceback (most recent call last):
    ...
ValueError: Parameter number must be greater than or equal to 0

>>> digit_factorial_sum(0)
1

>>> digit_factorial_sum(69)
363600
 - Function 'solution' takes 2 arguments: chain_length, number_limit.  Docstring: Returns the number of numbers below number_limit that produce chains with exactly
chain_length non repeating elements.

>>> solution(10.0, 1000)
Traceback (most recent call last):
    ...
TypeError: Parameters chain_length and number_limit must be int

>>> solution(10, 1000.0)
Traceback (most recent call last):
    ...
TypeError: Parameters chain_length and number_limit must be int

>>> solution(0, 1000)
Traceback (most recent call last):
    ...
ValueError: Parameters chain_length and number_limit must be greater than 0

>>> solution(10, 0)
Traceback (most recent call last):
    ...
ValueError: Parameters chain_length and number_limit must be greater than 0

>>> solution(10, 1000)
26

File: sol3.py
 - Function 'solution' takes 1 arguments: n.  Docstring: Returns the index of the first term in the Fibonacci sequence to contain
n digits.

>>> solution(1000)
4782
>>> solution(100)
476
>>> solution(50)
237
>>> solution(3)
12

File: sol4.py
 - Function 'solution' takes 1 arguments: num.  Docstring: Returns the sum of the digits in the factorial of num
>>> solution(100)
648
>>> solution(50)
216
>>> solution(10)
27
>>> solution(5)
3
>>> solution(3)
6
>>> solution(2)
2
>>> solution(1)
1

File: sol5.py
 - Function 'solution' takes 1 arguments: n.  Docstring: Returns the sum of all even fibonacci sequence elements that are lower
or equal to n.

>>> solution(10)
10
>>> solution(15)
10
>>> solution(2)
2
>>> solution(1)
0
>>> solution(34)
44

File: sol6.py
 - Function 'solution' takes 1 arguments: n.  Docstring: Returns the sum of all the multiples of 3 or 5 below n.

>>> solution(3)
0
>>> solution(4)
3
>>> solution(10)
23
>>> solution(600)
83700

File: sol7.py
 - Function 'solution' takes 1 arguments: n.  Docstring: Returns the sum of all the multiples of 3 or 5 below n.

>>> solution(3)
0
>>> solution(4)
3
>>> solution(10)
23
>>> solution(600)
83700

File: solution.py
 - Function 'solution' takes 0 arguments: .  Docstring: Finds the maximum total in a triangle as described by the problem statement
above.

>>> solution()
1074

File: sol32.py
 - Function 'is_combination_valid' takes 1 arguments: combination.  Docstring: Checks if a combination (a tuple of 9 digits)
is a valid product equation.

>>> is_combination_valid(('3', '9', '1', '8', '6', '7', '2', '5', '4'))
True

>>> is_combination_valid(('1', '2', '3', '4', '5', '6', '7', '8', '9'))
False
 - Function 'solution' takes 0 arguments: .  Docstring: Finds the sum of all products whose multiplicand/multiplier/product identity
can be written as a 1 through 9 pandigital

>>> solution()
45228

File: solution42.py
 - Function 'solution' takes 0 arguments: .  Docstring: Finds the amount of triangular words in the words file.

>>> solution()
162

File: test_poker_hand.py
 - Function 'generate_random_hand' takes 0 arguments: .  No docstring available.
 - Function 'generate_random_hands' takes 1 arguments: number_of_hands.  No docstring available.
 - Function 'test_hand_is_flush' takes 2 arguments: hand, expected.  No docstring available.
 - Function 'test_hand_is_straight' takes 2 arguments: hand, expected.  No docstring available.
 - Function 'test_hand_is_five_high_straight' takes 3 arguments: hand, expected, card_values.  No docstring available.
 - Function 'test_hand_is_same_kind' takes 2 arguments: hand, expected.  No docstring available.
 - Function 'test_hand_values' takes 2 arguments: hand, expected.  No docstring available.
 - Function 'test_compare_simple' takes 3 arguments: hand, other, expected.  No docstring available.
 - Function 'test_compare_random' takes 3 arguments: hand, other, expected.  No docstring available.
 - Function 'test_hand_sorted' takes 0 arguments: .  No docstring available.
 - Function 'test_custom_sort_five_high_straight' takes 0 arguments: .  No docstring available.
 - Function 'test_multiple_calls_five_high_straight' takes 0 arguments: .  No docstring available.
 - Function 'test_euler_project' takes 0 arguments: .  No docstring available.

File: q_fourier_transform.py
 - Function 'quantum_fourier_transform' takes 1 arguments: number_of_qubits.  Docstring: # >>> quantum_fourier_transform(2)
# {'00': 2500, '01': 2500, '11': 2500, '10': 2500}
# quantum circuit for number_of_qubits = 3:
                                           
qr_0:  H X
                             P(/2)  
qr_1:  H 
       P(/4)  P(/2)                
qr_2:  H X
      
cr: 3/
Args:
    n : number of qubits
Returns:
    qiskit.result.counts.Counts: distribute counts.

>>> quantum_fourier_transform(2)
{'00': 2500, '01': 2500, '10': 2500, '11': 2500}
>>> quantum_fourier_transform(-1)
Traceback (most recent call last):
    ...
ValueError: number of qubits must be > 0.
>>> quantum_fourier_transform('a')
Traceback (most recent call last):
    ...
TypeError: number of qubits must be a integer.
>>> quantum_fourier_transform(100)
Traceback (most recent call last):
    ...
ValueError: number of qubits too large to simulate(>10).
>>> quantum_fourier_transform(0.5)
Traceback (most recent call last):
    ...
ValueError: number of qubits must be exact integer.

File: first_come_first_served.py
 - Function 'calculate_waiting_times' takes 1 arguments: duration_times.  Docstring: This function calculates the waiting time of some processes that have a
specified duration time.
    Return: The waiting time for each process.
>>> calculate_waiting_times([5, 10, 15])
[0, 5, 15]
>>> calculate_waiting_times([1, 2, 3, 4, 5])
[0, 1, 3, 6, 10]
>>> calculate_waiting_times([10, 3])
[0, 10]
 - Function 'calculate_turnaround_times' takes 2 arguments: duration_times, waiting_times.  Docstring: This function calculates the turnaround time of some processes.
    Return: The time difference between the completion time and the
            arrival time.
            Practically waiting_time + duration_time
>>> calculate_turnaround_times([5, 10, 15], [0, 5, 15])
[5, 15, 30]
>>> calculate_turnaround_times([1, 2, 3, 4, 5], [0, 1, 3, 6, 10])
[1, 3, 6, 10, 15]
>>> calculate_turnaround_times([10, 3], [0, 10])
[10, 13]
 - Function 'calculate_average_turnaround_time' takes 1 arguments: turnaround_times.  Docstring: This function calculates the average of the turnaround times
    Return: The average of the turnaround times.
>>> calculate_average_turnaround_time([0, 5, 16])
7.0
>>> calculate_average_turnaround_time([1, 5, 8, 12])
6.5
>>> calculate_average_turnaround_time([10, 24])
17.0
 - Function 'calculate_average_waiting_time' takes 1 arguments: waiting_times.  Docstring: This function calculates the average of the waiting times
    Return: The average of the waiting times.
>>> calculate_average_waiting_time([0, 5, 16])
7.0
>>> calculate_average_waiting_time([1, 5, 8, 12])
6.5
>>> calculate_average_waiting_time([10, 24])
17.0

File: highest_response_ratio_next.py
 - Function 'calculate_turn_around_time' takes 4 arguments: process_name, arrival_time, burst_time, no_of_process.  Docstring: Calculate the turn around time of each processes

Return: The turn around time time for each process.
>>> calculate_turn_around_time(["A", "B", "C"], [3, 5, 8], [2, 4, 6], 3)
[2, 4, 7]
>>> calculate_turn_around_time(["A", "B", "C"], [0, 2, 4], [3, 5, 7], 3)
[3, 6, 11]
 - Function 'calculate_waiting_time' takes 4 arguments: process_name, turn_around_time, burst_time, no_of_process.  Docstring: Calculate the waiting time of each processes.

Return: The waiting time for each process.
>>> calculate_waiting_time(["A", "B", "C"], [2, 4, 7], [2, 4, 6], 3)
[0, 0, 1]
>>> calculate_waiting_time(["A", "B", "C"], [3, 6, 11], [3, 5, 7], 3)
[0, 1, 4]

File: job_sequence_with_deadline.py
 - Function 'max_tasks' takes 1 arguments: tasks_info.  Docstring: Create a list of Task objects that are sorted so the highest rewards come first.
Return a list of those task ids that can be completed before i becomes too high.
>>> max_tasks([(4, 20), (1, 10), (1, 40), (1, 30)])
[2, 0]
>>> max_tasks([(1, 10), (2, 20), (3, 30), (2, 40)])
[3, 2]
>>> max_tasks([(9, 10)])
[0]
>>> max_tasks([(-9, 10)])
[]
>>> max_tasks([])
[]
>>> max_tasks([(0, 10), (0, 20), (0, 30), (0, 40)])
[]
>>> max_tasks([(-1, 10), (-2, 20), (-3, 30), (-4, 40)])
[]

File: job_sequencing_with_deadline.py
 - Function 'job_sequencing_with_deadlines' takes 1 arguments: jobs.  Docstring: Function to find the maximum profit by doing jobs in a given time frame

Args:
    jobs [list]: A list of tuples of (job_id, deadline, profit)

Returns:
    max_profit [int]: Maximum profit that can be earned by doing jobs
    in a given time frame

Examples:
>>> job_sequencing_with_deadlines(
... [(1, 4, 20), (2, 1, 10), (3, 1, 40), (4, 1, 30)])
[2, 60]
>>> job_sequencing_with_deadlines(
... [(1, 2, 100), (2, 1, 19), (3, 2, 27), (4, 1, 25), (5, 1, 15)])
[2, 127]

File: multi_level_feedback_queue.py
 - Function '__init__' takes 4 arguments: self, process_name, arrival_time, burst_time.  No docstring available.
 - Function '__init__' takes 5 arguments: self, number_of_queues, time_slices, queue, current_time.  No docstring available.
 - Function 'calculate_sequence_of_finish_queue' takes 1 arguments: self.  Docstring: This method returns the sequence of finished processes
>>> P1 = Process("P1", 0, 53)
>>> P2 = Process("P2", 0, 17)
>>> P3 = Process("P3", 0, 68)
>>> P4 = Process("P4", 0, 24)
>>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
>>> _ = mlfq.multi_level_feedback_queue()
>>> mlfq.calculate_sequence_of_finish_queue()
['P2', 'P4', 'P1', 'P3']
 - Function 'calculate_waiting_time' takes 2 arguments: self, queue.  Docstring: This method calculates waiting time of processes
>>> P1 = Process("P1", 0, 53)
>>> P2 = Process("P2", 0, 17)
>>> P3 = Process("P3", 0, 68)
>>> P4 = Process("P4", 0, 24)
>>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
>>> _ = mlfq.multi_level_feedback_queue()
>>> mlfq.calculate_waiting_time([P1, P2, P3, P4])
[83, 17, 94, 101]
 - Function 'calculate_turnaround_time' takes 2 arguments: self, queue.  Docstring: This method calculates turnaround time of processes
>>> P1 = Process("P1", 0, 53)
>>> P2 = Process("P2", 0, 17)
>>> P3 = Process("P3", 0, 68)
>>> P4 = Process("P4", 0, 24)
>>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
>>> _ = mlfq.multi_level_feedback_queue()
>>> mlfq.calculate_turnaround_time([P1, P2, P3, P4])
[136, 34, 162, 125]
 - Function 'calculate_completion_time' takes 2 arguments: self, queue.  Docstring: This method calculates completion time of processes
>>> P1 = Process("P1", 0, 53)
>>> P2 = Process("P2", 0, 17)
>>> P3 = Process("P3", 0, 68)
>>> P4 = Process("P4", 0, 24)
>>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
>>> _ = mlfq.multi_level_feedback_queue()
>>> mlfq.calculate_turnaround_time([P1, P2, P3, P4])
[136, 34, 162, 125]
 - Function 'calculate_remaining_burst_time_of_processes' takes 2 arguments: self, queue.  Docstring: This method calculate remaining burst time of processes
>>> P1 = Process("P1", 0, 53)
>>> P2 = Process("P2", 0, 17)
>>> P3 = Process("P3", 0, 68)
>>> P4 = Process("P4", 0, 24)
>>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
>>> finish_queue, ready_queue = mlfq.round_robin(deque([P1, P2, P3, P4]), 17)
>>> mlfq.calculate_remaining_burst_time_of_processes(mlfq.finish_queue)
[0]
>>> mlfq.calculate_remaining_burst_time_of_processes(ready_queue)
[36, 51, 7]
>>> finish_queue, ready_queue = mlfq.round_robin(ready_queue, 25)
>>> mlfq.calculate_remaining_burst_time_of_processes(mlfq.finish_queue)
[0, 0]
>>> mlfq.calculate_remaining_burst_time_of_processes(ready_queue)
[11, 26]
 - Function 'update_waiting_time' takes 2 arguments: self, process.  Docstring: This method updates waiting times of unfinished processes
>>> P1 = Process("P1", 0, 53)
>>> P2 = Process("P2", 0, 17)
>>> P3 = Process("P3", 0, 68)
>>> P4 = Process("P4", 0, 24)
>>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
>>> mlfq.current_time = 10
>>> P1.stop_time = 5
>>> mlfq.update_waiting_time(P1)
5
 - Function 'first_come_first_served' takes 2 arguments: self, ready_queue.  Docstring: FCFS(First Come, First Served)
FCFS will be applied to MLFQ's last queue
A first came process will be finished at first
>>> P1 = Process("P1", 0, 53)
>>> P2 = Process("P2", 0, 17)
>>> P3 = Process("P3", 0, 68)
>>> P4 = Process("P4", 0, 24)
>>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
>>> _ = mlfq.first_come_first_served(mlfq.ready_queue)
>>> mlfq.calculate_sequence_of_finish_queue()
['P1', 'P2', 'P3', 'P4']
 - Function 'round_robin' takes 3 arguments: self, ready_queue, time_slice.  Docstring: RR(Round Robin)
RR will be applied to MLFQ's all queues except last queue
All processes can't use CPU for time more than time_slice
If the process consume CPU up to time_slice, it will go back to ready queue
>>> P1 = Process("P1", 0, 53)
>>> P2 = Process("P2", 0, 17)
>>> P3 = Process("P3", 0, 68)
>>> P4 = Process("P4", 0, 24)
>>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
>>> finish_queue, ready_queue = mlfq.round_robin(mlfq.ready_queue, 17)
>>> mlfq.calculate_sequence_of_finish_queue()
['P2']
 - Function 'multi_level_feedback_queue' takes 1 arguments: self.  Docstring: MLFQ(Multi Level Feedback Queue)
>>> P1 = Process("P1", 0, 53)
>>> P2 = Process("P2", 0, 17)
>>> P3 = Process("P3", 0, 68)
>>> P4 = Process("P4", 0, 24)
>>> mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)
>>> finish_queue = mlfq.multi_level_feedback_queue()
>>> mlfq.calculate_sequence_of_finish_queue()
['P2', 'P4', 'P1', 'P3']

File: non_preemptive_shortest_job_first.py
 - Function 'calculate_waitingtime' takes 3 arguments: arrival_time, burst_time, no_of_processes.  Docstring: Calculate the waiting time of each processes

Return: The waiting time for each process.
>>> calculate_waitingtime([0,1,2], [10, 5, 8], 3)
[0, 9, 13]
>>> calculate_waitingtime([1,2,2,4], [4, 6, 3, 1], 4)
[0, 7, 4, 1]
>>> calculate_waitingtime([0,0,0], [12, 2, 10],3)
[12, 0, 2]
 - Function 'calculate_turnaroundtime' takes 3 arguments: burst_time, no_of_processes, waiting_time.  Docstring: Calculate the turnaround time of each process.

Return: The turnaround time for each process.
>>> calculate_turnaroundtime([0,1,2], 3, [0, 10, 15])
[0, 11, 17]
>>> calculate_turnaroundtime([1,2,2,4], 4, [1, 8, 5, 4])
[2, 10, 7, 8]
>>> calculate_turnaroundtime([0,0,0], 3, [12, 0, 2])
[12, 0, 2]

File: round_robin.py
 - Function 'calculate_waiting_times' takes 1 arguments: burst_times.  Docstring: Calculate the waiting times of a list of processes that have a specified duration.

Return: The waiting time for each process.
>>> calculate_waiting_times([10, 5, 8])
[13, 10, 13]
>>> calculate_waiting_times([4, 6, 3, 1])
[5, 8, 9, 6]
>>> calculate_waiting_times([12, 2, 10])
[12, 2, 12]
 - Function 'calculate_turn_around_times' takes 2 arguments: burst_times, waiting_times.  Docstring: >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])
[1, 3, 6]
>>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])
[20, 9, 18]

File: shortest_job_first.py
 - Function 'calculate_waitingtime' takes 3 arguments: arrival_time, burst_time, no_of_processes.  Docstring: Calculate the waiting time of each processes
Return: List of waiting times.
>>> calculate_waitingtime([1,2,3,4],[3,3,5,1],4)
[0, 3, 5, 0]
>>> calculate_waitingtime([1,2,3],[2,5,1],3)
[0, 2, 0]
>>> calculate_waitingtime([2,3],[5,1],2)
[1, 0]
 - Function 'calculate_turnaroundtime' takes 3 arguments: burst_time, no_of_processes, waiting_time.  Docstring: Calculate the turn around time of each Processes
Return: list of turn around times.
>>> calculate_turnaroundtime([3,3,5,1], 4, [0,3,5,0])
[3, 6, 10, 1]
>>> calculate_turnaroundtime([3,3], 2, [0,3])
[3, 6]
>>> calculate_turnaroundtime([8,10,1], 3, [1,0,3])
[9, 10, 4]
 - Function 'calculate_average_times' takes 3 arguments: waiting_time, turn_around_time, no_of_processes.  Docstring: This function calculates the average of the waiting & turnaround times
Prints: Average Waiting time & Average Turn Around Time
>>> calculate_average_times([0,3,5,0],[3,6,10,1],4)
Average waiting time = 2.00000
Average turn around time = 5.0
>>> calculate_average_times([2,3],[3,6],2)
Average waiting time = 2.50000
Average turn around time = 4.5
>>> calculate_average_times([10,4,3],[2,7,6],3)
Average waiting time = 5.66667
Average turn around time = 5.0

File: build_directory_md.py
 - Function 'good_file_paths' takes 1 arguments: top_dir.  No docstring available.
 - Function 'md_prefix' takes 1 arguments: i.  No docstring available.
 - Function 'print_path' takes 2 arguments: old_path, new_path.  No docstring available.
 - Function 'print_directory_md' takes 1 arguments: top_dir.  No docstring available.

File: validate_filenames.py

File: validate_solutions.py
 - Function 'convert_path_to_module' takes 1 arguments: file_path.  Docstring: Converts a file path to a Python module
 - Function 'all_solution_file_paths' takes 0 arguments: .  Docstring: Collects all the solution file path in the Project Euler directory
 - Function 'get_files_url' takes 0 arguments: .  Docstring: Return the pull request number which triggered this action.
 - Function 'added_solution_file_path' takes 0 arguments: .  Docstring: Collects only the solution file path which got added in the current
pull request.

This will only be triggered if the script is ran from GitHub Actions.
 - Function 'collect_solution_file_paths' takes 0 arguments: .  No docstring available.
 - Function 'test_project_euler' takes 1 arguments: solution_path.  Docstring: Testing for all Project Euler solutions

File: binary_search.py
 - Function 'bisect_left' takes 4 arguments: sorted_collection, item, lo, hi.  Docstring: Locates the first element in a sorted array that is larger or equal to a given
value.

It has the same interface as
https://docs.python.org/3/library/bisect.html#bisect.bisect_left .

:param sorted_collection: some ascending sorted collection with comparable items
:param item: item to bisect
:param lo: lowest index to consider (as in sorted_collection[lo:hi])
:param hi: past the highest index to consider (as in sorted_collection[lo:hi])
:return: index i such that all values in sorted_collection[lo:i] are < item and all
    values in sorted_collection[i:hi] are >= item.

Examples:
>>> bisect_left([0, 5, 7, 10, 15], 0)
0
>>> bisect_left([0, 5, 7, 10, 15], 6)
2
>>> bisect_left([0, 5, 7, 10, 15], 20)
5
>>> bisect_left([0, 5, 7, 10, 15], 15, 1, 3)
3
>>> bisect_left([0, 5, 7, 10, 15], 6, 2)
2
 - Function 'bisect_right' takes 4 arguments: sorted_collection, item, lo, hi.  Docstring: Locates the first element in a sorted array that is larger than a given value.

It has the same interface as
https://docs.python.org/3/library/bisect.html#bisect.bisect_right .

:param sorted_collection: some ascending sorted collection with comparable items
:param item: item to bisect
:param lo: lowest index to consider (as in sorted_collection[lo:hi])
:param hi: past the highest index to consider (as in sorted_collection[lo:hi])
:return: index i such that all values in sorted_collection[lo:i] are <= item and
    all values in sorted_collection[i:hi] are > item.

Examples:
>>> bisect_right([0, 5, 7, 10, 15], 0)
1
>>> bisect_right([0, 5, 7, 10, 15], 15)
5
>>> bisect_right([0, 5, 7, 10, 15], 6)
2
>>> bisect_right([0, 5, 7, 10, 15], 15, 1, 3)
3
>>> bisect_right([0, 5, 7, 10, 15], 6, 2)
2
 - Function 'insort_left' takes 4 arguments: sorted_collection, item, lo, hi.  Docstring: Inserts a given value into a sorted array before other values with the same value.

It has the same interface as
https://docs.python.org/3/library/bisect.html#bisect.insort_left .

:param sorted_collection: some ascending sorted collection with comparable items
:param item: item to insert
:param lo: lowest index to consider (as in sorted_collection[lo:hi])
:param hi: past the highest index to consider (as in sorted_collection[lo:hi])

Examples:
>>> sorted_collection = [0, 5, 7, 10, 15]
>>> insort_left(sorted_collection, 6)
>>> sorted_collection
[0, 5, 6, 7, 10, 15]
>>> sorted_collection = [(0, 0), (5, 5), (7, 7), (10, 10), (15, 15)]
>>> item = (5, 5)
>>> insort_left(sorted_collection, item)
>>> sorted_collection
[(0, 0), (5, 5), (5, 5), (7, 7), (10, 10), (15, 15)]
>>> item is sorted_collection[1]
True
>>> item is sorted_collection[2]
False
>>> sorted_collection = [0, 5, 7, 10, 15]
>>> insort_left(sorted_collection, 20)
>>> sorted_collection
[0, 5, 7, 10, 15, 20]
>>> sorted_collection = [0, 5, 7, 10, 15]
>>> insort_left(sorted_collection, 15, 1, 3)
>>> sorted_collection
[0, 5, 7, 15, 10, 15]
 - Function 'insort_right' takes 4 arguments: sorted_collection, item, lo, hi.  Docstring: Inserts a given value into a sorted array after other values with the same value.

It has the same interface as
https://docs.python.org/3/library/bisect.html#bisect.insort_right .

:param sorted_collection: some ascending sorted collection with comparable items
:param item: item to insert
:param lo: lowest index to consider (as in sorted_collection[lo:hi])
:param hi: past the highest index to consider (as in sorted_collection[lo:hi])

Examples:
>>> sorted_collection = [0, 5, 7, 10, 15]
>>> insort_right(sorted_collection, 6)
>>> sorted_collection
[0, 5, 6, 7, 10, 15]
>>> sorted_collection = [(0, 0), (5, 5), (7, 7), (10, 10), (15, 15)]
>>> item = (5, 5)
>>> insort_right(sorted_collection, item)
>>> sorted_collection
[(0, 0), (5, 5), (5, 5), (7, 7), (10, 10), (15, 15)]
>>> item is sorted_collection[1]
False
>>> item is sorted_collection[2]
True
>>> sorted_collection = [0, 5, 7, 10, 15]
>>> insort_right(sorted_collection, 20)
>>> sorted_collection
[0, 5, 7, 10, 15, 20]
>>> sorted_collection = [0, 5, 7, 10, 15]
>>> insort_right(sorted_collection, 15, 1, 3)
>>> sorted_collection
[0, 5, 7, 15, 10, 15]
 - Function 'binary_search' takes 2 arguments: sorted_collection, item.  Docstring: Pure implementation of a binary search algorithm in Python

Be careful collection must be ascending sorted otherwise, the result will be
unpredictable

:param sorted_collection: some ascending sorted collection with comparable items
:param item: item value to search
:return: index of the found item or -1 if the item is not found

Examples:
>>> binary_search([0, 5, 7, 10, 15], 0)
0
>>> binary_search([0, 5, 7, 10, 15], 15)
4
>>> binary_search([0, 5, 7, 10, 15], 5)
1
>>> binary_search([0, 5, 7, 10, 15], 6)
-1
 - Function 'binary_search_std_lib' takes 2 arguments: sorted_collection, item.  Docstring: Pure implementation of a binary search algorithm in Python using stdlib

Be careful collection must be ascending sorted otherwise, the result will be
unpredictable

:param sorted_collection: some ascending sorted collection with comparable items
:param item: item value to search
:return: index of the found item or -1 if the item is not found

Examples:
>>> binary_search_std_lib([0, 5, 7, 10, 15], 0)
0
>>> binary_search_std_lib([0, 5, 7, 10, 15], 15)
4
>>> binary_search_std_lib([0, 5, 7, 10, 15], 5)
1
>>> binary_search_std_lib([0, 5, 7, 10, 15], 6)
-1
 - Function 'binary_search_by_recursion' takes 4 arguments: sorted_collection, item, left, right.  Docstring: Pure implementation of a binary search algorithm in Python by recursion

Be careful collection must be ascending sorted otherwise, the result will be
unpredictable
First recursion should be started with left=0 and right=(len(sorted_collection)-1)

:param sorted_collection: some ascending sorted collection with comparable items
:param item: item value to search
:return: index of the found item or -1 if the item is not found

Examples:
>>> binary_search_by_recursion([0, 5, 7, 10, 15], 0, 0, 4)
0
>>> binary_search_by_recursion([0, 5, 7, 10, 15], 15, 0, 4)
4
>>> binary_search_by_recursion([0, 5, 7, 10, 15], 5, 0, 4)
1
>>> binary_search_by_recursion([0, 5, 7, 10, 15], 6, 0, 4)
-1
 - Function 'exponential_search' takes 2 arguments: sorted_collection, item.  Docstring: Pure implementation of an exponential search algorithm in Python
Resources used:
https://en.wikipedia.org/wiki/Exponential_search

Be careful collection must be ascending sorted otherwise, result will be
unpredictable

:param sorted_collection: some ascending sorted collection with comparable items
:param item: item value to search
:return: index of the found item or -1 if the item is not found

the order of this algorithm is O(lg I) where I is index position of item if exist

Examples:
>>> exponential_search([0, 5, 7, 10, 15], 0)
0
>>> exponential_search([0, 5, 7, 10, 15], 15)
4
>>> exponential_search([0, 5, 7, 10, 15], 5)
1
>>> exponential_search([0, 5, 7, 10, 15], 6)
-1

File: binary_tree_traversal.py
 - Function '__init__' takes 2 arguments: self, data.  No docstring available.
 - Function 'build_tree' takes 0 arguments: .  No docstring available.
 - Function 'pre_order' takes 1 arguments: node.  Docstring: >>> root = TreeNode(1)
>>> tree_node2 = TreeNode(2)
>>> tree_node3 = TreeNode(3)
>>> tree_node4 = TreeNode(4)
>>> tree_node5 = TreeNode(5)
>>> tree_node6 = TreeNode(6)
>>> tree_node7 = TreeNode(7)
>>> root.left, root.right = tree_node2, tree_node3
>>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5
>>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7
>>> pre_order(root)
1,2,4,5,3,6,7,
 - Function 'in_order' takes 1 arguments: node.  Docstring: >>> root = TreeNode(1)
>>> tree_node2 = TreeNode(2)
>>> tree_node3 = TreeNode(3)
>>> tree_node4 = TreeNode(4)
>>> tree_node5 = TreeNode(5)
>>> tree_node6 = TreeNode(6)
>>> tree_node7 = TreeNode(7)
>>> root.left, root.right = tree_node2, tree_node3
>>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5
>>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7
>>> in_order(root)
4,2,5,1,6,3,7,
 - Function 'post_order' takes 1 arguments: node.  Docstring: >>> root = TreeNode(1)
>>> tree_node2 = TreeNode(2)
>>> tree_node3 = TreeNode(3)
>>> tree_node4 = TreeNode(4)
>>> tree_node5 = TreeNode(5)
>>> tree_node6 = TreeNode(6)
>>> tree_node7 = TreeNode(7)
>>> root.left, root.right = tree_node2, tree_node3
>>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5
>>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7
>>> post_order(root)
4,5,2,6,7,3,1,
 - Function 'level_order' takes 1 arguments: node.  Docstring: >>> root = TreeNode(1)
>>> tree_node2 = TreeNode(2)
>>> tree_node3 = TreeNode(3)
>>> tree_node4 = TreeNode(4)
>>> tree_node5 = TreeNode(5)
>>> tree_node6 = TreeNode(6)
>>> tree_node7 = TreeNode(7)
>>> root.left, root.right = tree_node2, tree_node3
>>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5
>>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7
>>> level_order(root)
1,2,3,4,5,6,7,
 - Function 'level_order_actual' takes 1 arguments: node.  Docstring: >>> root = TreeNode(1)
>>> tree_node2 = TreeNode(2)
>>> tree_node3 = TreeNode(3)
>>> tree_node4 = TreeNode(4)
>>> tree_node5 = TreeNode(5)
>>> tree_node6 = TreeNode(6)
>>> tree_node7 = TreeNode(7)
>>> root.left, root.right = tree_node2, tree_node3
>>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5
>>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7
>>> level_order_actual(root)
1,
2,3,
4,5,6,7,
 - Function 'pre_order_iter' takes 1 arguments: node.  Docstring: >>> root = TreeNode(1)
>>> tree_node2 = TreeNode(2)
>>> tree_node3 = TreeNode(3)
>>> tree_node4 = TreeNode(4)
>>> tree_node5 = TreeNode(5)
>>> tree_node6 = TreeNode(6)
>>> tree_node7 = TreeNode(7)
>>> root.left, root.right = tree_node2, tree_node3
>>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5
>>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7
>>> pre_order_iter(root)
1,2,4,5,3,6,7,
 - Function 'in_order_iter' takes 1 arguments: node.  Docstring: >>> root = TreeNode(1)
>>> tree_node2 = TreeNode(2)
>>> tree_node3 = TreeNode(3)
>>> tree_node4 = TreeNode(4)
>>> tree_node5 = TreeNode(5)
>>> tree_node6 = TreeNode(6)
>>> tree_node7 = TreeNode(7)
>>> root.left, root.right = tree_node2, tree_node3
>>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5
>>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7
>>> in_order_iter(root)
4,2,5,1,6,3,7,
 - Function 'post_order_iter' takes 1 arguments: node.  Docstring: >>> root = TreeNode(1)
>>> tree_node2 = TreeNode(2)
>>> tree_node3 = TreeNode(3)
>>> tree_node4 = TreeNode(4)
>>> tree_node5 = TreeNode(5)
>>> tree_node6 = TreeNode(6)
>>> tree_node7 = TreeNode(7)
>>> root.left, root.right = tree_node2, tree_node3
>>> tree_node2.left, tree_node2.right = tree_node4 , tree_node5
>>> tree_node3.left, tree_node3.right = tree_node6 , tree_node7
>>> post_order_iter(root)
4,5,2,6,7,3,1,
 - Function 'prompt' takes 3 arguments: s, width, char.  No docstring available.

File: double_linear_search.py
 - Function 'double_linear_search' takes 2 arguments: array, search_item.  Docstring: Iterate through the array from both sides to find the index of search_item.

:param array: the array to be searched
:param search_item: the item to be searched
:return the index of search_item, if search_item is in array, else -1

Examples:
>>> double_linear_search([1, 5, 5, 10], 1)
0
>>> double_linear_search([1, 5, 5, 10], 5)
1
>>> double_linear_search([1, 5, 5, 10], 100)
-1
>>> double_linear_search([1, 5, 5, 10], 10)
3

File: double_linear_search_recursion.py
 - Function 'search' takes 4 arguments: list_data, key, left, right.  Docstring: Iterate through the array to find the index of key using recursion.
:param list_data: the list to be searched
:param key: the key to be searched
:param left: the index of first element
:param right: the index of last element
:return: the index of key value if found, -1 otherwise.

>>> search(list(range(0, 11)), 5)
5
>>> search([1, 2, 4, 5, 3], 4)
2
>>> search([1, 2, 4, 5, 3], 6)
-1
>>> search([5], 5)
0
>>> search([], 1)
-1

File: fibonacci_search.py
 - Function 'fibonacci' takes 1 arguments: k.  Docstring: Finds fibonacci number in index k.

Parameters
----------
k :
    Index of fibonacci.

Returns
-------
int
    Fibonacci number in position k.

>>> fibonacci(0)
0
>>> fibonacci(2)
1
>>> fibonacci(5)
5
>>> fibonacci(15)
610
>>> fibonacci('a')
Traceback (most recent call last):
TypeError: k must be an integer.
>>> fibonacci(-5)
Traceback (most recent call last):
ValueError: k integer must be greater or equal to zero.
 - Function 'fibonacci_search' takes 2 arguments: arr, val.  Docstring: A pure Python implementation of a fibonacci search algorithm.

Parameters
----------
arr
    List of sorted elements.
val
    Element to search in list.

Returns
-------
int
    The index of the element in the array.
    -1 if the element is not found.

>>> fibonacci_search([4, 5, 6, 7], 4)
0
>>> fibonacci_search([4, 5, 6, 7], -10)
-1
>>> fibonacci_search([-18, 2], -18)
0
>>> fibonacci_search([5], 5)
0
>>> fibonacci_search(['a', 'c', 'd'], 'c')
1
>>> fibonacci_search(['a', 'c', 'd'], 'f')
-1
>>> fibonacci_search([], 1)
-1
>>> fibonacci_search([.1, .4 , 7], .4)
1
>>> fibonacci_search([], 9)
-1
>>> fibonacci_search(list(range(100)), 63)
63
>>> fibonacci_search(list(range(100)), 99)
99
>>> fibonacci_search(list(range(-100, 100, 3)), -97)
1
>>> fibonacci_search(list(range(-100, 100, 3)), 0)
-1
>>> fibonacci_search(list(range(-100, 100, 5)), 0)
20
>>> fibonacci_search(list(range(-100, 100, 5)), 95)
39

File: hill_climbing.py
 - Function '__init__' takes 5 arguments: self, x, y, step_size, function_to_optimize.  Docstring: The constructor of the search problem.

x: the x coordinate of the current search state.
y: the y coordinate of the current search state.
step_size: size of the step to take when looking for neighbors.
function_to_optimize: a function to optimize having the signature f(x, y).
 - Function 'score' takes 1 arguments: self.  Docstring: Returns the output of the function called with current x and y coordinates.
>>> def test_function(x, y):
...     return x + y
>>> SearchProblem(0, 0, 1, test_function).score()  # 0 + 0 = 0
0
>>> SearchProblem(5, 7, 1, test_function).score()  # 5 + 7 = 12
12
 - Function 'get_neighbors' takes 1 arguments: self.  Docstring: Returns a list of coordinates of neighbors adjacent to the current coordinates.

Neighbors:
| 0 | 1 | 2 |
| 3 | _ | 4 |
| 5 | 6 | 7 |
 - Function '__hash__' takes 1 arguments: self.  Docstring: hash the string representation of the current search state.
 - Function '__eq__' takes 2 arguments: self, obj.  Docstring: Check if the 2 objects are equal.
 - Function '__str__' takes 1 arguments: self.  Docstring: string representation of the current search state.
>>> str(SearchProblem(0, 0, 1, None))
'x: 0 y: 0'
>>> str(SearchProblem(2, 5, 1, None))
'x: 2 y: 5'
 - Function 'hill_climbing' takes 8 arguments: search_prob, find_max, max_x, min_x, max_y, min_y, visualization, max_iter.  Docstring: Implementation of the hill climbling algorithm.
We start with a given state, find all its neighbors,
move towards the neighbor which provides the maximum (or minimum) change.
We keep doing this until we are at a state where we do not have any
neighbors which can improve the solution.
    Args:
        search_prob: The search state at the start.
        find_max: If True, the algorithm should find the maximum else the minimum.
        max_x, min_x, max_y, min_y: the maximum and minimum bounds of x and y.
        visualization: If True, a matplotlib graph is displayed.
        max_iter: number of times to run the iteration.
    Returns a search state having the maximum (or minimum) score.
 - Function 'test_f1' takes 2 arguments: x, y.  No docstring available.
 - Function 'test_f2' takes 2 arguments: x, y.  No docstring available.

File: interpolation_search.py
 - Function 'interpolation_search' takes 2 arguments: sorted_collection, item.  Docstring: Searches for an item in a sorted collection by interpolation search algorithm.

Args:
    sorted_collection: sorted list of integers
    item: item value to search

Returns:
    int: The index of the found item, or None if the item is not found.
Examples:
>>> interpolation_search([1, 2, 3, 4, 5], 2)
1
>>> interpolation_search([1, 2, 3, 4, 5], 4)
3
>>> interpolation_search([1, 2, 3, 4, 5], 6) is None
True
>>> interpolation_search([], 1) is None
True
>>> interpolation_search([100], 100)
0
>>> interpolation_search([1, 2, 3, 4, 5], 0) is None
True
>>> interpolation_search([1, 2, 3, 4, 5], 7) is None
True
>>> interpolation_search([1, 2, 3, 4, 5], 2)
1
>>> interpolation_search([1, 2, 3, 4, 5], 0) is None
True
>>> interpolation_search([1, 2, 3, 4, 5], 7) is None
True
>>> interpolation_search([1, 2, 3, 4, 5], 2)
1
>>> interpolation_search([5, 5, 5, 5, 5], 3) is None
True
 - Function 'interpolation_search_by_recursion' takes 4 arguments: sorted_collection, item, left, right.  Docstring: Pure implementation of interpolation search algorithm in Python by recursion
Be careful collection must be ascending sorted, otherwise result will be
unpredictable
First recursion should be started with left=0 and right=(len(sorted_collection)-1)

Args:
    sorted_collection: some sorted collection with comparable items
    item: item value to search
    left: left index in collection
    right: right index in collection

Returns:
    index of item in collection or None if item is not present

Examples:
>>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 0)
0
>>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 15)
4
>>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 5)
1
>>> interpolation_search_by_recursion([0, 5, 7, 10, 15], 100) is None
True
>>> interpolation_search_by_recursion([5, 5, 5, 5, 5], 3) is None
True

File: jump_search.py
 - Function '__lt__' takes 0 arguments: .  No docstring available.
 - Function 'jump_search' takes 2 arguments: arr, item.  Docstring: Python implementation of the jump search algorithm.
Return the index if the `item` is found, otherwise return -1.

Examples:
>>> jump_search([0, 1, 2, 3, 4, 5], 3)
3
>>> jump_search([-5, -2, -1], -1)
2
>>> jump_search([0, 5, 10, 20], 8)
-1
>>> jump_search([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610], 55)
10
>>> jump_search(["aa", "bb", "cc", "dd", "ee", "ff"], "ee")
4

File: linear_search.py
 - Function 'linear_search' takes 2 arguments: sequence, target.  Docstring: A pure Python implementation of a linear search algorithm

:param sequence: a collection with comparable items (as sorted items not required
    in Linear Search)
:param target: item value to search
:return: index of found item or -1 if item is not found

Examples:
>>> linear_search([0, 5, 7, 10, 15], 0)
0
>>> linear_search([0, 5, 7, 10, 15], 15)
4
>>> linear_search([0, 5, 7, 10, 15], 5)
1
>>> linear_search([0, 5, 7, 10, 15], 6)
-1
 - Function 'rec_linear_search' takes 4 arguments: sequence, low, high, target.  Docstring: A pure Python implementation of a recursive linear search algorithm

:param sequence: a collection with comparable items (as sorted items not required
    in Linear Search)
:param low: Lower bound of the array
:param high: Higher bound of the array
:param target: The element to be found
:return: Index of the key or -1 if key not found

Examples:
>>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 0)
0
>>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 700)
4
>>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, 30)
1
>>> rec_linear_search([0, 30, 500, 100, 700], 0, 4, -6)
-1

File: median_of_medians.py
 - Function 'median_of_five' takes 1 arguments: arr.  Docstring: Return the median of the input list
:param arr: Array to find median of
:return: median of arr

>>> median_of_five([2, 4, 5, 7, 899])
5
>>> median_of_five([5, 7, 899, 54, 32])
32
>>> median_of_five([5, 4, 3, 2])
4
>>> median_of_five([3, 5, 7, 10, 2])
5
 - Function 'median_of_medians' takes 1 arguments: arr.  Docstring: Return a pivot to partition data on by calculating
Median of medians of input data
:param arr: The data to be checked (a list)
:return: median of medians of input array

>>> median_of_medians([2, 4, 5, 7, 899, 54, 32])
54
>>> median_of_medians([5, 7, 899, 54, 32])
32
>>> median_of_medians([5, 4, 3, 2])
4
>>> median_of_medians([3, 5, 7, 10, 2, 12])
12
 - Function 'quick_select' takes 2 arguments: arr, target.  Docstring: Two way partition the data into smaller and greater lists,
in relationship to the pivot
:param arr: The data to be searched (a list)
:param target: The rank to be searched
:return: element at rank target

>>> quick_select([2, 4, 5, 7, 899, 54, 32], 5)
32
>>> quick_select([2, 4, 5, 7, 899, 54, 32], 1)
2
>>> quick_select([5, 4, 3, 2], 2)
3
>>> quick_select([3, 5, 7, 10, 2, 12], 3)
5

File: quick_select.py
 - Function '_partition' takes 2 arguments: data, pivot.  Docstring: Three way partition the data into smaller, equal and greater lists,
in relationship to the pivot
:param data: The data to be sorted (a list)
:param pivot: The value to partition the data on
:return: Three list: smaller, equal and greater
 - Function 'quick_select' takes 2 arguments: items, index.  Docstring: >>> quick_select([2, 4, 5, 7, 899, 54, 32], 5)
54
>>> quick_select([2, 4, 5, 7, 899, 54, 32], 1)
4
>>> quick_select([5, 4, 3, 2], 2)
4
>>> quick_select([3, 5, 7, 10, 2, 12], 3)
7

File: sentinel_linear_search.py
 - Function 'sentinel_linear_search' takes 2 arguments: sequence, target.  Docstring: Pure implementation of sentinel linear search algorithm in Python

:param sequence: some sequence with comparable items
:param target: item value to search
:return: index of found item or None if item is not found

Examples:
>>> sentinel_linear_search([0, 5, 7, 10, 15], 0)
0

>>> sentinel_linear_search([0, 5, 7, 10, 15], 15)
4

>>> sentinel_linear_search([0, 5, 7, 10, 15], 5)
1

>>> sentinel_linear_search([0, 5, 7, 10, 15], 6)

File: simple_binary_search.py
 - Function 'binary_search' takes 2 arguments: a_list, item.  Docstring: >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]
>>> binary_search(test_list, 3)
False
>>> binary_search(test_list, 13)
True
>>> binary_search([4, 4, 5, 6, 7], 4)
True
>>> binary_search([4, 4, 5, 6, 7], -10)
False
>>> binary_search([-18, 2], -18)
True
>>> binary_search([5], 5)
True
>>> binary_search(['a', 'c', 'd'], 'c')
True
>>> binary_search(['a', 'c', 'd'], 'f')
False
>>> binary_search([], 1)
False
>>> binary_search([-.1, .1 , .8], .1)
True
>>> binary_search(range(-5000, 5000, 10), 80)
True
>>> binary_search(range(-5000, 5000, 10), 1255)
False
>>> binary_search(range(0, 10000, 5), 2)
False

File: simulated_annealing.py
 - Function 'simulated_annealing' takes 10 arguments: search_prob, find_max, max_x, min_x, max_y, min_y, visualization, start_temperate, rate_of_decrease, threshold_temp.  Docstring: Implementation of the simulated annealing algorithm. We start with a given state,
find all its neighbors. Pick a random neighbor, if that neighbor improves the
solution, we move in that direction, if that neighbor does not improve the solution,
we generate a random real number between 0 and 1, if the number is within a certain
range (calculated using temperature) we move in that direction, else we pick
another neighbor randomly and repeat the process.

Args:
    search_prob: The search state at the start.
    find_max: If True, the algorithm should find the minimum else the minimum.
    max_x, min_x, max_y, min_y: the maximum and minimum bounds of x and y.
    visualization: If True, a matplotlib graph is displayed.
    start_temperate: the initial temperate of the system when the program starts.
    rate_of_decrease: the rate at which the temperate decreases in each iteration.
    threshold_temp: the threshold temperature below which we end the search
Returns a search state having the maximum (or minimum) score.
 - Function 'test_f1' takes 2 arguments: x, y.  No docstring available.
 - Function 'test_f2' takes 2 arguments: x, y.  No docstring available.

File: tabu_search.py
 - Function 'generate_neighbours' takes 1 arguments: path.  Docstring: Pure implementation of generating a dictionary of neighbors and the cost with each
neighbor, given a path file that includes a graph.

:param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)
:return dict_of_neighbours: Dictionary with key each node and value a list of lists
    with the neighbors of the node and the cost (distance) for each neighbor.

Example of dict_of_neighbours:
>>) dict_of_neighbours[a]
[[b,20],[c,18],[d,22],[e,26]]

This indicates the neighbors of node (city) 'a', which has neighbor the node 'b'
with distance 20, the node 'c' with distance 18, the node 'd' with distance 22 and
the node 'e' with distance 26.
 - Function 'generate_first_solution' takes 2 arguments: path, dict_of_neighbours.  Docstring: Pure implementation of generating the first solution for the Tabu search to start,
with the redundant resolution strategy. That means that we start from the starting
node (e.g. node 'a'), then we go to the city nearest (lowest distance) to this node
(let's assume is node 'c'), then we go to the nearest city of the node 'c', etc.
till we have visited all cities and return to the starting node.

:param path: The path to the .txt file that includes the graph (e.g.tabudata2.txt)
:param dict_of_neighbours: Dictionary with key each node and value a list of lists
    with the neighbors of the node and the cost (distance) for each neighbor.
:return first_solution: The solution for the first iteration of Tabu search using
    the redundant resolution strategy in a list.
:return distance_of_first_solution: The total distance that Travelling Salesman
    will travel, if he follows the path in first_solution.
 - Function 'find_neighborhood' takes 2 arguments: solution, dict_of_neighbours.  Docstring: Pure implementation of generating the neighborhood (sorted by total distance of
each solution from lowest to highest) of a solution with 1-1 exchange method, that
means we exchange each node in a solution with each other node and generating a
number of solution named neighborhood.

:param solution: The solution in which we want to find the neighborhood.
:param dict_of_neighbours: Dictionary with key each node and value a list of lists
    with the neighbors of the node and the cost (distance) for each neighbor.
:return neighborhood_of_solution: A list that includes the solutions and the total
    distance of each solution (in form of list) that are produced with 1-1 exchange
    from the solution that the method took as an input

Example:
>>> find_neighborhood(['a', 'c', 'b', 'd', 'e', 'a'],
...                   {'a': [['b', '20'], ['c', '18'], ['d', '22'], ['e', '26']],
...                    'c': [['a', '18'], ['b', '10'], ['d', '23'], ['e', '24']],
...                    'b': [['a', '20'], ['c', '10'], ['d', '11'], ['e', '12']],
...                    'e': [['a', '26'], ['b', '12'], ['c', '24'], ['d', '40']],
...                    'd': [['a', '22'], ['b', '11'], ['c', '23'], ['e', '40']]}
...                   )  # doctest: +NORMALIZE_WHITESPACE
[['a', 'e', 'b', 'd', 'c', 'a', 90],
 ['a', 'c', 'd', 'b', 'e', 'a', 90],
 ['a', 'd', 'b', 'c', 'e', 'a', 93],
 ['a', 'c', 'b', 'e', 'd', 'a', 102],
 ['a', 'c', 'e', 'd', 'b', 'a', 113],
 ['a', 'b', 'c', 'd', 'e', 'a', 119]]
 - Function 'tabu_search' takes 5 arguments: first_solution, distance_of_first_solution, dict_of_neighbours, iters, size.  Docstring: Pure implementation of Tabu search algorithm for a Travelling Salesman Problem in
Python.

:param first_solution: The solution for the first iteration of Tabu search using
    the redundant resolution strategy in a list.
:param distance_of_first_solution: The total distance that Travelling Salesman will
    travel, if he follows the path in first_solution.
:param dict_of_neighbours: Dictionary with key each node and value a list of lists
    with the neighbors of the node and the cost (distance) for each neighbor.
:param iters: The number of iterations that Tabu search will execute.
:param size: The size of Tabu List.
:return best_solution_ever: The solution with the lowest distance that occurred
    during the execution of Tabu search.
:return best_cost: The total distance that Travelling Salesman will travel, if he
    follows the path in best_solution ever.
 - Function 'main' takes 1 arguments: args.  No docstring available.

File: ternary_search.py
 - Function 'lin_search' takes 4 arguments: left, right, array, target.  Docstring: Perform linear search in list. Returns -1 if element is not found.

Parameters
----------
left : int
    left index bound.
right : int
    right index bound.
array : List[int]
    List of elements to be searched on
target : int
    Element that is searched

Returns
-------
int
    index of element that is looked for.

Examples
--------
>>> lin_search(0, 4, [4, 5, 6, 7], 7)
3
>>> lin_search(0, 3, [4, 5, 6, 7], 7)
-1
>>> lin_search(0, 2, [-18, 2], -18)
0
>>> lin_search(0, 1, [5], 5)
0
>>> lin_search(0, 3, ['a', 'c', 'd'], 'c')
1
>>> lin_search(0, 3, [.1, .4 , -.1], .1)
0
>>> lin_search(0, 3, [.1, .4 , -.1], -.1)
2
 - Function 'ite_ternary_search' takes 2 arguments: array, target.  Docstring: Iterative method of the ternary search algorithm.
>>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]
>>> ite_ternary_search(test_list, 3)
-1
>>> ite_ternary_search(test_list, 13)
4
>>> ite_ternary_search([4, 5, 6, 7], 4)
0
>>> ite_ternary_search([4, 5, 6, 7], -10)
-1
>>> ite_ternary_search([-18, 2], -18)
0
>>> ite_ternary_search([5], 5)
0
>>> ite_ternary_search(['a', 'c', 'd'], 'c')
1
>>> ite_ternary_search(['a', 'c', 'd'], 'f')
-1
>>> ite_ternary_search([], 1)
-1
>>> ite_ternary_search([.1, .4 , -.1], .1)
0
 - Function 'rec_ternary_search' takes 4 arguments: left, right, array, target.  Docstring: Recursive method of the ternary search algorithm.

>>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]
>>> rec_ternary_search(0, len(test_list), test_list, 3)
-1
>>> rec_ternary_search(4, len(test_list), test_list, 42)
8
>>> rec_ternary_search(0, 2, [4, 5, 6, 7], 4)
0
>>> rec_ternary_search(0, 3, [4, 5, 6, 7], -10)
-1
>>> rec_ternary_search(0, 1, [-18, 2], -18)
0
>>> rec_ternary_search(0, 1, [5], 5)
0
>>> rec_ternary_search(0, 2, ['a', 'c', 'd'], 'c')
1
>>> rec_ternary_search(0, 2, ['a', 'c', 'd'], 'f')
-1
>>> rec_ternary_search(0, 0, [], 1)
-1
>>> rec_ternary_search(0, 3, [.1, .4 , -.1], .1)
0

File: bead_sort.py
 - Function 'bead_sort' takes 1 arguments: sequence.  Docstring: >>> bead_sort([6, 11, 12, 4, 1, 5])
[1, 4, 5, 6, 11, 12]

>>> bead_sort([9, 8, 7, 6, 5, 4 ,3, 2, 1])
[1, 2, 3, 4, 5, 6, 7, 8, 9]

>>> bead_sort([5, 0, 4, 3])
[0, 3, 4, 5]

>>> bead_sort([8, 2, 1])
[1, 2, 8]

>>> bead_sort([1, .9, 0.0, 0, -1, -.9])
Traceback (most recent call last):
    ...
TypeError: Sequence must be list of non-negative integers

>>> bead_sort("Hello world")
Traceback (most recent call last):
    ...
TypeError: Sequence must be list of non-negative integers

File: binary_insertion_sort.py
 - Function 'binary_insertion_sort' takes 1 arguments: collection.  Docstring: Sorts a list using the binary insertion sort algorithm.

:param collection: A mutable ordered collection with comparable items.
:return: The same collection ordered in ascending order.

Examples:
>>> binary_insertion_sort([0, 4, 1234, 4, 1])
[0, 1, 4, 4, 1234]
>>> binary_insertion_sort([]) == sorted([])
True
>>> binary_insertion_sort([-1, -2, -3]) == sorted([-1, -2, -3])
True
>>> lst = ['d', 'a', 'b', 'e', 'c']
>>> binary_insertion_sort(lst) == sorted(lst)
True
>>> import random
>>> collection = random.sample(range(-50, 50), 100)
>>> binary_insertion_sort(collection) == sorted(collection)
True
>>> import string
>>> collection = random.choices(string.ascii_letters + string.digits, k=100)
>>> binary_insertion_sort(collection) == sorted(collection)
True

File: bitonic_sort.py
 - Function 'comp_and_swap' takes 4 arguments: array, index1, index2, direction.  Docstring: Compare the value at given index1 and index2 of the array and swap them as per
the given direction.

The parameter direction indicates the sorting direction, ASCENDING(1) or
DESCENDING(0); if (a[i] > a[j]) agrees with the direction, then a[i] and a[j] are
interchanged.

>>> arr = [12, 42, -21, 1]
>>> comp_and_swap(arr, 1, 2, 1)
>>> arr
[12, -21, 42, 1]

>>> comp_and_swap(arr, 1, 2, 0)
>>> arr
[12, 42, -21, 1]

>>> comp_and_swap(arr, 0, 3, 1)
>>> arr
[1, 42, -21, 12]

>>> comp_and_swap(arr, 0, 3, 0)
>>> arr
[12, 42, -21, 1]
 - Function 'bitonic_merge' takes 4 arguments: array, low, length, direction.  Docstring: It recursively sorts a bitonic sequence in ascending order, if direction = 1, and in
descending if direction = 0.
The sequence to be sorted starts at index position low, the parameter length is the
number of elements to be sorted.

>>> arr = [12, 42, -21, 1]
>>> bitonic_merge(arr, 0, 4, 1)
>>> arr
[-21, 1, 12, 42]

>>> bitonic_merge(arr, 0, 4, 0)
>>> arr
[42, 12, 1, -21]
 - Function 'bitonic_sort' takes 4 arguments: array, low, length, direction.  Docstring: This function first produces a bitonic sequence by recursively sorting its two
halves in opposite sorting orders, and then calls bitonic_merge to make them in the
same order.

>>> arr = [12, 34, 92, -23, 0, -121, -167, 145]
>>> bitonic_sort(arr, 0, 8, 1)
>>> arr
[-167, -121, -23, 0, 12, 34, 92, 145]

>>> bitonic_sort(arr, 0, 8, 0)
>>> arr
[145, 92, 34, 12, 0, -23, -121, -167]

File: bogo_sort.py
 - Function 'bogo_sort' takes 1 arguments: collection.  Docstring: Pure implementation of the bogosort algorithm in Python
:param collection: some mutable ordered collection with heterogeneous
comparable items inside
:return: the same collection ordered by ascending
Examples:
>>> bogo_sort([0, 5, 3, 2, 2])
[0, 2, 2, 3, 5]
>>> bogo_sort([])
[]
>>> bogo_sort([-2, -5, -45])
[-45, -5, -2]
 - Function 'is_sorted' takes 1 arguments: collection.  No docstring available.

File: bubble_sort.py
 - Function 'bubble_sort_iterative' takes 1 arguments: collection.  Docstring: Pure implementation of bubble sort algorithm in Python

:param collection: some mutable ordered collection with heterogeneous
comparable items inside
:return: the same collection ordered by ascending

Examples:
>>> bubble_sort_iterative([0, 5, 2, 3, 2])
[0, 2, 2, 3, 5]
>>> bubble_sort_iterative([])
[]
>>> bubble_sort_iterative([-2, -45, -5])
[-45, -5, -2]
>>> bubble_sort_iterative([-23, 0, 6, -4, 34])
[-23, -4, 0, 6, 34]
>>> bubble_sort_iterative([0, 5, 2, 3, 2]) == sorted([0, 5, 2, 3, 2])
True
>>> bubble_sort_iterative([]) == sorted([])
True
>>> bubble_sort_iterative([-2, -45, -5]) == sorted([-2, -45, -5])
True
>>> bubble_sort_iterative([-23, 0, 6, -4, 34]) == sorted([-23, 0, 6, -4, 34])
True
>>> bubble_sort_iterative(['d', 'a', 'b', 'e']) == sorted(['d', 'a', 'b', 'e'])
True
>>> bubble_sort_iterative(['z', 'a', 'y', 'b', 'x', 'c'])
['a', 'b', 'c', 'x', 'y', 'z']
>>> bubble_sort_iterative([1.1, 3.3, 5.5, 7.7, 2.2, 4.4, 6.6])
[1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7]
>>> bubble_sort_iterative([1, 3.3, 5, 7.7, 2, 4.4, 6])
[1, 2, 3.3, 4.4, 5, 6, 7.7]
>>> import random
>>> collection_arg = random.sample(range(-50, 50), 100)
>>> bubble_sort_iterative(collection_arg) == sorted(collection_arg)
True
>>> import string
>>> collection_arg = random.choices(string.ascii_letters + string.digits, k=100)
>>> bubble_sort_iterative(collection_arg) == sorted(collection_arg)
True
 - Function 'bubble_sort_recursive' takes 1 arguments: collection.  Docstring: It is similar iterative bubble sort but recursive.

:param collection: mutable ordered sequence of elements
:return: the same list in ascending order

Examples:
>>> bubble_sort_recursive([0, 5, 2, 3, 2])
[0, 2, 2, 3, 5]
>>> bubble_sort_iterative([])
[]
>>> bubble_sort_recursive([-2, -45, -5])
[-45, -5, -2]
>>> bubble_sort_recursive([-23, 0, 6, -4, 34])
[-23, -4, 0, 6, 34]
>>> bubble_sort_recursive([0, 5, 2, 3, 2]) == sorted([0, 5, 2, 3, 2])
True
>>> bubble_sort_recursive([]) == sorted([])
True
>>> bubble_sort_recursive([-2, -45, -5]) == sorted([-2, -45, -5])
True
>>> bubble_sort_recursive([-23, 0, 6, -4, 34]) == sorted([-23, 0, 6, -4, 34])
True
>>> bubble_sort_recursive(['d', 'a', 'b', 'e']) == sorted(['d', 'a', 'b', 'e'])
True
>>> bubble_sort_recursive(['z', 'a', 'y', 'b', 'x', 'c'])
['a', 'b', 'c', 'x', 'y', 'z']
>>> bubble_sort_recursive([1.1, 3.3, 5.5, 7.7, 2.2, 4.4, 6.6])
[1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7]
>>> bubble_sort_recursive([1, 3.3, 5, 7.7, 2, 4.4, 6])
[1, 2, 3.3, 4.4, 5, 6, 7.7]
>>> import random
>>> collection_arg = random.sample(range(-50, 50), 100)
>>> bubble_sort_recursive(collection_arg) == sorted(collection_arg)
True
>>> import string
>>> collection_arg = random.choices(string.ascii_letters + string.digits, k=100)
>>> bubble_sort_recursive(collection_arg) == sorted(collection_arg)
True

File: bucket_sort.py
 - Function 'bucket_sort' takes 2 arguments: my_list, bucket_count.  Docstring: >>> data = [-1, 2, -5, 0]
>>> bucket_sort(data) == sorted(data)
True
>>> data = [9, 8, 7, 6, -12]
>>> bucket_sort(data) == sorted(data)
True
>>> data = [.4, 1.2, .1, .2, -.9]
>>> bucket_sort(data) == sorted(data)
True
>>> bucket_sort([]) == sorted([])
True
>>> data = [-1e10, 1e10]
>>> bucket_sort(data) == sorted(data)
True
>>> import random
>>> collection = random.sample(range(-50, 50), 50)
>>> bucket_sort(collection) == sorted(collection)
True

File: circle_sort.py
 - Function 'circle_sort' takes 1 arguments: collection.  Docstring: A pure Python implementation of circle sort algorithm

:param collection: a mutable collection of comparable items in any order
:return: the same collection in ascending order

Examples:
>>> circle_sort([0, 5, 3, 2, 2])
[0, 2, 2, 3, 5]
>>> circle_sort([])
[]
>>> circle_sort([-2, 5, 0, -45])
[-45, -2, 0, 5]
>>> collections = ([], [0, 5, 3, 2, 2], [-2, 5, 0, -45])
>>> all(sorted(collection) == circle_sort(collection) for collection in collections)
True
 - Function 'circle_sort_util' takes 3 arguments: collection, low, high.  Docstring: >>> arr = [5,4,3,2,1]
>>> circle_sort_util(lst, 0, 2)
True
>>> arr
[3, 4, 5, 2, 1]

File: cocktail_shaker_sort.py
 - Function 'cocktail_shaker_sort' takes 1 arguments: arr.  Docstring: Sorts a list using the Cocktail Shaker Sort algorithm.

:param arr: List of elements to be sorted.
:return: Sorted list.

>>> cocktail_shaker_sort([4, 5, 2, 1, 2])
[1, 2, 2, 4, 5]
>>> cocktail_shaker_sort([-4, 5, 0, 1, 2, 11])
[-4, 0, 1, 2, 5, 11]
>>> cocktail_shaker_sort([0.1, -2.4, 4.4, 2.2])
[-2.4, 0.1, 2.2, 4.4]
>>> cocktail_shaker_sort([1, 2, 3, 4, 5])
[1, 2, 3, 4, 5]
>>> cocktail_shaker_sort([-4, -5, -24, -7, -11])
[-24, -11, -7, -5, -4]
>>> cocktail_shaker_sort(["elderberry", "banana", "date", "apple", "cherry"])
['apple', 'banana', 'cherry', 'date', 'elderberry']
>>> cocktail_shaker_sort((-4, -5, -24, -7, -11))
Traceback (most recent call last):
    ...
TypeError: 'tuple' object does not support item assignment

File: comb_sort.py
 - Function 'comb_sort' takes 1 arguments: data.  Docstring: Pure implementation of comb sort algorithm in Python
:param data: mutable collection with comparable items
:return: the same collection in ascending order
Examples:
>>> comb_sort([0, 5, 3, 2, 2])
[0, 2, 2, 3, 5]
>>> comb_sort([])
[]
>>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3])
[-15, -7, 0, 2, 3, 8, 45, 99]

File: counting_sort.py
 - Function 'counting_sort' takes 1 arguments: collection.  Docstring: Pure implementation of counting sort algorithm in Python
:param collection: some mutable ordered collection with heterogeneous
comparable items inside
:return: the same collection ordered by ascending
Examples:
>>> counting_sort([0, 5, 3, 2, 2])
[0, 2, 2, 3, 5]
>>> counting_sort([])
[]
>>> counting_sort([-2, -5, -45])
[-45, -5, -2]
 - Function 'counting_sort_string' takes 1 arguments: string.  Docstring: >>> counting_sort_string("thisisthestring")
'eghhiiinrsssttt'

File: cycle_sort.py
 - Function 'cycle_sort' takes 1 arguments: array.  Docstring: >>> cycle_sort([4, 3, 2, 1])
[1, 2, 3, 4]

>>> cycle_sort([-4, 20, 0, -50, 100, -1])
[-50, -4, -1, 0, 20, 100]

>>> cycle_sort([-.1, -.2, 1.3, -.8])
[-0.8, -0.2, -0.1, 1.3]

>>> cycle_sort([])
[]

File: double_sort.py
 - Function 'double_sort' takes 1 arguments: collection.  Docstring: This sorting algorithm sorts an array using the principle of bubble sort,
but does it both from left to right and right to left.
Hence, it's called "Double sort"
:param collection: mutable ordered sequence of elements
:return: the same collection in ascending order
Examples:
>>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6 ,-7])
[-7, -6, -5, -4, -3, -2, -1]
>>> double_sort([])
[]
>>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6])
[-6, -5, -4, -3, -2, -1]
>>> double_sort([-3, 10, 16, -42, 29]) == sorted([-3, 10, 16, -42, 29])
True

File: dutch_national_flag_sort.py
 - Function 'dutch_national_flag_sort' takes 1 arguments: sequence.  Docstring: A pure Python implementation of Dutch National Flag sort algorithm.
:param data: 3 unique integer values (e.g., 0, 1, 2) in an sequence
:return: The same collection in ascending order

>>> dutch_national_flag_sort([])
[]
>>> dutch_national_flag_sort([0])
[0]
>>> dutch_national_flag_sort([2, 1, 0, 0, 1, 2])
[0, 0, 1, 1, 2, 2]
>>> dutch_national_flag_sort([0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1])
[0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2]
>>> dutch_national_flag_sort("abacab")
Traceback (most recent call last):
  ...
ValueError: The elements inside the sequence must contains only (0, 1, 2) values
>>> dutch_national_flag_sort("Abacab")
Traceback (most recent call last):
  ...
ValueError: The elements inside the sequence must contains only (0, 1, 2) values
>>> dutch_national_flag_sort([3, 2, 3, 1, 3, 0, 3])
Traceback (most recent call last):
  ...
ValueError: The elements inside the sequence must contains only (0, 1, 2) values
>>> dutch_national_flag_sort([-1, 2, -1, 1, -1, 0, -1])
Traceback (most recent call last):
  ...
ValueError: The elements inside the sequence must contains only (0, 1, 2) values
>>> dutch_national_flag_sort([1.1, 2, 1.1, 1, 1.1, 0, 1.1])
Traceback (most recent call last):
  ...
ValueError: The elements inside the sequence must contains only (0, 1, 2) values

File: exchange_sort.py
 - Function 'exchange_sort' takes 1 arguments: numbers.  Docstring: Uses exchange sort to sort a list of numbers.
Source: https://en.wikipedia.org/wiki/Sorting_algorithm#Exchange_sort
>>> exchange_sort([5, 4, 3, 2, 1])
[1, 2, 3, 4, 5]
>>> exchange_sort([-1, -2, -3])
[-3, -2, -1]
>>> exchange_sort([1, 2, 3, 4, 5])
[1, 2, 3, 4, 5]
>>> exchange_sort([0, 10, -2, 5, 3])
[-2, 0, 3, 5, 10]
>>> exchange_sort([])
[]

File: external_sort.py
 - Function '__init__' takes 2 arguments: self, filename.  No docstring available.
 - Function 'write_block' takes 3 arguments: self, data, block_number.  No docstring available.
 - Function 'get_block_filenames' takes 1 arguments: self.  No docstring available.
 - Function 'split' takes 3 arguments: self, block_size, sort_key.  No docstring available.
 - Function 'cleanup' takes 1 arguments: self.  No docstring available.
 - Function 'select' takes 2 arguments: self, choices.  No docstring available.
 - Function '__init__' takes 2 arguments: self, files.  No docstring available.
 - Function 'get_dict' takes 1 arguments: self.  No docstring available.
 - Function 'refresh' takes 1 arguments: self.  No docstring available.
 - Function 'unshift' takes 2 arguments: self, index.  No docstring available.
 - Function '__init__' takes 2 arguments: self, merge_strategy.  No docstring available.
 - Function 'merge' takes 4 arguments: self, filenames, outfilename, buffer_size.  No docstring available.
 - Function 'get_file_handles' takes 3 arguments: self, filenames, buffer_size.  No docstring available.
 - Function '__init__' takes 2 arguments: self, block_size.  No docstring available.
 - Function 'sort' takes 3 arguments: self, filename, sort_key.  No docstring available.
 - Function 'get_number_blocks' takes 3 arguments: self, filename, block_size.  No docstring available.
 - Function 'parse_memory' takes 1 arguments: string.  No docstring available.
 - Function 'main' takes 0 arguments: .  No docstring available.

File: gnome_sort.py
 - Function 'gnome_sort' takes 1 arguments: lst.  Docstring: Pure implementation of the gnome sort algorithm in Python

Take some mutable ordered collection with heterogeneous comparable items inside as
arguments, return the same collection ordered by ascending.

Examples:
>>> gnome_sort([0, 5, 3, 2, 2])
[0, 2, 2, 3, 5]

>>> gnome_sort([])
[]

>>> gnome_sort([-2, -5, -45])
[-45, -5, -2]

>>> "".join(gnome_sort(list(set("Gnomes are stupid!"))))
' !Gadeimnoprstu'

File: heap_sort.py
 - Function 'heapify' takes 3 arguments: unsorted, index, heap_size.  No docstring available.
 - Function 'heap_sort' takes 1 arguments: unsorted.  Docstring: Pure implementation of the heap sort algorithm in Python
:param collection: some mutable ordered collection with heterogeneous
comparable items inside
:return: the same collection ordered by ascending

Examples:
>>> heap_sort([0, 5, 3, 2, 2])
[0, 2, 2, 3, 5]

>>> heap_sort([])
[]

>>> heap_sort([-2, -5, -45])
[-45, -5, -2]

File: insertion_sort.py
 - Function '__lt__' takes 0 arguments: .  No docstring available.
 - Function 'insertion_sort' takes 1 arguments: collection.  Docstring: A pure Python implementation of the insertion sort algorithm

:param collection: some mutable ordered collection with heterogeneous
comparable items inside
:return: the same collection ordered by ascending

Examples:
>>> insertion_sort([0, 5, 3, 2, 2])
[0, 2, 2, 3, 5]
>>> insertion_sort([]) == sorted([])
True
>>> insertion_sort([-2, -5, -45]) == sorted([-2, -5, -45])
True
>>> insertion_sort(['d', 'a', 'b', 'e', 'c']) == sorted(['d', 'a', 'b', 'e', 'c'])
True
>>> import random
>>> collection = random.sample(range(-50, 50), 100)
>>> insertion_sort(collection) == sorted(collection)
True
>>> import string
>>> collection = random.choices(string.ascii_letters + string.digits, k=100)
>>> insertion_sort(collection) == sorted(collection)
True

File: intro_sort.py
 - Function 'insertion_sort' takes 3 arguments: array, start, end.  Docstring: >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]
>>> insertion_sort(array, 0, len(array))
[1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]
>>> array = [21, 15, 11, 45, -2, -11, 46]
>>> insertion_sort(array, 0, len(array))
[-11, -2, 11, 15, 21, 45, 46]
>>> array = [-2, 0, 89, 11, 48, 79, 12]
>>> insertion_sort(array, 0, len(array))
[-2, 0, 11, 12, 48, 79, 89]
>>> array = ['a', 'z', 'd', 'p', 'v', 'l', 'o', 'o']
>>> insertion_sort(array, 0, len(array))
['a', 'd', 'l', 'o', 'o', 'p', 'v', 'z']
>>> array = [73.568, 73.56, -45.03, 1.7, 0, 89.45]
>>> insertion_sort(array, 0, len(array))
[-45.03, 0, 1.7, 73.56, 73.568, 89.45]
 - Function 'heapify' takes 3 arguments: array, index, heap_size.  Docstring: >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]
>>> heapify(array, len(array) // 2, len(array))
 - Function 'heap_sort' takes 1 arguments: array.  Docstring: >>> heap_sort([4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12])
[1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]
>>> heap_sort([-2, -11, 0, 0, 0, 87, 45, -69, 78, 12, 10, 103, 89, 52])
[-69, -11, -2, 0, 0, 0, 10, 12, 45, 52, 78, 87, 89, 103]
>>> heap_sort(['b', 'd', 'e', 'f', 'g', 'p', 'x', 'z', 'b', 's', 'e', 'u', 'v'])
['b', 'b', 'd', 'e', 'e', 'f', 'g', 'p', 's', 'u', 'v', 'x', 'z']
>>> heap_sort([6.2, -45.54, 8465.20, 758.56, -457.0, 0, 1, 2.879, 1.7, 11.7])
[-457.0, -45.54, 0, 1, 1.7, 2.879, 6.2, 11.7, 758.56, 8465.2]
 - Function 'median_of_3' takes 4 arguments: array, first_index, middle_index, last_index.  Docstring: >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]
>>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1)
12
>>> array = [13, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]
>>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1)
13
>>> array = [4, 2, 6, 8, 1, 7, 8, 22, 15, 14, 27, 79, 23, 45, 14, 16]
>>> median_of_3(array, 0, ((len(array) - 0) // 2) + 1, len(array) - 1)
14
 - Function 'partition' takes 4 arguments: array, low, high, pivot.  Docstring: >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]
>>> partition(array, 0, len(array), 12)
8
>>> array = [21, 15, 11, 45, -2, -11, 46]
>>> partition(array, 0, len(array), 15)
3
>>> array = ['a', 'z', 'd', 'p', 'v', 'l', 'o', 'o']
>>> partition(array, 0, len(array), 'p')
5
>>> array = [6.2, -45.54, 8465.20, 758.56, -457.0, 0, 1, 2.879, 1.7, 11.7]
>>> partition(array, 0, len(array), 2.879)
6
 - Function 'sort' takes 1 arguments: array.  Docstring: :param collection: some mutable ordered collection with heterogeneous
comparable items inside
:return: the same collection ordered by ascending

Examples:
>>> sort([4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12])
[1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]
>>> sort([-1, -5, -3, -13, -44])
[-44, -13, -5, -3, -1]
>>> sort([])
[]
>>> sort([5])
[5]
>>> sort([-3, 0, -7, 6, 23, -34])
[-34, -7, -3, 0, 6, 23]
>>> sort([1.7, 1.0, 3.3, 2.1, 0.3 ])
[0.3, 1.0, 1.7, 2.1, 3.3]
>>> sort(['d', 'a', 'b', 'e', 'c'])
['a', 'b', 'c', 'd', 'e']
 - Function 'intro_sort' takes 5 arguments: array, start, end, size_threshold, max_depth.  Docstring: >>> array = [4, 2, 6, 8, 1, 7, 8, 22, 14, 56, 27, 79, 23, 45, 14, 12]
>>> max_depth = 2 * math.ceil(math.log2(len(array)))
>>> intro_sort(array, 0, len(array), 16, max_depth)
[1, 2, 4, 6, 7, 8, 8, 12, 14, 14, 22, 23, 27, 45, 56, 79]

File: iterative_merge_sort.py
 - Function 'merge' takes 4 arguments: input_list, low, mid, high.  Docstring: sorting left-half and right-half individually
then merging them into result
 - Function 'iter_merge_sort' takes 1 arguments: input_list.  Docstring: Return a sorted copy of the input list

>>> iter_merge_sort([5, 9, 8, 7, 1, 2, 7])
[1, 2, 5, 7, 7, 8, 9]
>>> iter_merge_sort([1])
[1]
>>> iter_merge_sort([2, 1])
[1, 2]
>>> iter_merge_sort([2, 1, 3])
[1, 2, 3]
>>> iter_merge_sort([4, 3, 2, 1])
[1, 2, 3, 4]
>>> iter_merge_sort([5, 4, 3, 2, 1])
[1, 2, 3, 4, 5]
>>> iter_merge_sort(['c', 'b', 'a'])
['a', 'b', 'c']
>>> iter_merge_sort([0.3, 0.2, 0.1])
[0.1, 0.2, 0.3]
>>> iter_merge_sort(['dep', 'dang', 'trai'])
['dang', 'dep', 'trai']
>>> iter_merge_sort([6])
[6]
>>> iter_merge_sort([])
[]
>>> iter_merge_sort([-2, -9, -1, -4])
[-9, -4, -2, -1]
>>> iter_merge_sort([1.1, 1, 0.0, -1, -1.1])
[-1.1, -1, 0.0, 1, 1.1]
>>> iter_merge_sort(['c', 'b', 'a'])
['a', 'b', 'c']
>>> iter_merge_sort('cba')
['a', 'b', 'c']

File: merge_insertion_sort.py
 - Function 'binary_search_insertion' takes 2 arguments: sorted_list, item.  Docstring: >>> binary_search_insertion([1, 2, 7, 9, 10], 4)
[1, 2, 4, 7, 9, 10]
 - Function 'merge' takes 2 arguments: left, right.  Docstring: >>> merge([[1, 6], [9, 10]], [[2, 3], [4, 5], [7, 8]])
[[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]
 - Function 'sortlist_2d' takes 1 arguments: list_2d.  Docstring: >>> sortlist_2d([[9, 10], [1, 6], [7, 8], [2, 3], [4, 5]])
[[1, 6], [2, 3], [4, 5], [7, 8], [9, 10]]
 - Function 'merge_insertion_sort' takes 1 arguments: collection.  Docstring: Pure implementation of merge-insertion sort algorithm in Python

:param collection: some mutable ordered collection with heterogeneous
comparable items inside
:return: the same collection ordered by ascending

Examples:
>>> merge_insertion_sort([0, 5, 3, 2, 2])
[0, 2, 2, 3, 5]

>>> merge_insertion_sort([99])
[99]

>>> merge_insertion_sort([-2, -5, -45])
[-45, -5, -2]

Testing with all permutations on range(0,5):
>>> import itertools
>>> permutations = list(itertools.permutations([0, 1, 2, 3, 4]))
>>> all(merge_insertion_sort(p) == [0, 1, 2, 3, 4] for p in permutations)
True

File: merge_sort.py
 - Function 'merge_sort' takes 1 arguments: collection.  Docstring: Sorts a list using the merge sort algorithm.

:param collection: A mutable ordered collection with comparable items.
:return: The same collection ordered in ascending order.

Time Complexity: O(n log n)

Examples:
>>> merge_sort([0, 5, 3, 2, 2])
[0, 2, 2, 3, 5]
>>> merge_sort([])
[]
>>> merge_sort([-2, -5, -45])
[-45, -5, -2]
 - Function 'merge' takes 2 arguments: left, right.  Docstring: Merge two sorted lists into a single sorted list.

:param left: Left collection
:param right: Right collection
:return: Merged result

File: msd_radix_sort.py
 - Function 'msd_radix_sort' takes 1 arguments: list_of_ints.  Docstring: Implementation of the MSD radix sort algorithm. Only works
with positive integers
:param list_of_ints: A list of integers
:return: Returns the sorted list
>>> msd_radix_sort([40, 12, 1, 100, 4])
[1, 4, 12, 40, 100]
>>> msd_radix_sort([])
[]
>>> msd_radix_sort([123, 345, 123, 80])
[80, 123, 123, 345]
>>> msd_radix_sort([1209, 834598, 1, 540402, 45])
[1, 45, 1209, 540402, 834598]
>>> msd_radix_sort([-1, 34, 45])
Traceback (most recent call last):
    ...
ValueError: All numbers must be positive
 - Function '_msd_radix_sort' takes 2 arguments: list_of_ints, bit_position.  Docstring: Sort the given list based on the bit at bit_position. Numbers with a
0 at that position will be at the start of the list, numbers with a
1 at the end.
:param list_of_ints: A list of integers
:param bit_position: the position of the bit that gets compared
:return: Returns a partially sorted list
>>> _msd_radix_sort([45, 2, 32], 1)
[2, 32, 45]
>>> _msd_radix_sort([10, 4, 12], 2)
[4, 12, 10]
 - Function 'msd_radix_sort_inplace' takes 1 arguments: list_of_ints.  Docstring: Inplace implementation of the MSD radix sort algorithm.
Sorts based on the binary representation of the integers.
>>> lst = [1, 345, 23, 89, 0, 3]
>>> msd_radix_sort_inplace(lst)
>>> lst == sorted(lst)
True
>>> lst = [1, 43, 0, 0, 0, 24, 3, 3]
>>> msd_radix_sort_inplace(lst)
>>> lst == sorted(lst)
True
>>> lst = []
>>> msd_radix_sort_inplace(lst)
>>> lst == []
True
>>> lst = [-1, 34, 23, 4, -42]
>>> msd_radix_sort_inplace(lst)
Traceback (most recent call last):
    ...
ValueError: All numbers must be positive
 - Function '_msd_radix_sort_inplace' takes 4 arguments: list_of_ints, bit_position, begin_index, end_index.  Docstring: Sort the given list based on the bit at bit_position. Numbers with a
0 at that position will be at the start of the list, numbers with a
1 at the end.
>>> lst = [45, 2, 32, 24, 534, 2932]
>>> _msd_radix_sort_inplace(lst, 1, 0, 3)
>>> lst == [32, 2, 45, 24, 534, 2932]
True
>>> lst = [0, 2, 1, 3, 12, 10, 4, 90, 54, 2323, 756]
>>> _msd_radix_sort_inplace(lst, 2, 4, 7)
>>> lst == [0, 2, 1, 3, 12, 4, 10, 90, 54, 2323, 756]
True

File: natural_sort.py
 - Function 'natural_sort' takes 1 arguments: input_list.  Docstring: Sort the given list of strings in the way that humans expect.

The normal Python sort algorithm sorts lexicographically,
so you might not get the results that you expect...

>>> example1 = ['2 ft 7 in', '1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '7 ft 6 in']
>>> sorted(example1)
['1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '2 ft 7 in', '7 ft 6 in']
>>> # The natural sort algorithm sort based on meaning and not computer code point.
>>> natural_sort(example1)
['1 ft 5 in', '2 ft 7 in', '2 ft 11 in', '7 ft 6 in', '10 ft 2 in']

>>> example2 = ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']
>>> sorted(example2)
['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']
>>> natural_sort(example2)
['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
 - Function 'alphanum_key' takes 1 arguments: key.  No docstring available.

File: odd_even_sort.py
 - Function 'odd_even_sort' takes 1 arguments: input_list.  Docstring: Sort input with odd even sort.

This algorithm uses the same idea of bubblesort,
but by first dividing in two phase (odd and even).
Originally developed for use on parallel processors
with local interconnections.
:param collection: mutable ordered sequence of elements
:return: same collection in ascending order
Examples:
>>> odd_even_sort([5 , 4 ,3 ,2 ,1])
[1, 2, 3, 4, 5]
>>> odd_even_sort([])
[]
>>> odd_even_sort([-10 ,-1 ,10 ,2])
[-10, -1, 2, 10]
>>> odd_even_sort([1 ,2 ,3 ,4])
[1, 2, 3, 4]

File: odd_even_transposition_parallel.py
 - Function 'oe_process' takes 8 arguments: position, value, l_send, r_send, lr_cv, rr_cv, result_pipe, multiprocessing_context.  No docstring available.
 - Function 'odd_even_transposition' takes 1 arguments: arr.  Docstring: >>> odd_even_transposition(list(range(10)[::-1])) == sorted(list(range(10)[::-1]))
True
>>> odd_even_transposition(["a", "x", "c"]) == sorted(["x", "a", "c"])
True
>>> odd_even_transposition([1.9, 42.0, 2.8]) == sorted([1.9, 42.0, 2.8])
True
>>> odd_even_transposition([False, True, False]) == sorted([False, False, True])
True
>>> odd_even_transposition([1, 32.0, 9]) == sorted([False, False, True])
False
>>> odd_even_transposition([1, 32.0, 9]) == sorted([1.0, 32, 9.0])
True
>>> unsorted_list = [-442, -98, -554, 266, -491, 985, -53, -529, 82, -429]
>>> odd_even_transposition(unsorted_list) == sorted(unsorted_list)
True
>>> unsorted_list = [-442, -98, -554, 266, -491, 985, -53, -529, 82, -429]
>>> odd_even_transposition(unsorted_list) == sorted(unsorted_list + [1])
False
 - Function 'main' takes 0 arguments: .  No docstring available.

File: odd_even_transposition_single_threaded.py
 - Function 'odd_even_transposition' takes 1 arguments: arr.  Docstring: >>> odd_even_transposition([5, 4, 3, 2, 1])
[1, 2, 3, 4, 5]

>>> odd_even_transposition([13, 11, 18, 0, -1])
[-1, 0, 11, 13, 18]

>>> odd_even_transposition([-.1, 1.1, .1, -2.9])
[-2.9, -0.1, 0.1, 1.1]

File: pancake_sort.py
 - Function 'pancake_sort' takes 1 arguments: arr.  Docstring: Sort Array with Pancake Sort.
:param arr: Collection containing comparable items
:return: Collection ordered in ascending order of items
Examples:
>>> pancake_sort([0, 5, 3, 2, 2])
[0, 2, 2, 3, 5]
>>> pancake_sort([])
[]
>>> pancake_sort([-2, -5, -45])
[-45, -5, -2]

File: patience_sort.py
 - Function '__lt__' takes 2 arguments: self, other.  No docstring available.
 - Function '__eq__' takes 2 arguments: self, other.  No docstring available.
 - Function 'patience_sort' takes 1 arguments: collection.  Docstring: A pure implementation of patience sort algorithm in Python

:param collection: some mutable ordered collection with heterogeneous
comparable items inside
:return: the same collection ordered by ascending

Examples:
>>> patience_sort([1, 9, 5, 21, 17, 6])
[1, 5, 6, 9, 17, 21]

>>> patience_sort([])
[]

>>> patience_sort([-3, -17, -48])
[-48, -17, -3]

File: pigeonhole_sort.py
 - Function 'pigeonhole_sort' takes 1 arguments: a.  Docstring: >>> a = [8, 3, 2, 7, 4, 6, 8]
>>> b = sorted(a)  # a nondestructive sort
>>> pigeonhole_sort(a)  # a destructive sort
>>> a == b
True
 - Function 'main' takes 0 arguments: .  No docstring available.

File: pigeon_sort.py
 - Function 'pigeon_sort' takes 1 arguments: array.  Docstring: Implementation of pigeon hole sort algorithm
:param array: Collection of comparable items
:return: Collection sorted in ascending order
>>> pigeon_sort([0, 5, 3, 2, 2])
[0, 2, 2, 3, 5]
>>> pigeon_sort([])
[]
>>> pigeon_sort([-2, -5, -45])
[-45, -5, -2]

File: quick_sort.py
 - Function 'quick_sort' takes 1 arguments: collection.  Docstring: A pure Python implementation of quicksort algorithm.

:param collection: a mutable collection of comparable items
:return: the same collection ordered in ascending order

Examples:
>>> quick_sort([0, 5, 3, 2, 2])
[0, 2, 2, 3, 5]
>>> quick_sort([])
[]
>>> quick_sort([-2, 5, 0, -45])
[-45, -2, 0, 5]

File: quick_sort_3_partition.py
 - Function 'quick_sort_3partition' takes 3 arguments: sorting, left, right.  No docstring available.
 - Function 'quick_sort_lomuto_partition' takes 3 arguments: sorting, left, right.  Docstring: A pure Python implementation of quick sort algorithm(in-place)
with Lomuto partition scheme:
https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme

:param sorting: sort list
:param left: left endpoint of sorting
:param right: right endpoint of sorting
:return: None

Examples:
>>> nums1 = [0, 5, 3, 1, 2]
>>> quick_sort_lomuto_partition(nums1, 0, 4)
>>> nums1
[0, 1, 2, 3, 5]
>>> nums2 = []
>>> quick_sort_lomuto_partition(nums2, 0, 0)
>>> nums2
[]
>>> nums3 = [-2, 5, 0, -4]
>>> quick_sort_lomuto_partition(nums3, 0, 3)
>>> nums3
[-4, -2, 0, 5]
 - Function 'lomuto_partition' takes 3 arguments: sorting, left, right.  Docstring: Example:
>>> lomuto_partition([1,5,7,6], 0, 3)
2
 - Function 'three_way_radix_quicksort' takes 1 arguments: sorting.  Docstring: Three-way radix quicksort:
https://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort
First divide the list into three parts.
Then recursively sort the "less than" and "greater than" partitions.

>>> three_way_radix_quicksort([])
[]
>>> three_way_radix_quicksort([1])
[1]
>>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])
[-5, -2, -2, 0, 1, 1]
>>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])
[-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]

File: radix_sort.py
 - Function 'radix_sort' takes 1 arguments: list_of_ints.  Docstring: Examples:
>>> radix_sort([0, 5, 3, 2, 2])
[0, 2, 2, 3, 5]

>>> radix_sort(list(range(15))) == sorted(range(15))
True
>>> radix_sort(list(range(14,-1,-1))) == sorted(range(15))
True
>>> radix_sort([1,100,10,1000]) == sorted([1,100,10,1000])
True

File: recursive_insertion_sort.py
 - Function 'rec_insertion_sort' takes 2 arguments: collection, n.  Docstring: Given a collection of numbers and its length, sorts the collections
in ascending order

:param collection: A mutable collection of comparable elements
:param n: The length of collections

>>> col = [1, 2, 1]
>>> rec_insertion_sort(col, len(col))
>>> col
[1, 1, 2]

>>> col = [2, 1, 0, -1, -2]
>>> rec_insertion_sort(col, len(col))
>>> col
[-2, -1, 0, 1, 2]

>>> col = [1]
>>> rec_insertion_sort(col, len(col))
>>> col
[1]
 - Function 'insert_next' takes 2 arguments: collection, index.  Docstring: Inserts the '(index-1)th' element into place

>>> col = [3, 2, 4, 2]
>>> insert_next(col, 1)
>>> col
[2, 3, 4, 2]

>>> col = [3, 2, 3]
>>> insert_next(col, 2)
>>> col
[3, 2, 3]

>>> col = []
>>> insert_next(col, 1)
>>> col
[]

File: recursive_mergesort_array.py
 - Function 'merge' takes 1 arguments: arr.  Docstring: Return a sorted array.
>>> merge([10,9,8,7,6,5,4,3,2,1])
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> merge([1,2,3,4,5,6,7,8,9,10])
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> merge([10,22,1,2,3,9,15,23])
[1, 2, 3, 9, 10, 15, 22, 23]
>>> merge([100])
[100]
>>> merge([])
[]

File: recursive_quick_sort.py
 - Function 'quick_sort' takes 1 arguments: data.  Docstring: >>> for data in ([2, 1, 0], [2.2, 1.1, 0], "quick_sort"):
...     quick_sort(data) == sorted(data)
True
True
True

File: selection_sort.py
 - Function 'selection_sort' takes 1 arguments: collection.  Docstring: Sorts a list in ascending order using the selection sort algorithm.

:param collection: A list of integers to be sorted.
:return: The sorted list.

Examples:
>>> selection_sort([0, 5, 3, 2, 2])
[0, 2, 2, 3, 5]

>>> selection_sort([])
[]

>>> selection_sort([-2, -5, -45])
[-45, -5, -2]

File: shell_sort.py
 - Function 'shell_sort' takes 1 arguments: collection.  Docstring: Pure implementation of shell sort algorithm in Python
:param collection:  Some mutable ordered collection with heterogeneous
comparable items inside
:return:  the same collection ordered by ascending

>>> shell_sort([0, 5, 3, 2, 2])
[0, 2, 2, 3, 5]
>>> shell_sort([])
[]
>>> shell_sort([-2, -5, -45])
[-45, -5, -2]

File: shrink_shell_sort.py
 - Function 'shell_sort' takes 1 arguments: collection.  Docstring: Implementation of shell sort algorithm in Python
:param collection:  Some mutable ordered collection with heterogeneous
comparable items inside
:return:  the same collection ordered by ascending

>>> shell_sort([3, 2, 1])
[1, 2, 3]
>>> shell_sort([])
[]
>>> shell_sort([1])
[1]

File: slowsort.py
 - Function 'slowsort' takes 3 arguments: sequence, start, end.  Docstring: Sorts sequence[start..end] (both inclusive) in-place.
start defaults to 0 if not given.
end defaults to len(sequence) - 1 if not given.
It returns None.
>>> seq = [1, 6, 2, 5, 3, 4, 4, 5]; slowsort(seq); seq
[1, 2, 3, 4, 4, 5, 5, 6]
>>> seq = []; slowsort(seq); seq
[]
>>> seq = [2]; slowsort(seq); seq
[2]
>>> seq = [1, 2, 3, 4]; slowsort(seq); seq
[1, 2, 3, 4]
>>> seq = [4, 3, 2, 1]; slowsort(seq); seq
[1, 2, 3, 4]
>>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, 2, 7); seq
[9, 8, 2, 3, 4, 5, 6, 7, 1, 0]
>>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, end = 4); seq
[5, 6, 7, 8, 9, 4, 3, 2, 1, 0]
>>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, start = 5); seq
[9, 8, 7, 6, 5, 0, 1, 2, 3, 4]

File: stooge_sort.py
 - Function 'stooge_sort' takes 1 arguments: arr.  Docstring: Examples:
>>> stooge_sort([18.1, 0, -7.1, -1, 2, 2])
[-7.1, -1, 0, 2, 2, 18.1]

>>> stooge_sort([])
[]
 - Function 'stooge' takes 3 arguments: arr, i, h.  No docstring available.

File: strand_sort.py
 - Function 'strand_sort' takes 3 arguments: arr, reverse, solution.  Docstring: Strand sort implementation
source: https://en.wikipedia.org/wiki/Strand_sort

:param arr: Unordered input list
:param reverse: Descent ordering flag
:param solution: Ordered items container

Examples:
>>> strand_sort([4, 2, 5, 3, 0, 1])
[0, 1, 2, 3, 4, 5]

>>> strand_sort([4, 2, 5, 3, 0, 1], reverse=True)
[5, 4, 3, 2, 1, 0]

File: tim_sort.py
 - Function 'binary_search' takes 4 arguments: lst, item, start, end.  No docstring available.
 - Function 'insertion_sort' takes 1 arguments: lst.  No docstring available.
 - Function 'merge' takes 2 arguments: left, right.  No docstring available.
 - Function 'tim_sort' takes 1 arguments: lst.  Docstring: >>> tim_sort("Python")
['P', 'h', 'n', 'o', 't', 'y']
>>> tim_sort((1.1, 1, 0, -1, -1.1))
[-1.1, -1, 0, 1, 1.1]
>>> tim_sort(list(reversed(list(range(7)))))
[0, 1, 2, 3, 4, 5, 6]
>>> tim_sort([3, 2, 1]) == insertion_sort([3, 2, 1])
True
>>> tim_sort([3, 2, 1]) == sorted([3, 2, 1])
True
 - Function 'main' takes 0 arguments: .  No docstring available.

File: topological_sort.py
 - Function 'topological_sort' takes 3 arguments: start, visited, sort.  Docstring: Perform topological sort on a directed acyclic graph.

File: tree_sort.py
 - Function '__iter__' takes 1 arguments: self.  No docstring available.
 - Function '__len__' takes 1 arguments: self.  No docstring available.
 - Function 'insert' takes 2 arguments: self, val.  No docstring available.
 - Function 'tree_sort' takes 1 arguments: arr.  Docstring: >>> tree_sort([])
()
>>> tree_sort((1,))
(1,)
>>> tree_sort((1, 2))
(1, 2)
>>> tree_sort([5, 2, 7])
(2, 5, 7)
>>> tree_sort((5, -4, 9, 2, 7))
(-4, 2, 5, 7, 9)
>>> tree_sort([5, 6, 1, -1, 4, 37, 2, 7])
(-1, 1, 2, 4, 5, 6, 7, 37)

# >>> tree_sort(range(10, -10, -1)) == tuple(sorted(range(10, -10, -1)))
# True

File: unknown_sort.py
 - Function 'merge_sort' takes 1 arguments: collection.  Docstring: Pure implementation of the fastest merge sort algorithm in Python

:param collection: some mutable ordered collection with heterogeneous
comparable items inside
:return: a collection ordered by ascending

Examples:
>>> merge_sort([0, 5, 3, 2, 2])
[0, 2, 2, 3, 5]

>>> merge_sort([])
[]

>>> merge_sort([-2, -5, -45])
[-45, -5, -2]

File: wiggle_sort.py
 - Function 'wiggle_sort' takes 1 arguments: nums.  Docstring: Python implementation of wiggle.
Example:
>>> wiggle_sort([0, 5, 3, 2, 2])
[0, 5, 2, 3, 2]
>>> wiggle_sort([])
[]
>>> wiggle_sort([-2, -5, -45])
[-45, -2, -5]
>>> wiggle_sort([-2.1, -5.68, -45.11])
[-45.11, -2.1, -5.68]

File: aho_corasick.py
 - Function '__init__' takes 2 arguments: self, keywords.  No docstring available.
 - Function 'find_next_state' takes 3 arguments: self, current_state, char.  No docstring available.
 - Function 'add_keyword' takes 2 arguments: self, keyword.  No docstring available.
 - Function 'set_fail_transitions' takes 1 arguments: self.  No docstring available.
 - Function 'search_in' takes 2 arguments: self, string.  Docstring: >>> A = Automaton(["what", "hat", "ver", "er"])
>>> A.search_in("whatever, err ... , wherever")
{'what': [0], 'hat': [1], 'ver': [5, 25], 'er': [6, 10, 22, 26]}

File: alternative_string_arrange.py
 - Function 'alternative_string_arrange' takes 2 arguments: first_str, second_str.  Docstring: Return the alternative arrangements of the two strings.
:param first_str:
:param second_str:
:return: String
>>> alternative_string_arrange("ABCD", "XY")
'AXBYCD'
>>> alternative_string_arrange("XY", "ABCD")
'XAYBCD'
>>> alternative_string_arrange("AB", "XYZ")
'AXBYZ'
>>> alternative_string_arrange("ABC", "")
'ABC'

File: anagrams.py
 - Function 'signature' takes 1 arguments: word.  Docstring: Return a word sorted
>>> signature("test")
'estt'
>>> signature("this is a test")
'   aehiisssttt'
>>> signature("finaltest")
'aefilnstt'
 - Function 'anagram' takes 1 arguments: my_word.  Docstring: Return every anagram of the given word
>>> anagram('test')
['sett', 'stet', 'test']
>>> anagram('this is a test')
[]
>>> anagram('final')
['final']

File: autocomplete_using_trie.py
 - Function '__init__' takes 1 arguments: self.  No docstring available.
 - Function 'insert_word' takes 2 arguments: self, text.  No docstring available.
 - Function 'find_word' takes 2 arguments: self, prefix.  No docstring available.
 - Function '_elements' takes 2 arguments: self, d.  No docstring available.
 - Function 'autocomplete_using_trie' takes 1 arguments: string.  Docstring: >>> trie = Trie()
>>> for word in words:
...     trie.insert_word(word)
...
>>> matches = autocomplete_using_trie("de")
>>> "detergent " in matches
True
>>> "dog " in matches
False
 - Function 'main' takes 0 arguments: .  No docstring available.

File: barcode_validator.py
 - Function 'get_check_digit' takes 1 arguments: barcode.  Docstring: Returns the last digit of barcode by excluding the last digit first
and then computing to reach the actual last digit from the remaining
12 digits.

>>> get_check_digit(8718452538119)
9
>>> get_check_digit(87184523)
5
>>> get_check_digit(87193425381086)
9
>>> [get_check_digit(x) for x in range(0, 100, 10)]
[0, 7, 4, 1, 8, 5, 2, 9, 6, 3]
 - Function 'is_valid' takes 1 arguments: barcode.  Docstring: Checks for length of barcode and last-digit
Returns boolean value of validity of barcode

>>> is_valid(8718452538119)
True
>>> is_valid(87184525)
False
>>> is_valid(87193425381089)
False
>>> is_valid(0)
False
>>> is_valid(dwefgiweuf)
Traceback (most recent call last):
    ...
NameError: name 'dwefgiweuf' is not defined
 - Function 'get_barcode' takes 1 arguments: barcode.  Docstring: Returns the barcode as an integer

>>> get_barcode("8718452538119")
8718452538119
>>> get_barcode("dwefgiweuf")
Traceback (most recent call last):
    ...
ValueError: Barcode 'dwefgiweuf' has alphabetic characters.

File: bitap_string_match.py
 - Function 'bitap_string_match' takes 2 arguments: text, pattern.  Docstring: Retrieves the index of the first occurrence of pattern in text.

Args:
    text: A string consisting only of lowercase alphabetical characters.
    pattern: A string consisting only of lowercase alphabetical characters.

Returns:
    int: The index where pattern first occurs. Return -1  if not found.

>>> bitap_string_match('abdabababc', 'ababc')
5
>>> bitap_string_match('aaaaaaaaaaaaaaaaaa', 'a')
0
>>> bitap_string_match('zxywsijdfosdfnso', 'zxywsijdfosdfnso')
0
>>> bitap_string_match('abdabababc', '')
0
>>> bitap_string_match('abdabababc', 'c')
9
>>> bitap_string_match('abdabababc', 'fofosdfo')
-1
>>> bitap_string_match('abdab', 'fofosdfo')
-1

File: boyer_moore_search.py
 - Function '__init__' takes 3 arguments: self, text, pattern.  No docstring available.
 - Function 'match_in_pattern' takes 2 arguments: self, char.  Docstring: finds the index of char in pattern in reverse order

Parameters :
    char (chr): character to be searched

Returns :
    i (int): index of char from last in pattern
    -1 (int): if char is not found in pattern
 - Function 'mismatch_in_text' takes 2 arguments: self, current_pos.  Docstring: find the index of mis-matched character in text when compared with pattern
from last

Parameters :
    current_pos (int): current index position of text

Returns :
    i (int): index of mismatched char from last in text
    -1 (int): if there is no mismatch between pattern and text block
 - Function 'bad_character_heuristic' takes 1 arguments: self.  No docstring available.

File: camel_case_to_snake_case.py
 - Function 'camel_to_snake_case' takes 1 arguments: input_str.  Docstring: Transforms a camelCase (or PascalCase) string to snake_case

>>> camel_to_snake_case("someRandomString")
'some_random_string'

>>> camel_to_snake_case("SomeRandomStr#ng")
'some_random_str_ng'

>>> camel_to_snake_case("123someRandom123String123")
'123_some_random_123_string_123'

>>> camel_to_snake_case("123SomeRandom123String123")
'123_some_random_123_string_123'

>>> camel_to_snake_case(123)
Traceback (most recent call last):
    ...
ValueError: Expected string as input, found <class 'int'>

File: can_string_be_rearranged_as_palindrome.py
 - Function 'can_string_be_rearranged_as_palindrome_counter' takes 1 arguments: input_str.  Docstring: A Palindrome is a String that reads the same forward as it does backwards.
Examples of Palindromes mom, dad, malayalam
>>> can_string_be_rearranged_as_palindrome_counter("Momo")
True
>>> can_string_be_rearranged_as_palindrome_counter("Mother")
False
>>> can_string_be_rearranged_as_palindrome_counter("Father")
False
>>> can_string_be_rearranged_as_palindrome_counter("A man a plan a canal Panama")
True
 - Function 'can_string_be_rearranged_as_palindrome' takes 1 arguments: input_str.  Docstring: A Palindrome is a String that reads the same forward as it does backwards.
Examples of Palindromes mom, dad, malayalam
>>> can_string_be_rearranged_as_palindrome("Momo")
True
>>> can_string_be_rearranged_as_palindrome("Mother")
False
>>> can_string_be_rearranged_as_palindrome("Father")
False
>>> can_string_be_rearranged_as_palindrome_counter("A man a plan a canal Panama")
True
 - Function 'benchmark' takes 1 arguments: input_str.  Docstring: Benchmark code for comparing above 2 functions

File: capitalize.py
 - Function 'capitalize' takes 1 arguments: sentence.  Docstring: Capitalizes the first letter of a sentence or word.

>>> capitalize("hello world")
'Hello world'
>>> capitalize("123 hello world")
'123 hello world'
>>> capitalize(" hello world")
' hello world'
>>> capitalize("a")
'A'
>>> capitalize("")
''

File: check_anagrams.py
 - Function 'check_anagrams' takes 2 arguments: first_str, second_str.  Docstring: Two strings are anagrams if they are made up of the same letters but are
arranged differently (ignoring the case).
>>> check_anagrams('Silent', 'Listen')
True
>>> check_anagrams('This is a string', 'Is this a string')
True
>>> check_anagrams('This is    a      string', 'Is     this a string')
True
>>> check_anagrams('There', 'Their')
False

File: count_vowels.py
 - Function 'count_vowels' takes 1 arguments: s.  Docstring: Count the number of vowels in a given string.

:param s: Input string to count vowels in.
:return: Number of vowels in the input string.

Examples:
>>> count_vowels("hello world")
3
>>> count_vowels("HELLO WORLD")
3
>>> count_vowels("123 hello world")
3
>>> count_vowels("")
0
>>> count_vowels("a quick brown fox")
5
>>> count_vowels("the quick BROWN fox")
5
>>> count_vowels("PYTHON")
1

File: credit_card_validator.py
 - Function 'validate_initial_digits' takes 1 arguments: credit_card_number.  Docstring: Function to validate initial digits of a given credit card number.
>>> valid = "4111111111111111 41111111111111 34 35 37 412345 523456 634567"
>>> all(validate_initial_digits(cc) for cc in valid.split())
True
>>> invalid = "14 25 76 32323 36111111111111"
>>> all(validate_initial_digits(cc) is False for cc in invalid.split())
True
 - Function 'luhn_validation' takes 1 arguments: credit_card_number.  Docstring: Function to luhn algorithm validation for a given credit card number.
>>> luhn_validation('4111111111111111')
True
>>> luhn_validation('36111111111111')
True
>>> luhn_validation('41111111111111')
False
 - Function 'validate_credit_card_number' takes 1 arguments: credit_card_number.  Docstring: Function to validate the given credit card number.
>>> validate_credit_card_number('4111111111111111')
4111111111111111 is a valid credit card number.
True
>>> validate_credit_card_number('helloworld$')
helloworld$ is an invalid credit card number because it has nonnumerical characters.
False
>>> validate_credit_card_number('32323')
32323 is an invalid credit card number because of its length.
False
>>> validate_credit_card_number('32323323233232332323')
32323323233232332323 is an invalid credit card number because of its length.
False
>>> validate_credit_card_number('36111111111111')
36111111111111 is an invalid credit card number because of its first two digits.
False
>>> validate_credit_card_number('41111111111111')
41111111111111 is an invalid credit card number because it fails the Luhn check.
False

File: damerau_levenshtein_distance.py
 - Function 'damerau_levenshtein_distance' takes 2 arguments: first_string, second_string.  Docstring: Implements the Damerau-Levenshtein distance algorithm that measures
the edit distance between two strings.

Parameters:
    first_string: The first string to compare
    second_string: The second string to compare

Returns:
    distance: The edit distance between the first and second strings

>>> damerau_levenshtein_distance("cat", "cut")
1
>>> damerau_levenshtein_distance("kitten", "sitting")
3
>>> damerau_levenshtein_distance("hello", "world")
4
>>> damerau_levenshtein_distance("book", "back")
2
>>> damerau_levenshtein_distance("container", "containment")
3
>>> damerau_levenshtein_distance("container", "containment")
3

File: detecting_english_programmatically.py
 - Function 'load_dictionary' takes 0 arguments: .  No docstring available.
 - Function 'get_english_count' takes 1 arguments: message.  No docstring available.
 - Function 'remove_non_letters' takes 1 arguments: message.  Docstring: >>> remove_non_letters("Hi! how are you?")
'Hi how are you'
>>> remove_non_letters("P^y%t)h@o*n")
'Python'
>>> remove_non_letters("1+1=2")
''
>>> remove_non_letters("www.google.com/")
'wwwgooglecom'
>>> remove_non_letters("")
''
 - Function 'is_english' takes 3 arguments: message, word_percentage, letter_percentage.  Docstring: >>> is_english('Hello World')
True
>>> is_english('llold HorWd')
False

File: dna.py
 - Function 'dna' takes 1 arguments: dna.  Docstring: https://en.wikipedia.org/wiki/DNA
Returns the second side of a DNA strand

>>> dna("GCTA")
'CGAT'
>>> dna("ATGC")
'TACG'
>>> dna("CTGA")
'GACT'
>>> dna("GFGG")
Traceback (most recent call last):
    ...
ValueError: Invalid Strand

File: frequency_finder.py
 - Function 'get_letter_count' takes 1 arguments: message.  No docstring available.
 - Function 'get_item_at_index_zero' takes 1 arguments: x.  No docstring available.
 - Function 'get_frequency_order' takes 1 arguments: message.  Docstring: Get the frequency order of the letters in the given string
>>> get_frequency_order('Hello World')
'LOWDRHEZQXJKVBPYGFMUCSNIAT'
>>> get_frequency_order('Hello@')
'LHOEZQXJKVBPYGFWMUCDRSNIAT'
>>> get_frequency_order('h')
'HZQXJKVBPYGFWMUCLDRSNIOATE'
 - Function 'english_freq_match_score' takes 1 arguments: message.  Docstring: >>> english_freq_match_score('Hello World')
1

File: hamming_distance.py
 - Function 'hamming_distance' takes 2 arguments: string1, string2.  Docstring: Calculate the Hamming distance between two equal length strings
In information theory, the Hamming distance between two strings of equal
length is the number of positions at which the corresponding symbols are
different. https://en.wikipedia.org/wiki/Hamming_distance

Args:
    string1 (str): Sequence 1
    string2 (str): Sequence 2

Returns:
    int: Hamming distance

>>> hamming_distance("python", "python")
0
>>> hamming_distance("karolin", "kathrin")
3
>>> hamming_distance("00000", "11111")
5
>>> hamming_distance("karolin", "kath")
Traceback (most recent call last):
  ...
ValueError: String lengths must match!

File: indian_phone_validator.py
 - Function 'indian_phone_validator' takes 1 arguments: phone.  Docstring: Determine whether the string is a valid phone number or not
:param phone:
:return: Boolean
>>> indian_phone_validator("+91123456789")
False
>>> indian_phone_validator("+919876543210")
True
>>> indian_phone_validator("01234567896")
False
>>> indian_phone_validator("919876543218")
True
>>> indian_phone_validator("+91-1234567899")
False
>>> indian_phone_validator("+91-9876543218")
True

File: is_contains_unique_chars.py
 - Function 'is_contains_unique_chars' takes 1 arguments: input_str.  Docstring: Check if all characters in the string is unique or not.
>>> is_contains_unique_chars("I_love.py")
True
>>> is_contains_unique_chars("I don't love Python")
False

Time complexity: O(n)
Space complexity: O(1) 19320 bytes as we are having 144697 characters in unicode

File: is_isogram.py
 - Function 'is_isogram' takes 1 arguments: string.  Docstring: An isogram is a word in which no letter is repeated.
Examples of isograms are uncopyrightable and ambidextrously.
>>> is_isogram('Uncopyrightable')
True
>>> is_isogram('allowance')
False
>>> is_isogram('copy1')
Traceback (most recent call last):
 ...
ValueError: String must only contain alphabetic characters.

File: is_pangram.py
 - Function 'is_pangram' takes 1 arguments: input_str.  Docstring: A Pangram String contains all the alphabets at least once.
>>> is_pangram("The quick brown fox jumps over the lazy dog")
True
>>> is_pangram("Waltz, bad nymph, for quick jigs vex.")
True
>>> is_pangram("Jived fox nymph grabs quick waltz.")
True
>>> is_pangram("My name is Unknown")
False
>>> is_pangram("The quick brown fox jumps over the la_y dog")
False
>>> is_pangram()
True
 - Function 'is_pangram_faster' takes 1 arguments: input_str.  Docstring: >>> is_pangram_faster("The quick brown fox jumps over the lazy dog")
True
>>> is_pangram_faster("Waltz, bad nymph, for quick jigs vex.")
True
>>> is_pangram_faster("Jived fox nymph grabs quick waltz.")
True
>>> is_pangram_faster("The quick brown fox jumps over the la_y dog")
False
>>> is_pangram_faster()
True
 - Function 'is_pangram_fastest' takes 1 arguments: input_str.  Docstring: >>> is_pangram_fastest("The quick brown fox jumps over the lazy dog")
True
>>> is_pangram_fastest("Waltz, bad nymph, for quick jigs vex.")
True
>>> is_pangram_fastest("Jived fox nymph grabs quick waltz.")
True
>>> is_pangram_fastest("The quick brown fox jumps over the la_y dog")
False
>>> is_pangram_fastest()
True
 - Function 'benchmark' takes 0 arguments: .  Docstring: Benchmark code comparing different version.

File: is_polish_national_id.py
 - Function 'is_polish_national_id' takes 1 arguments: input_str.  Docstring: Verification of the correctness of the PESEL number.
www-gov-pl.translate.goog/web/gov/czym-jest-numer-pesel?_x_tr_sl=auto&_x_tr_tl=en

PESEL can start with 0, that's why we take str as input,
but convert it to int for some calculations.


>>> is_polish_national_id(123)
Traceback (most recent call last):
    ...
ValueError: Expected str as input, found <class 'int'>

>>> is_polish_national_id("abc")
Traceback (most recent call last):
    ...
ValueError: Expected number as input

>>> is_polish_national_id("02070803628") # correct PESEL
True

>>> is_polish_national_id("02150803629") # wrong month
False

>>> is_polish_national_id("02075503622") # wrong day
False

>>> is_polish_national_id("-99012212349") # wrong range
False

>>> is_polish_national_id("990122123499999") # wrong range
False

>>> is_polish_national_id("02070803621") # wrong checksum
False

File: is_spain_national_id.py
 - Function 'is_spain_national_id' takes 1 arguments: spanish_id.  Docstring: Spain National Id is a string composed by 8 numbers plus a letter
The letter in fact is not part of the ID, it acts as a validator,
checking you didn't do a mistake when entering it on a system or
are giving a fake one.

https://en.wikipedia.org/wiki/Documento_Nacional_de_Identidad_(Spain)#Number

>>> is_spain_national_id("12345678Z")
True
>>> is_spain_national_id("12345678z")  # It is case-insensitive
True
>>> is_spain_national_id("12345678x")
False
>>> is_spain_national_id("12345678I")
False
>>> is_spain_national_id("12345678-Z")  # Some systems add a dash
True
>>> is_spain_national_id("12345678")
Traceback (most recent call last):
    ...
ValueError: Input must be a string of 8 numbers plus letter
>>> is_spain_national_id("123456709")
Traceback (most recent call last):
    ...
ValueError: Input must be a string of 8 numbers plus letter
>>> is_spain_national_id("1234567--Z")
Traceback (most recent call last):
    ...
ValueError: Input must be a string of 8 numbers plus letter
>>> is_spain_national_id("1234Z")
Traceback (most recent call last):
    ...
ValueError: Input must be a string of 8 numbers plus letter
>>> is_spain_national_id("1234ZzZZ")
Traceback (most recent call last):
    ...
ValueError: Input must be a string of 8 numbers plus letter
>>> is_spain_national_id(12345678)
Traceback (most recent call last):
    ...
TypeError: Expected string as input, found int

File: is_srilankan_phone_number.py
 - Function 'is_sri_lankan_phone_number' takes 1 arguments: phone.  Docstring: Determine whether the string is a valid sri lankan mobile phone number or not
References: https://aye.sh/blog/sri-lankan-phone-number-regex

>>> is_sri_lankan_phone_number("+94773283048")
True
>>> is_sri_lankan_phone_number("+9477-3283048")
True
>>> is_sri_lankan_phone_number("0718382399")
True
>>> is_sri_lankan_phone_number("0094702343221")
True
>>> is_sri_lankan_phone_number("075 3201568")
True
>>> is_sri_lankan_phone_number("07779209245")
False
>>> is_sri_lankan_phone_number("0957651234")
False

File: is_valid_email_address.py
 - Function 'is_valid_email_address' takes 1 arguments: email.  Docstring: Returns True if the passed email address is valid.

The local part of the email precedes the singular @ symbol and
is associated with a display-name. For example, "john.smith"
The domain is stricter than the local part and follows the @ symbol.

Global email checks:
 1. There can only be one @ symbol in the email address. Technically if the
    @ symbol is quoted in the local-part, then it is valid, however this
    implementation ignores "" for now.
    (See https://en.wikipedia.org/wiki/Email_address#:~:text=If%20quoted,)
 2. The local-part and the domain are limited to a certain number of octets. With
    unicode storing a single character in one byte, each octet is equivalent to
    a character. Hence, we can just check the length of the string.
Checks for the local-part:
 3. The local-part may contain: upper and lowercase latin letters, digits 0 to 9,
    and printable characters (!#$%&'*+-/=?^_`{|}~)
 4. The local-part may also contain a "." in any place that is not the first or
    last character, and may not have more than one "." consecutively.

Checks for the domain:
 5. The domain may contain: upper and lowercase latin letters and digits 0 to 9
 6. Hyphen "-", provided that it is not the first or last character
 7. The domain may also contain a "." in any place that is not the first or
    last character, and may not have more than one "." consecutively.

>>> for email, valid in email_tests:
...     assert is_valid_email_address(email) == valid

File: jaro_winkler.py
 - Function 'jaro_winkler' takes 2 arguments: str1, str2.  Docstring: Jaro-Winkler distance is a string metric measuring an edit distance between two
sequences.
Output value is between 0.0 and 1.0.

>>> jaro_winkler("martha", "marhta")
0.9611111111111111
>>> jaro_winkler("CRATE", "TRACE")
0.7333333333333334
>>> jaro_winkler("test", "dbdbdbdb")
0.0
>>> jaro_winkler("test", "test")
1.0
>>> jaro_winkler("hello world", "HeLLo W0rlD")
0.6363636363636364
>>> jaro_winkler("test", "")
0.0
>>> jaro_winkler("hello", "world")
0.4666666666666666
>>> jaro_winkler("hell**o", "*world")
0.4365079365079365
 - Function 'get_matched_characters' takes 2 arguments: _str1, _str2.  No docstring available.

File: join.py
 - Function 'join' takes 2 arguments: separator, separated.  Docstring: Joins a list of strings using a separator
and returns the result.

:param separator: Separator to be used
            for joining the strings.
:param separated: List of strings to be joined.

:return: Joined string with the specified separator.

Examples:

>>> join("", ["a", "b", "c", "d"])
'abcd'
>>> join("#", ["a", "b", "c", "d"])
'a#b#c#d'
>>> join("#", "a")
'a'
>>> join(" ", ["You", "are", "amazing!"])
'You are amazing!'

This example should raise an
exception for non-string elements:
>>> join("#", ["a", "b", "c", 1])
Traceback (most recent call last):
    ...
Exception: join() accepts only strings

Additional test case with a different separator:
>>> join("-", ["apple", "banana", "cherry"])
'apple-banana-cherry'

File: knuth_morris_pratt.py
 - Function 'knuth_morris_pratt' takes 2 arguments: text, pattern.  Docstring: The Knuth-Morris-Pratt Algorithm for finding a pattern within a piece of text
with complexity O(n + m)

1) Preprocess pattern to identify any suffixes that are identical to prefixes

    This tells us where to continue from if we get a mismatch between a character
    in our pattern and the text.

2) Step through the text one character at a time and compare it to a character in
    the pattern updating our location within the pattern if necessary

>>> kmp = "knuth_morris_pratt"
>>> all(
...    knuth_morris_pratt(kmp, s) == kmp.find(s)
...    for s in ("kn", "h_m", "rr", "tt", "not there")
... )
True
 - Function 'get_failure_array' takes 1 arguments: pattern.  Docstring: Calculates the new index we should go to if we fail a comparison
:param pattern:
:return:

File: levenshtein_distance.py
 - Function 'levenshtein_distance' takes 2 arguments: first_word, second_word.  Docstring: Implementation of the Levenshtein distance in Python.
:param first_word: the first word to measure the difference.
:param second_word: the second word to measure the difference.
:return: the levenshtein distance between the two words.
Examples:
>>> levenshtein_distance("planet", "planetary")
3
>>> levenshtein_distance("", "test")
4
>>> levenshtein_distance("book", "back")
2
>>> levenshtein_distance("book", "book")
0
>>> levenshtein_distance("test", "")
4
>>> levenshtein_distance("", "")
0
>>> levenshtein_distance("orchestration", "container")
10
 - Function 'levenshtein_distance_optimized' takes 2 arguments: first_word, second_word.  Docstring: Compute the Levenshtein distance between two words (strings).
The function is optimized for efficiency by modifying rows in place.
:param first_word: the first word to measure the difference.
:param second_word: the second word to measure the difference.
:return: the Levenshtein distance between the two words.
Examples:
>>> levenshtein_distance_optimized("planet", "planetary")
3
>>> levenshtein_distance_optimized("", "test")
4
>>> levenshtein_distance_optimized("book", "back")
2
>>> levenshtein_distance_optimized("book", "book")
0
>>> levenshtein_distance_optimized("test", "")
4
>>> levenshtein_distance_optimized("", "")
0
>>> levenshtein_distance_optimized("orchestration", "container")
10
 - Function 'benchmark_levenshtein_distance' takes 1 arguments: func.  Docstring: Benchmark the Levenshtein distance function.
:param str: The name of the function being benchmarked.
:param func: The function to be benchmarked.

File: lower.py
 - Function 'lower' takes 1 arguments: word.  Docstring: Will convert the entire string to lowercase letters

>>> lower("wow")
'wow'
>>> lower("HellZo")
'hellzo'
>>> lower("WHAT")
'what'
>>> lower("wh[]32")
'wh[]32'
>>> lower("whAT")
'what'

File: manacher.py
 - Function 'palindromic_string' takes 1 arguments: input_string.  Docstring: >>> palindromic_string('abbbaba')
'abbba'
>>> palindromic_string('ababa')
'ababa'

Manacher's algorithm which finds Longest palindromic Substring in linear time.

1. first this convert input_string("xyx") into new_string("x|y|x") where odd
    positions are actual input characters.
2. for each character in new_string it find corresponding length and
    store the length and left,right to store previously calculated info.
    (please look the explanation for details)

3. return corresponding output_string by removing all "|"

File: min_cost_string_conversion.py
 - Function 'compute_transform_tables' takes 6 arguments: source_string, destination_string, copy_cost, replace_cost, delete_cost, insert_cost.  No docstring available.
 - Function 'assemble_transformation' takes 3 arguments: ops, i, j.  No docstring available.

File: naive_string_search.py
 - Function 'naive_pattern_search' takes 2 arguments: s, pattern.  Docstring: >>> naive_pattern_search("ABAAABCDBBABCDDEBCABC", "ABC")
[4, 10, 18]
>>> naive_pattern_search("ABC", "ABAAABCDBBABCDDEBCABC")
[]
>>> naive_pattern_search("", "ABC")
[]
>>> naive_pattern_search("TEST", "TEST")
[0]
>>> naive_pattern_search("ABCDEGFTEST", "TEST")
[7]

File: ngram.py
 - Function 'create_ngram' takes 2 arguments: sentence, ngram_size.  Docstring: Create ngrams from a sentence

>>> create_ngram("I am a sentence", 2)
['I ', ' a', 'am', 'm ', ' a', 'a ', ' s', 'se', 'en', 'nt', 'te', 'en', 'nc', 'ce']
>>> create_ngram("I am an NLPer", 2)
['I ', ' a', 'am', 'm ', ' a', 'an', 'n ', ' N', 'NL', 'LP', 'Pe', 'er']
>>> create_ngram("This is short", 50)
[]

File: palindrome.py
 - Function 'is_palindrome' takes 1 arguments: s.  Docstring: Return True if s is a palindrome otherwise return False.

>>> all(is_palindrome(key) is value for key, value in test_data.items())
True
 - Function 'is_palindrome_traversal' takes 1 arguments: s.  Docstring: Return True if s is a palindrome otherwise return False.

>>> all(is_palindrome_traversal(key) is value for key, value in test_data.items())
True
 - Function 'is_palindrome_recursive' takes 1 arguments: s.  Docstring: Return True if s is a palindrome otherwise return False.

>>> all(is_palindrome_recursive(key) is value for key, value in test_data.items())
True
 - Function 'is_palindrome_slice' takes 1 arguments: s.  Docstring: Return True if s is a palindrome otherwise return False.

>>> all(is_palindrome_slice(key) is value for key, value in test_data.items())
True
 - Function 'benchmark_function' takes 1 arguments: name.  No docstring available.

File: pig_latin.py
 - Function 'pig_latin' takes 1 arguments: word.  Docstring: Compute the piglatin of a given string.

https://en.wikipedia.org/wiki/Pig_Latin

Usage examples:
>>> pig_latin("pig")
'igpay'
>>> pig_latin("latin")
'atinlay'
>>> pig_latin("banana")
'ananabay'
>>> pig_latin("friends")
'iendsfray'
>>> pig_latin("smile")
'ilesmay'
>>> pig_latin("string")
'ingstray'
>>> pig_latin("eat")
'eatway'
>>> pig_latin("omelet")
'omeletway'
>>> pig_latin("are")
'areway'
>>> pig_latin(" ")
''
>>> pig_latin(None)
''

File: prefix_function.py
 - Function 'prefix_function' takes 1 arguments: input_string.  Docstring: For the given string this function computes value for each index(i),
which represents the longest coincidence of prefix and suffix
for given substring (input_str[0...i])

For the value of the first element the algorithm always returns 0

>>> prefix_function("aabcdaabc")
[0, 1, 0, 0, 0, 1, 2, 3, 4]
>>> prefix_function("asdasdad")
[0, 0, 0, 1, 2, 3, 4, 0]
 - Function 'longest_prefix' takes 1 arguments: input_str.  Docstring: Prefix-function use case
Finding longest prefix which is suffix as well

>>> longest_prefix("aabcdaabc")
4
>>> longest_prefix("asdasdad")
4
>>> longest_prefix("abcab")
2

File: rabin_karp.py
 - Function 'rabin_karp' takes 2 arguments: pattern, text.  Docstring: The Rabin-Karp Algorithm for finding a pattern within a piece of text
with complexity O(nm), most efficient when it is used with multiple patterns
as it is able to check if any of a set of patterns match a section of text in o(1)
given the precomputed hashes.

This will be the simple version which only assumes one pattern is being searched
for but it's not hard to modify

1) Calculate pattern hash

2) Step through the text one character at a time passing a window with the same
    length as the pattern
    calculating the hash of the text within the window compare it with the hash
    of the pattern. Only testing equality if the hashes match
 - Function 'test_rabin_karp' takes 0 arguments: .  Docstring: >>> test_rabin_karp()
Success.

File: remove_duplicate.py
 - Function 'remove_duplicates' takes 1 arguments: sentence.  Docstring: Remove duplicates from sentence
>>> remove_duplicates("Python is great and Java is also great")
'Java Python also and great is'
>>> remove_duplicates("Python   is      great and Java is also great")
'Java Python also and great is'

File: reverse_letters.py
 - Function 'reverse_letters' takes 2 arguments: sentence, length.  Docstring: Reverse all words that are longer than the given length of characters in a sentence.
If unspecified, length is taken as 0

>>> reverse_letters("Hey wollef sroirraw", 3)
'Hey fellow warriors'
>>> reverse_letters("nohtyP is nohtyP", 2)
'Python is Python'
>>> reverse_letters("1 12 123 1234 54321 654321", 0)
'1 21 321 4321 12345 123456'
>>> reverse_letters("racecar")
'racecar'

File: reverse_words.py
 - Function 'reverse_words' takes 1 arguments: input_str.  Docstring: Reverses words in a given string
>>> reverse_words("I love Python")
'Python love I'
>>> reverse_words("I     Love          Python")
'Python Love I'

File: snake_case_to_camel_pascal_case.py
 - Function 'snake_to_camel_case' takes 2 arguments: input_str, use_pascal.  Docstring: Transforms a snake_case given string to camelCase (or PascalCase if indicated)
(defaults to not use Pascal)

>>> snake_to_camel_case("some_random_string")
'someRandomString'

>>> snake_to_camel_case("some_random_string", use_pascal=True)
'SomeRandomString'

>>> snake_to_camel_case("some_random_string_with_numbers_123")
'someRandomStringWithNumbers123'

>>> snake_to_camel_case("some_random_string_with_numbers_123", use_pascal=True)
'SomeRandomStringWithNumbers123'

>>> snake_to_camel_case(123)
Traceback (most recent call last):
    ...
ValueError: Expected string as input, found <class 'int'>

>>> snake_to_camel_case("some_string", use_pascal="True")
Traceback (most recent call last):
    ...
ValueError: Expected boolean as use_pascal parameter, found <class 'str'>

File: split.py
 - Function 'split' takes 2 arguments: string, separator.  Docstring: Will split the string up into all the values separated by the separator
(defaults to spaces)

>>> split("apple#banana#cherry#orange",separator='#')
['apple', 'banana', 'cherry', 'orange']

>>> split("Hello there")
['Hello', 'there']

>>> split("11/22/63",separator = '/')
['11', '22', '63']

>>> split("12:43:39",separator = ":")
['12', '43', '39']

File: string_switch_case.py
 - Function 'split_input' takes 1 arguments: str_.  Docstring: >>> split_input("one two 31235three4four")
[['one', 'two', '31235three4four']]
 - Function 'to_simple_case' takes 1 arguments: str_.  Docstring: >>> to_simple_case("one two 31235three4four")
'OneTwo31235three4four'
>>> to_simple_case("This should be combined")
'ThisShouldBeCombined'
>>> to_simple_case("The first letters are capitalized, then string is merged")
'TheFirstLettersAreCapitalizedThenStringIsMerged'
>>> to_simple_case("special characters :, ', %, ^, $, are ignored")
'SpecialCharactersAreIgnored'
 - Function 'to_complex_case' takes 3 arguments: text, upper, separator.  Docstring: Returns the string concatenated with the delimiter we provide.

Parameters:
@text: The string on which we want to perform operation
@upper: Boolean value to determine whether we want capitalized result or not
@separator: The delimiter with which we want to concatenate words

Examples:
>>> to_complex_case("one two 31235three4four", True, "_")
'ONE_TWO_31235THREE4FOUR'
>>> to_complex_case("one two 31235three4four", False, "-")
'one-two-31235three4four'
 - Function 'to_pascal_case' takes 1 arguments: text.  Docstring: >>> to_pascal_case("one two 31235three4four")
'OneTwo31235three4four'
 - Function 'to_camel_case' takes 1 arguments: text.  Docstring: >>> to_camel_case("one two 31235three4four")
'oneTwo31235three4four'
 - Function 'to_snake_case' takes 2 arguments: text, upper.  Docstring: >>> to_snake_case("one two 31235three4four", True)
'ONE_TWO_31235THREE4FOUR'
>>> to_snake_case("one two 31235three4four", False)
'one_two_31235three4four'
 - Function 'to_kebab_case' takes 2 arguments: text, upper.  Docstring: >>> to_kebab_case("one two 31235three4four", True)
'ONE-TWO-31235THREE4FOUR'
>>> to_kebab_case("one two 31235three4four", False)
'one-two-31235three4four'

File: strip.py
 - Function 'strip' takes 2 arguments: user_string, characters.  Docstring: Remove leading and trailing characters (whitespace by default) from a string.

Args:
    user_string (str): The input string to be stripped.
    characters (str, optional): Optional characters to be removed
            (default is whitespace).

Returns:
    str: The stripped string.

Examples:
    >>> strip("   hello   ")
    'hello'
    >>> strip("...world...", ".")
    'world'
    >>> strip("123hello123", "123")
    'hello'
    >>> strip("")
    ''

File: text_justification.py
 - Function 'text_justification' takes 2 arguments: word, max_width.  Docstring: Will format the string such that each line has exactly
(max_width) characters and is fully (left and right) justified,
and return the list of justified text.

example 1:
string = "This is an example of text justification."
max_width = 16

output = ['This    is    an',
          'example  of text',
          'justification.  ']

>>> text_justification("This is an example of text justification.", 16)
['This    is    an', 'example  of text', 'justification.  ']

example 2:
string = "Two roads diverged in a yellow wood"
max_width = 16
output = ['Two        roads',
          'diverged   in  a',
          'yellow wood     ']

>>> text_justification("Two roads diverged in a yellow wood", 16)
['Two        roads', 'diverged   in  a', 'yellow wood     ']

Time complexity: O(m*n)
Space complexity: O(m*n)
 - Function 'justify' takes 3 arguments: line, width, max_width.  No docstring available.

File: title.py
 - Function 'to_title_case' takes 1 arguments: word.  Docstring: Converts a string to capitalized case, preserving the input as is

>>> to_title_case("Aakash")
'Aakash'

>>> to_title_case("aakash")
'Aakash'

>>> to_title_case("AAKASH")
'Aakash'

>>> to_title_case("aAkAsH")
'Aakash'
 - Function 'sentence_to_title_case' takes 1 arguments: input_str.  Docstring: Converts a string to title case, preserving the input as is

>>> sentence_to_title_case("Aakash Giri")
'Aakash Giri'

>>> sentence_to_title_case("aakash giri")
'Aakash Giri'

>>> sentence_to_title_case("AAKASH GIRI")
'Aakash Giri'

>>> sentence_to_title_case("aAkAsH gIrI")
'Aakash Giri'

File: top_k_frequent_words.py
 - Function '__init__' takes 3 arguments: self, word, count.  No docstring available.
 - Function '__eq__' takes 2 arguments: self, other.  Docstring: >>> WordCount('a', 1).__eq__(WordCount('b', 1))
True
>>> WordCount('a', 1).__eq__(WordCount('a', 1))
True
>>> WordCount('a', 1).__eq__(WordCount('a', 2))
False
>>> WordCount('a', 1).__eq__(WordCount('b', 2))
False
>>> WordCount('a', 1).__eq__(1)
NotImplemented
 - Function '__lt__' takes 2 arguments: self, other.  Docstring: >>> WordCount('a', 1).__lt__(WordCount('b', 1))
False
>>> WordCount('a', 1).__lt__(WordCount('a', 1))
False
>>> WordCount('a', 1).__lt__(WordCount('a', 2))
True
>>> WordCount('a', 1).__lt__(WordCount('b', 2))
True
>>> WordCount('a', 2).__lt__(WordCount('a', 1))
False
>>> WordCount('a', 2).__lt__(WordCount('b', 1))
False
>>> WordCount('a', 1).__lt__(1)
NotImplemented
 - Function 'top_k_frequent_words' takes 2 arguments: words, k_value.  Docstring: Returns the `k_value` most frequently occurring words,
in non-increasing order of occurrence.
In this context, a word is defined as an element in the provided list.

In case `k_value` is greater than the number of distinct words, a value of k equal
to the number of distinct words will be considered, instead.

>>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 3)
['c', 'a', 'b']
>>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 2)
['c', 'a']
>>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 1)
['c']
>>> top_k_frequent_words(['a', 'b', 'c', 'a', 'c', 'c'], 0)
[]
>>> top_k_frequent_words([], 1)
[]
>>> top_k_frequent_words(['a', 'a'], 2)
['a']

File: upper.py
 - Function 'upper' takes 1 arguments: word.  Docstring: Convert an entire string to ASCII uppercase letters by looking for lowercase ASCII
letters and subtracting 32 from their integer representation to get the uppercase
letter.

>>> upper("wow")
'WOW'
>>> upper("Hello")
'HELLO'
>>> upper("WHAT")
'WHAT'
>>> upper("wh[]32")
'WH[]32'

File: wave.py
 - Function 'wave' takes 1 arguments: txt.  Docstring: Returns a so called 'wave' of a given string
>>> wave('cat')
['Cat', 'cAt', 'caT']
>>> wave('one')
['One', 'oNe', 'onE']
>>> wave('book')
['Book', 'bOok', 'boOk', 'booK']

File: wildcard_pattern_matching.py
 - Function 'match_pattern' takes 2 arguments: input_string, pattern.  Docstring: uses bottom-up dynamic programming solution for matching the input
string with a given pattern.

Runtime: O(len(input_string)*len(pattern))

Arguments
--------
input_string: str, any string which should be compared with the pattern
pattern: str, the string that represents a pattern and may contain
'.' for single character matches and '*' for zero or more of preceding character
matches

Note
----
the pattern cannot start with a '*',
because there should be at least one character before *

Returns
-------
A Boolean denoting whether the given string follows the pattern

Examples
-------
>>> match_pattern("aab", "c*a*b")
True
>>> match_pattern("dabc", "*abc")
False
>>> match_pattern("aaa", "aa")
False
>>> match_pattern("aaa", "a.a")
True
>>> match_pattern("aaab", "aa*")
False
>>> match_pattern("aaab", ".*")
True
>>> match_pattern("a", "bbbb")
False
>>> match_pattern("", "bbbb")
False
>>> match_pattern("a", "")
False
>>> match_pattern("", "")
True

File: word_occurrence.py
 - Function 'word_occurrence' takes 1 arguments: sentence.  Docstring: >>> from collections import Counter
>>> SENTENCE = "a b A b c b d b d e f e g e h e i e j e 0"
>>> occurence_dict = word_occurrence(SENTENCE)
>>> all(occurence_dict[word] == count for word, count
...     in Counter(SENTENCE.split()).items())
True
>>> dict(word_occurrence("Two  spaces"))
{'Two': 1, 'spaces': 1}

File: word_patterns.py
 - Function 'get_word_pattern' takes 1 arguments: word.  Docstring: Returns numerical pattern of character appearances in given word
>>> get_word_pattern("")
''
>>> get_word_pattern(" ")
'0'
>>> get_word_pattern("pattern")
'0.1.2.2.3.4.5'
>>> get_word_pattern("word pattern")
'0.1.2.3.4.5.6.7.7.8.2.9'
>>> get_word_pattern("get word pattern")
'0.1.2.3.4.5.6.7.3.8.9.2.2.1.6.10'
>>> get_word_pattern()
Traceback (most recent call last):
...
TypeError: get_word_pattern() missing 1 required positional argument: 'word'
>>> get_word_pattern(1)
Traceback (most recent call last):
...
AttributeError: 'int' object has no attribute 'upper'
>>> get_word_pattern(1.1)
Traceback (most recent call last):
...
AttributeError: 'float' object has no attribute 'upper'
>>> get_word_pattern([])
Traceback (most recent call last):
...
AttributeError: 'list' object has no attribute 'upper'

File: z_function.py
 - Function 'z_function' takes 1 arguments: input_str.  Docstring: For the given string this function computes value for each index,
which represents the maximal length substring starting from the index
and is the same as the prefix of the same size

e.x.  for string 'abab' for second index value would be 2

For the value of the first element the algorithm always returns 0

>>> z_function("abracadabra")
[0, 0, 0, 1, 0, 1, 0, 4, 0, 0, 1]
>>> z_function("aaaa")
[0, 3, 2, 1]
>>> z_function("zxxzxxz")
[0, 0, 0, 4, 0, 0, 1]
 - Function 'go_next' takes 3 arguments: i, z_result, s.  Docstring: Check if we have to move forward to the next characters or not
 - Function 'find_pattern' takes 2 arguments: pattern, input_str.  Docstring: Example of using z-function for pattern occurrence
Given function returns the number of times 'pattern'
appears in 'input_str' as a substring

>>> find_pattern("abr", "abracadabra")
2
>>> find_pattern("a", "aaaa")
4
>>> find_pattern("xz", "zxxzxxz")
2

File: co2_emission.py
 - Function 'fetch_last_half_hour' takes 0 arguments: .  No docstring available.
 - Function 'fetch_from_to' takes 2 arguments: start, end.  No docstring available.

File: covid_stats_via_xpath.py
 - Function 'covid_stats' takes 1 arguments: url.  No docstring available.

File: crawl_google_results.py

File: crawl_google_scholar_citation.py
 - Function 'get_citation' takes 2 arguments: base_url, params.  Docstring: Return the citation number.

File: currency_converter.py
 - Function 'convert_currency' takes 4 arguments: from_, to, amount, api_key.  Docstring: https://www.amdoren.com/currency-api/

File: current_stock_price.py
 - Function 'stock_price' takes 1 arguments: symbol.  No docstring available.

File: current_weather.py
 - Function 'current_weather' takes 1 arguments: location.  Docstring: >>> current_weather("location")
Traceback (most recent call last):
    ...
ValueError: No API keys provided or no valid data returned.

File: daily_horoscope.py
 - Function 'horoscope' takes 2 arguments: zodiac_sign, day.  No docstring available.

File: download_images_from_google_query.py
 - Function 'download_images_from_google_query' takes 2 arguments: query, max_images.  Docstring: Searches google using the provided query term and downloads the images in a folder.

Args:
     query : The image search term to be provided by the user. Defaults to
    "dhaka".
    image_numbers : [description]. Defaults to 5.

Returns:
    The number of images successfully downloaded.

# Comment out slow (4.20s call) doctests
# >>> download_images_from_google_query()
5
# >>> download_images_from_google_query("potato")
5

File: emails_from_url.py
 - Function '__init__' takes 2 arguments: self, domain.  No docstring available.
 - Function 'handle_starttag' takes 3 arguments: self, tag, attrs.  Docstring: This function parse html to take takes url from tags
 - Function 'get_domain_name' takes 1 arguments: url.  Docstring: This function get the main domain name

>>> get_domain_name("https://a.b.c.d/e/f?g=h,i=j#k")
'c.d'
>>> get_domain_name("Not a URL!")
''
 - Function 'get_sub_domain_name' takes 1 arguments: url.  Docstring: >>> get_sub_domain_name("https://a.b.c.d/e/f?g=h,i=j#k")
'a.b.c.d'
>>> get_sub_domain_name("Not a URL!")
''
 - Function 'emails_from_url' takes 1 arguments: url.  Docstring: This function takes url and return all valid urls

File: fetch_anime_and_play.py
 - Function 'search_scraper' takes 1 arguments: anime_name.  Docstring: [summary]

Take an url and
return list of anime after scraping the site.

>>> type(search_scraper("demon_slayer"))
<class 'list'>

Args:
    anime_name (str): [Name of anime]

Raises:
    e: [Raises exception on failure]

Returns:
    [list]: [List of animes]
 - Function 'search_anime_episode_list' takes 1 arguments: episode_endpoint.  Docstring: [summary]

Take an url and
return list of episodes after scraping the site
for an url.

>>> type(search_anime_episode_list("/anime/kimetsu-no-yaiba"))
<class 'list'>

Args:
    episode_endpoint (str): [Endpoint of episode]

Raises:
    e: [description]

Returns:
    [list]: [List of episodes]
 - Function 'get_anime_episode' takes 1 arguments: episode_endpoint.  Docstring: [summary]

Get click url and download url from episode url

>>> type(get_anime_episode("/watch/kimetsu-no-yaiba/1"))
<class 'list'>

Args:
    episode_endpoint (str): [Endpoint of episode]

Raises:
    e: [description]

Returns:
    [list]: [List of download and watch url]

File: fetch_bbc_news.py
 - Function 'fetch_bbc_news' takes 1 arguments: bbc_news_api_key.  No docstring available.

File: fetch_github_info.py
 - Function 'fetch_github_info' takes 1 arguments: auth_token.  Docstring: Fetch GitHub info of a user using the requests module

File: fetch_jobs.py
 - Function 'fetch_jobs' takes 1 arguments: location.  No docstring available.

File: fetch_quotes.py
 - Function 'quote_of_the_day' takes 0 arguments: .  No docstring available.
 - Function 'random_quotes' takes 0 arguments: .  No docstring available.

File: fetch_well_rx_price.py
 - Function 'fetch_pharmacy_and_price_list' takes 2 arguments: drug_name, zip_code.  Docstring: [summary]

This function will take input of drug name and zipcode,
then request to the BASE_URL site.
Get the page data and scrape it to the generate the
list of lowest prices for the prescription drug.

Args:
    drug_name (str): [Drug name]
    zip_code(str): [Zip code]

Returns:
    list: [List of pharmacy name and price]

>>> fetch_pharmacy_and_price_list(None, None)

>>> fetch_pharmacy_and_price_list(None, 30303)

>>> fetch_pharmacy_and_price_list("eliquis", None)

File: get_amazon_product_data.py
 - Function 'get_amazon_product_data' takes 1 arguments: product.  Docstring: Take a product name or category as input and return product information from Amazon
including title, URL, price, ratings, and the discount available.

File: get_imdb_top_250_movies_csv.py
 - Function 'get_imdb_top_250_movies' takes 1 arguments: url.  No docstring available.
 - Function 'write_movies' takes 1 arguments: filename.  No docstring available.

File: get_ip_geolocation.py
 - Function 'get_ip_geolocation' takes 1 arguments: ip_address.  No docstring available.

File: get_top_billionaires.py
 - Function 'years_old' takes 2 arguments: birth_timestamp, today.  Docstring: Calculate the age in years based on the given birth date.  Only the year, month,
and day are used in the calculation.  The time of day is ignored.

Args:
    birth_timestamp: The date of birth.
    today: (useful for writing tests) or if None then datetime.date.today().

Returns:
    int: The age in years.

Examples:
>>> today = date(2024, 1, 12)
>>> years_old(birth_timestamp=datetime(1959, 11, 20).timestamp(), today=today)
64
>>> years_old(birth_timestamp=datetime(1970, 2, 13).timestamp(), today=today)
53
>>> all(
...     years_old(datetime(today.year - i, 1, 12).timestamp(), today=today) == i
...     for i in range(1, 111)
... )
True
 - Function 'get_forbes_real_time_billionaires' takes 0 arguments: .  Docstring: Get the top 10 real-time billionaires using Forbes API.

Returns:
    List of top 10 realtime billionaires data.
 - Function 'display_billionaires' takes 1 arguments: forbes_billionaires.  Docstring: Display Forbes real-time billionaires in a rich table.

Args:
    forbes_billionaires (list): Forbes top 10 real-time billionaires

File: get_top_hn_posts.py
 - Function 'get_hackernews_story' takes 1 arguments: story_id.  No docstring available.
 - Function 'hackernews_top_stories' takes 1 arguments: max_stories.  Docstring: Get the top max_stories posts from HackerNews - https://news.ycombinator.com/
 - Function 'hackernews_top_stories_as_markdown' takes 1 arguments: max_stories.  No docstring available.

File: get_user_tweets.py
 - Function 'get_all_tweets' takes 1 arguments: screen_name.  No docstring available.

File: giphy.py
 - Function 'get_gifs' takes 2 arguments: query, api_key.  Docstring: Get a list of URLs of GIFs based on a given query..

File: instagram_crawler.py
 - Function 'extract_user_profile' takes 1 arguments: script.  Docstring: May raise json.decoder.JSONDecodeError
 - Function '__init__' takes 2 arguments: self, username.  No docstring available.
 - Function 'get_json' takes 1 arguments: self.  Docstring: Return a dict of user information
 - Function '__repr__' takes 1 arguments: self.  No docstring available.
 - Function '__str__' takes 1 arguments: self.  No docstring available.
 - Function 'username' takes 1 arguments: self.  No docstring available.
 - Function 'fullname' takes 1 arguments: self.  No docstring available.
 - Function 'biography' takes 1 arguments: self.  No docstring available.
 - Function 'email' takes 1 arguments: self.  No docstring available.
 - Function 'website' takes 1 arguments: self.  No docstring available.
 - Function 'number_of_followers' takes 1 arguments: self.  No docstring available.
 - Function 'number_of_followings' takes 1 arguments: self.  No docstring available.
 - Function 'number_of_posts' takes 1 arguments: self.  No docstring available.
 - Function 'profile_picture_url' takes 1 arguments: self.  No docstring available.
 - Function 'is_verified' takes 1 arguments: self.  No docstring available.
 - Function 'is_private' takes 1 arguments: self.  No docstring available.
 - Function 'test_instagram_user' takes 1 arguments: username.  Docstring: A self running doctest
>>> test_instagram_user()

File: instagram_pic.py
 - Function 'download_image' takes 1 arguments: url.  Docstring: Download an image from a given URL by scraping the 'og:image' meta tag.

Parameters:
    url: The URL to scrape.

Returns:
    A message indicating the result of the operation.

File: instagram_video.py
 - Function 'download_video' takes 1 arguments: url.  No docstring available.

File: nasa_data.py
 - Function 'get_apod_data' takes 1 arguments: api_key.  Docstring: Get the APOD(Astronomical Picture of the day) data
Get your API Key from: https://api.nasa.gov/
 - Function 'save_apod' takes 2 arguments: api_key, path.  No docstring available.
 - Function 'get_archive_data' takes 1 arguments: query.  Docstring: Get the data of a particular query from NASA archives

File: open_google_results.py

File: random_anime_character.py
 - Function 'save_image' takes 2 arguments: image_url, image_title.  Docstring: Saves the image of anime character
 - Function 'random_anime_character' takes 0 arguments: .  Docstring: Returns the Title, Description, and Image Title of a random anime character .

File: recaptcha_verification.py
 - Function 'login_using_recaptcha' takes 1 arguments: request.  No docstring available.

File: reddit.py
 - Function 'get_subreddit_data' takes 4 arguments: subreddit, limit, age, wanted_data.  Docstring: subreddit : Subreddit to query
limit : Number of posts to fetch
age : ["new", "top", "hot"]
wanted_data : Get only the required data in the list

File: search_books_by_isbn.py
 - Function 'get_openlibrary_data' takes 1 arguments: olid.  Docstring: Given an 'isbn/0140328726', return book data from Open Library as a Python dict.
Given an '/authors/OL34184A', return authors data as a Python dict.
This code must work for olids with or without a leading slash ('/').

# Comment out doctests if they take too long or have results that may change
# >>> get_openlibrary_data(olid='isbn/0140328726')  # doctest: +ELLIPSIS
{'publishers': ['Puffin'], 'number_of_pages': 96, 'isbn_10': ['0140328726'], ...
# >>> get_openlibrary_data(olid='/authors/OL7353617A')  # doctest: +ELLIPSIS
{'name': 'Adrian Brisku', 'created': {'type': '/type/datetime', ...
 - Function 'summarize_book' takes 1 arguments: ol_book_data.  Docstring: Given Open Library book data, return a summary as a Python dict.

File: slack_message.py
 - Function 'send_slack_message' takes 2 arguments: message_body, slack_url.  No docstring available.

File: test_fetch_github_info.py
 - Function 'test_fetch_github_info' takes 1 arguments: monkeypatch.  No docstring available.
 - Function '__init__' takes 2 arguments: self, content.  No docstring available.
 - Function 'json' takes 1 arguments: self.  No docstring available.
 - Function 'mock_response' takes 0 arguments: .  No docstring available.

File: world_covid19_stats.py
 - Function 'world_covid19_stats' takes 1 arguments: url.  Docstring: Return a dict of current worldwide COVID-19 statistics
